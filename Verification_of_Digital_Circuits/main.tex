\documentclass{standalone}

\input{./content/packages}
\input{./content/desgin}
\input{./content/declarations}

\begin{document}
\begin{mindmap}
  \begin{mindmapcontent}
    \node (middle) at (current page.center) {Verification of Digital Circuits
      \resizebox{\textwidth}{!}{
        \begin{minipage}[t]{18cm}
        \end{minipage}
      }
    }
    child {
      node {Basics}
      child {
        node {Propositional Logic
          \resizebox{\textwidth}{!}{
            \begin{minipage}[t]{12cm}
              \begin{itemize}
                \item \script{128}{Syntax inductively and as context-free grammar}
                \item \script{129}{Semantics}
                \item \script{131}{Literal, Clause, Conjunctive Normal Form (CNF) (f.)}
                \begin{itemize}
                  \item \script{170}{Notation: Set of literals, empty clause} and \script{172}{Notation: CNF formula set of clauses, empty formula}
                  \item \script{171}{Operations on clauses} and \script{172}{Union of two CNF formulas}
                \end{itemize}
                \item \script{144}{Equivalence}
              \end{itemize}
            \end{minipage}
          }
        }
        child {
          node {Resolution
            \resizebox{\textwidth}{!}{
              \begin{minipage}[t]{12cm}
                \begin{itemize}
                  \item \script{174}{Definition, resolvent}: $L\in C_1, \neg L \in C_2, R = (C_1 - \{L\}) \cup (C_2 - \{\neg L\})$, $R = C_1 \otimes_L C_2$
                  \begin{itemize}
                    \item \script{175}{Examples}
                  \end{itemize}
                  \item \script{176}{Resolution Lemma}: Let $F$ be a CNF formula and $R$ be the resolvent of two clauses $C_1$ and $C_2$ from $F$. Then $F$ and $F \cup \{R\}$ are equivalent: $F \equiv F \cup \{R\}$
                  \begin{itemize}
                    \item \script{177}{Proof}
                  \end{itemize}
                  \item \script{178}{$Res(F)$ etc.}
                  \begin{itemize}
                    \item $Res(F) = F \cup \{R \mid R \text{ is the resolvent of two clauses in } F\}$
                    \item $Res^0(F) = F$
                    \item $Res^{t+1}(F ) = Res(Res^t(F)) \text{ for } t \ge 0$
                    \item $Res^*(F ) = lim_{t\ge 0}\enspace Res^t(F)$
                  \end{itemize}
                  \item \script{179}{Resolution Theorem}: A CNF formula F is \alert{unsatisfiable} \textit{iff} $\square \in Res^*(F)$
                  \begin{itemize}
                    \item \script{180}{Proof}
                  \end{itemize}
                \end{itemize}
              \end{minipage}
            }
          }
        }
      }
      child {
        node {Important Definitions
          \resizebox{\textwidth}{!}{
            \begin{minipage}[t]{12cm}
              \begin{itemize}
                \item \underline{essential definitions:}
                  \begin{itemize}
                    \item \alert{verification method:} Check equivalence between specification and implementation
                    \item \alert{formal verification:} Mathematical proofs of correctness
                      \begin{itemize}
                        \item one uses \alert{formal methods} to avoid and detect design errors
                        \item because validation by simulation can never cover the complete system behavior
                      \end{itemize}
                    \item \alert{security:} A system should not leak information that should be kept secret
                    \item \alert{safety:} System does what it should do, implementation behaves as said in the specification (in this lecture)
                    \item \alert{canonical:} Exactly one representation
                    \item \alert{topological sort:} A graph traversal in which each node v is visited only after all its dependencies are visited
                    \begin{itemize}
                      \item a topological ordering is possible \alert{iff} the graph is a directed acyclic graph (DAG)
                      \item \underline{algorithm:} The algorithm loops through each node of the graph, in an arbitrary order, initiating a depth-first search that terminates when it hits any node that has already been visited since the beginning of the topological sort or the node has no outgoing edges (i.e. a leaf node)
                    \end{itemize}
                  \end{itemize}
              \end{itemize}
            \end{minipage}
          }
        }
      }
      child {
        node {Design of integrated circuits
          \resizebox{\textwidth}{!}{
            \begin{minipage}[t]{12cm}
              \begin{itemize}
                \item \underline{\script{22}{design of integrated circuits}:} 
                  \begin{itemize}
                    \item start with abstract specification and make it more and more concrete
                    \item implementation of the level before is the specification of the next level
                    \item equivalence checking for single steps easier than between initial specification and final implementation, similiarity is much higher
                    % \item more abstract SystemC Specification can be above Register-Transfer-Level
                    \item \alert{Initial Specification:} Usually in natural language
                      % \begin{itemize}
                      %   \item would need a specification in formal language e.g. specification by properties, on high level called design properties
                      % \end{itemize}
                  \end{itemize}
                  \begin{enumerate}[label=\color{PrimaryColor}\arabic*.]
                    \item \alert{Register-Transfer-Level:} Registers, Operations, Memory, no exact implementation for e.g. multiplier, don't fix the details
                      % \begin{itemize}
                      %   \item[$\textcolor{SwitchColor}{\blacksquare}$] Implementation in Hardware Description Language e.g. VHDL, Verilog
                      % \end{itemize}
                    \item \alert{Gate-Level:} Gates (AND, OR, etc.)
                    \item \alert{Layout-Level:} Placement (fix places of different components / gates) and routing (fix where connections go)
                  \end{enumerate}
                  \begin{itemize}
                    \item \alert{Final implementation:} Design data for producing the chip
                  \end{itemize}
              \end{itemize}
            \end{minipage}
          }
        }
      }
    }
    child {
      node {Basic technologies}
      child {
        node {Binary decision diagrams (BDDs)
          \resizebox{\textwidth}{!}{
            \begin{minipage}[t]{8cm}
              \begin{itemize}
                \item \script{41}{Syntax}
                \item \script{42}{Semantic}
                \item \script{45}{Example}
                \item \script{46}{Drawbacks}
                \item  The \alert{size} is given by the number of non-terminal nodes
                \item \underline{Limitations of BDDs:}
                \begin{itemize}
                  \item Canonical representation has to deal with the available memory.
                  \item Not directly usable with sequential circuits.
                  \item Not directly usable when the specification is a set of properties.
                \end{itemize}
              \end{itemize}
            \end{minipage}
          }
        }
        child {
          node {Construction of ROBDDs}
          child {
            node {Forward construction / symbolic simulation
              \resizebox{\textwidth}{!}{
                \begin{minipage}[t]{12cm}
                  \begin{itemize}
                    \item \script{104}{Algorithm}
                    \item \script{105}{Example}
                  \end{itemize}
                \end{minipage}
              }
            }
            child {
              node {ITE-Operator
                \resizebox{\textwidth}{!}{
                  \begin{minipage}[t]{14cm}
                    \begin{itemize}
                      \item all the binary operation can be reduced to a call to ITE (\enquote{If-Then-Else}-Operator)
                      \item \script{90}{Definition}: $ITE(F, G, H) = (F\wedge G)\vee(\neg F\wedge H)$
                      \begin{itemize}
                        \item the expression derives from the fact that a ITE node can be interpreted as a \alert{multiplexer} with inputs $G$ and $H$ and selector $F$
                        \item $AND(F, G) = ITE(F, G, 0) = (F\wedge G)\vee(\neg F\wedge 0) = F\wedge G$
                        \item $OR(F, G) = ITE(F, 1, G) = (F\wedge 1)\vee(\neg F\wedge G) = F \vee (\neg F \wedge G) = F\vee G$
                        \item $NOT(F) = ITE(F, 0, 1) = (F\wedge 0)\vee(\neg F\wedge 1) = \neg F$
                      \end{itemize}
                    \item \script{91}{Theorem and Proof}: $ITE(F, G, H) = (\neg x_i \wedge ITE(F_{\neg x_i}, G_{\neg x_i}, H_{\neg x_i}))\vee(x_i\wedge ITE(F_{x_i}, G_{x_i}, H_{x_i}))$
                    \item \script{93}{Algorithm to Compute a new ROBDD for ITE(F, G, H) out of ROBDD's F, G and H (ff.)}
                      \begin{itemize}
                        \item \underline{Base cases:} 
                          \begin{itemize}
                            \item $ITE(1, F, G) = ITE(0, G, F) = ITE(F, 1, 0) = ITE(G, F, F) = F$
                            \item $NOT(F) = ITE(F , 0, 1) = \neg F$
                          \end{itemize}
                        \item \script{99}{Runtime}
                      \end{itemize}
                    \end{itemize}
                  \end{minipage}
                }
              }
            }
          }
          child {
            node {Backward construction
              \resizebox{\textwidth}{!}{
                \begin{minipage}[t]{12cm}
                  \begin{itemize}
                    \item \script{116}{Algorithm}
                    \item \script{120}{Example}
                  \end{itemize}
                \end{minipage}
              }
            }
            child {
              node {Substitution operator, compose
                \resizebox{\textwidth}{!}{
                  \begin{minipage}[t]{12cm}
                    \begin{itemize}
                      \item \script{117}{Definition}: $compose(F, G, x_i)(x_1, \ldots , x_n) = F (x_1 , \ldots , x_{i-1}, G (x_1 , \ldots , x_n), x_{i+1}, \ldots , x_n)$
                      \item \script{118}{Theorem}: $compose(F, G, x_i) = ITE(G, F_{x_i}, F_{\neg x_i})$
                      \begin{itemize}
                        \item \script{119}{Proof}
                      \end{itemize}
                    \end{itemize}
                  \end{minipage}
                }
              }
            }
          }
        }
        child {
          node {Reduced Ordered Binary Decision Diagrams (ROBDDs)
            \resizebox{\textwidth}{!}{
              \begin{minipage}[t]{12cm}
                \begin{itemize}
                  \item A BDD G is a Reduced Ordered Binary Decision Diagram iff it is ordered and reduced
                    \begin{itemize}
                      \item In this context, reduced means that none of the reduction rules (\enquote{isomorphism} and \enquote{Shannon}) can be applied (anymore).
                    \end{itemize}
                  \item \script{57}{Example}
                  \item (\script{62}{Remark})
                  \item \script{65}{Proof of the Canonicity of ROBDDs}
                  \begin{itemize}
                    \item \script{64}{Definition Isomorphism}
                  \end{itemize}
                \end{itemize}
              \end{minipage}
            }
          }
          child {
            node {Reduction Rules
              \resizebox{\textwidth}{!}{
                \begin{minipage}[t]{12cm}
                  \begin{itemize}
                    \item OBDDs can be reduced to ROBDDs in layers starting from the terminal nodes
                  \end{itemize}
                \end{minipage}
              }
            }
            child {
              node {\enquote{Isomorphism} reduction
                \resizebox{\textwidth}{!}{
                  \begin{minipage}[t]{12cm}
                    \begin{itemize}
                      \item \script{51}{Definition}
                      \item \script{52}{Example}
                    \end{itemize}
                  \end{minipage}
                }
              }
            }
            child {
              node {\enquote{Shannon} reduction
                \resizebox{\textwidth}{!}{
                  \begin{minipage}[t]{12cm}
                    \begin{itemize}
                      \item \script{53}{Definition and Example}
                    \end{itemize}
                  \end{minipage}
                }
              }
            }
          }
          child {
            node {Ordered BDDs (OBDDs)
              \resizebox{\textwidth}{!}{
                \begin{minipage}[t]{12cm}
                  \begin{itemize}
                    \item A BDD G over the set of variables $X_n = \{x_1, \ldots, x_n\}$ is ordered, iff it is \alert{free} and the \alert{variables on every path} from the root to a terminal node occur in the \alert{same order}
                    \item \script{48}{information about variable order}
                    \item \script{49}{example}
                    \item This is still not enough, there can be redundancy in the OBDD
                  \end{itemize}
                \end{minipage}
              }
            }
            child {
              node {Free BDDs
                \resizebox{\textwidth}{!}{
                  \begin{minipage}[t]{12cm}
                    \begin{itemize}
                      \item A BDD G is free, iff each variable along every path from the root to a terminal node occurs at most once.
                      \item \script{47}{Example}
                    \end{itemize}
                  \end{minipage}
                }
              }
            }
          }
        }
        child {
          node {Shannon theorem
            \resizebox{\textwidth}{!}{
              \begin{minipage}[t]{8cm}
                \begin{itemize}
                  \item \script{43}{Definition}: $F = (\neg x_i\wedge F_{\neg x_i})\vee(x_i\wedge F_{x_i})$
                  \item \script{44}{Proof}
                  \item for BDD's Composition rule and Decomposition rule have the same structure
                \end{itemize}
              \end{minipage}
            }
          }
        }
        child {
          node {Use of ROBDDs in Verification
            \resizebox{\textwidth}{!}{
              \begin{minipage}[t]{12cm}
                \begin{itemize}
                  \item the size of a ROBDD depends strongly on the variable order $\pi$ one chooses
                  \begin{itemize}
                    \item \script{81}{example (f.)}
                  \end{itemize}
                  \item every cofactor regarding the first n variables consitutes a different Boolean function
                  \begin{itemize}
                    \item $2n$ different cofactors
                    \item \script{83}{example}
                  \end{itemize}
                \end{itemize}
              \end{minipage}
            }
          }
          child {
            node {Finding optimal variable order
              \resizebox{\textwidth}{!}{
                \begin{minipage}[t]{8cm}
                  \begin{itemize}
                    \item \alert{Theorem (Bollig, Savicky, Wegener, 1994):} Given a ROBDD with variable order $\pi$, the problem of finding a new variable order $\pi\prime$ with minimal ROBDD-size is NP-Complete
                      \begin{itemize}
                        \item \underline{but there are \alert{Heuristics}:}
                          \begin{itemize}
                            \item define an initial variable order based on the circuit representation
                            \item perform dynamic reordering within an existing variable order to reduce the size of the ROBDD
                          \end{itemize}
                      \end{itemize}
                  \end{itemize}
                \end{minipage}
              }
            }
            child {
              node {Define an initial variable order
                \resizebox{\textwidth}{!}{
                  \begin{minipage}[t]{12cm}
                    \begin{itemize}
                      \item \script{107}{Method of Malik}
                      \item \script{108}{Example}
                    \end{itemize}
                  \end{minipage}
                }
              }
            }
            child {
              node {Dynamic modification of the variable ordering
                \resizebox{\textwidth}{!}{
                  \begin{minipage}[t]{12cm}
                    \begin{itemize}
                      \item \script{110}{General Algorithm}
                      \begin{itemize}
                        \item \script{112}{Sifting}
                        \begin{itemize}
                          \item \script{113}{Example}
                          \item \script{114}{Runtime}
                        \end{itemize}
                      \end{itemize}
                    \end{itemize}
                  \end{minipage}
                }
              }
            }
          }
          child {
            node {Not applicable for all pratical functions
              \resizebox{\textwidth}{!}{
                \begin{minipage}[t]{12cm}
                  \begin{itemize}
                    \item \alert{Theorem (Shannon):} \enquote{Almost every} Boolean function $F\colon\, \mathbb{B}^n\rightarrow\mathbb{B}$ requires more than $(2^n / n) 2$-input gates for an optimal implementation
                    \begin{itemize}
                      \item holds also for ROBDDs, because they can be seen as multiplexer circuits
                      \item \underline{should we care?}: not really, because one does equivalence checking mostly for circuits that are not exponential (the others that are not \enquote{almost every} usually occur, because we're interested in functions with structure)
                    \end{itemize}
                    \item \alert{Lemma (Bryant, 1986):} Independently from the variable order, multiplication is representable with ROBDDs only with exponential complexity in the bit-width
                    \begin{itemize}
                      \item there exist actually polynomial mutlipliers, but there are no ROBDDs with polynomial complexity in the bit-width for them
                    \end{itemize}
                  \end{itemize}
                \end{minipage}
              }
            }
          }
        }
      }
      child {
        node {Satisfiability solvers (SAT / QBF)
          \resizebox{\textwidth}{!}{
            \begin{minipage}[t]{12cm}
              \begin{itemize}
                \item \script{130}{Satisfiable, Model, Unsatisfiable}
                \item \script{133}{Satisfiability-Problem (SAT-Problem)}
                \item \script{164}{Complexity of the SAT Problem}
                \item \script{165}{Practice and Applications}
                \item \script{167}{Overview on SAT Algorithms (f.)}, complete and incomplete methods
              \end{itemize}
            \end{minipage}
          }
        }
        child {
          node {Naive method
            \resizebox{\textwidth}{!}{
              \begin{minipage}[t]{12cm}
                \begin{itemize}
                  \item \script{181}{Algorithm}
                  \item \script{182}{Complexity}
                  \item \script{183}{Examples (ff.)}
                \end{itemize}
              \end{minipage}
            }
          }
        }
        child {
          node {DP-Algorithm
            \resizebox{\textwidth}{!}{
              \begin{minipage}[t]{12cm}
                \begin{itemize}
                  \item based on \alert{variable elimination} method and uses a couple of optimizations:
                  \begin{itemize}
                    \item \script{189}{Subsumption check}: Let $C_1$ and $C_2$ be two clauses. $C_1$ subsumes $C_2$ iff all literals occurring in $C_1$ also occur in $C_2$: $C_1 \subseteq C_2$
                      \begin{itemize}
                        \item \alert{Idea:} To satisfy a CNF formula $F$, all clauses need to be satisfied, in particular $C_1$. Since all literals of $C_1$ are also contained in $C_2$, every satisfying assignment of $C_1$ also satisfies $C_2$. Therefore $C_2$ does not need to be considered separately and can be deleted
                        \item \script{190}{Example}
                      \end{itemize}
                    \item \script{191}{Pure literal detection}: Let $F$ be a CNF-formula and $L$ a literal contained in $F$. $L$ is a \alert{pure literal} \textit{iff} $L$ is contained in $F$ either only positive or only negative, but not both $L$ and $\neg L$ appear in $F$
                    \begin{itemize}
                      \item \alert{Idea:} Delete from $F$ all clauses which contain a pure literal. They can be satisfied by an according assignment to $L$. This cannot prevent any other clause from being satisfied, because $\neg L$ does not appear in $F$
                      \item \script{192}{Example}
                    \end{itemize}
                  \end{itemize}
                  \item the optimizations improve the runtime behavior in practice, but not the worst case complexity of the naı̈ve method
                \end{itemize}
              \end{minipage}
            }
          }
        }
        child {
          node {DLL-Algorithm}
        }
      }
      child {
        node {And-inverter graphs (AIGs)
        }
      }
    }
    child {
      node (test) {Property checking
        \resizebox{\textwidth}{!}{
          \begin{minipage}[t]{12cm}
            \begin{itemize}
              \item Prove that a system specifies a set of properties
            \end{itemize}
          \end{minipage}
        }
      }
      child {
        node {Specification of properties with temporal logics}
      }
      child {
        node {Algorithms for checking properties of circuits}
      }
      child {
        node {Bounded model checking using SAT solvers}
      }
      child {
        node {Unbounded model checking}
        child {
          node {K-Induktion}
        }
        child {
          node {Craig interpolation}
        }
        child {
          node {Property directed reachability (PDR)}
        }
      }
    }
    child {
      node {Equivalence checking
        \resizebox{\textwidth}{!}{
          \begin{minipage}[t]{12cm}
            \begin{itemize}
              \item Prove that two designs have the same (functional) behavior
              \item Given two combinational circuits (i.e., without memory), do they compute the same boolean function?
              \item So one can't do better in all cases, doesn't work for all practical cases, but for many:
              \begin{itemize}
                \item Combinational Equivalence Checking is NP-hard, if there would be polynomial data in a canonical datastructure one would just have to translate both circuits into this datastructure and comparison is easy, can't assume there's a datastructure with polynomial size which is canonical
                \item some function tables are so random, it's not possible to compress them
                \item canonical disjunctive normal form, then one has as many terms as elements in the ON-Set
              \end{itemize}
            \end{itemize}
          \end{minipage}
        }
      }
      child {
        node {Combinational circuits}
        child {
          node {Application of BDDs and SAT for equivalence checking
            \resizebox{\textwidth}{!}{
              \begin{minipage}[t]{12cm}
                \begin{itemize}
                  \item \alert{Equivalence Checking Method:} Convert each circuit into a datastructure that has exactly one representation of each Boolean function. Then compare these representations
                  \item in \alert{BDD-based} equivalence checking the limiting resource is the \alert{available memory}, whereas in the \alert{SAT-based} approach this is the \alert{runtime} of the solving algorithm
                \end{itemize}
              \end{minipage}
            }
          }
          child {
            node {SAT-based Equivalence Checking
              \resizebox{\textwidth}{!}{
                \begin{minipage}[t]{12cm}
                  \begin{itemize}
                    \item \script{135}{Approach}
                    \item \script{139}{Miter Circuit with multiple outputs (f.)}
                    \item usually SAT-algorithms take as input only CNF formulas; that means the Boolean function of the miter circuit must be translated into a CNF representation
                    \item \script{162}{Example}
                  \end{itemize}
                \end{minipage}
              }
            }
            child {
              node {Conversion of a Propositional Logic Formula into CNF
                \resizebox{\textwidth}{!}{
                  \begin{minipage}[t]{12cm}
                    \begin{itemize}
                      \item every propositional logic formula $F$ can be translated into an equivalent CNF formula $F'$
                      \begin{itemize}
                        \item \script{144}{Proof}
                      \end{itemize}
                    \end{itemize}
                  \end{minipage}
                }
              }
              child {
                node {Satisfiability equivalent CNF (Tseitin Transformation)
                  \resizebox{\textwidth}{!}{
                    \begin{minipage}[t]{12cm}
                      \begin{itemize}
                        \item \script{152}{Algorithm for conversion into \alert{satisfiability equivalent} CNF}
                        \item \script{153}{Gates}
                        \item \script{154}{Example (ff.)}
                        \item as long as for the CNF representation of each single gate only a constant number of clauses is required, the number of clauses in the final CNF will be linear in the number of gates in the circuit (the same holds for the size of the formula)
                        \item \script{159}{Size comparison to equivalent CNF}
                      \end{itemize}
                    \end{minipage}
                  }
                }
              }
              child {
                node (convcnf) {Equivalent CNF
                  \resizebox{\textwidth}{!}{
                    \begin{minipage}[t]{12cm}
                      \begin{itemize}
                        \item \script{145}{Algorithm for conversion into \alert{equivalent} CNF}
                          \begin{itemize}
                            \item \script{148}{Examples (ff.)}
                          \end{itemize}
                        \item \script{146}{Size of a formula}
                          \begin{itemize}
                            \item \script{147}{Proof}
                          \end{itemize}
                      \end{itemize}
                    \end{minipage}
                  }
                }
              }
            }
          }
        }
        child {
          node {Exploitation of structural information}
        }
      }
      child {
        node {Sequential circuits}
        child {
          node {Product automata}
        }
        child {
          node {Characteristic functions}
        }
        child {
          node {Image and pre-image computations}
        }
        child {
          node {BDD-based methods for proving equivalence of two sequential circuits}
        }
        child {
          node {Generation of counterexamples}
        }
      }
    }
  \end{mindmapcontent}
  \begin{edges}
    \edge{test}{middle}
  \end{edges}
  \annotation{test}{annotation}
\end{mindmap}
\end{document}
