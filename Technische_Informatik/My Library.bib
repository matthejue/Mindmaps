@software{ActionsStarterworkflows2022,
  title = {Actions/Starter-Workflows},
  date = {2022-04-11},
  url = {https://github.com/actions/starter-workflows/blob/70f16d3552b2b728227019eb69710ed1b44cf811/ci/python-package.yml},
  urldate = {2022-04-11},
  abstract = {Accelerating new GitHub Actions workflows},
  organization = {{GitHub Actions}}
}

@online{ANormalizationWhyHow,
  title = {A-{{Normalization}}: {{Why}} and {{How}} (with Code)},
  url = {https://matt.might.net/articles/a-normalization/},
  urldate = {2022-07-23}
}

@online{ANSIGrammarLex,
  title = {{{ANSI C}} Grammar ({{Lex}})},
  url = {https://www.lysator.liu.se/c/ANSI-C-grammar-l.html},
  urldate = {2022-07-29},
  file = {/home/areo/Zotero/storage/HFF3AUH2/ANSI-C-grammar-l.html;/home/areo/Zotero/storage/XD7B4BJU/ANSI-C-grammar-l.html}
}

@online{ANSIGrammarLexa,
  title = {{{ANSI C}} Grammar ({{Lex}})},
  url = {https://www.quut.com/c/ANSI-C-grammar-l-2011.html},
  urldate = {2022-08-15},
  file = {/home/areo/Zotero/storage/P2E3RLFC/ANSI-C-grammar-l-2011.html}
}

@online{ANSIGrammarLexb,
  title = {{{ANSI C}} Grammar ({{Lex}}) Old},
  url = {https://www.lysator.liu.se/c/ANSI-C-grammar-l.html},
  urldate = {2022-08-15},
  file = {/home/areo/Zotero/storage/6TJ9I9BL/ANSI-C-grammar-l.html}
}

@online{ANSIGrammarYacc,
  title = {{{ANSI C}} Grammar ({{Yacc}})},
  url = {http://www.quut.com/c/ANSI-C-grammar-y.html},
  urldate = {2022-07-29},
  file = {/home/areo/Zotero/storage/BZFHXQ5R/ANSI-C-grammar-y.html;/home/areo/Zotero/storage/XXT4QLK3/ANSI-C-grammar-y.html}
}

@online{ANSIGrammarYacca,
  title = {{{ANSI C}} Grammar ({{Yacc}})},
  url = {https://www.quut.com/c/ANSI-C-grammar-y.html},
  urldate = {2022-08-15},
  file = {/home/areo/Zotero/storage/YC8WB87R/ANSI-C-grammar-y.html}
}

@online{ANSIGrammarYaccb,
  title = {{{ANSI C}} Grammar ({{Yacc}}) Old},
  url = {https://www.lysator.liu.se/c/ANSI-C-grammar-y.html},
  urldate = {2022-08-15},
  file = {/home/areo/Zotero/storage/3DFAJJG7/ANSI-C-grammar-y.html}
}

@online{AnswerWhatDifference2018,
  title = {Answer to "{{What}} Is the Difference between Tree Search and Graph Search?"},
  shorttitle = {Answer to "{{What}} Is the Difference between Tree Search and Graph Search?},
  date = {2018-12-16},
  url = {https://ai.stackexchange.com/a/9554},
  urldate = {2023-06-04},
  organization = {{Artificial Intelligence Stack Exchange}},
  file = {/home/areo/Zotero/storage/YJLYFXFC/what-is-the-difference-between-tree-search-and-graph-search.html}
}

@online{ANTLR,
  title = {{{ANTLR}}},
  url = {https://www.antlr.org/},
  urldate = {2022-07-31},
  file = {/home/areo/Zotero/storage/FE43SMM9/www.antlr.org.html}
}

@inreference{AnweisungProgrammierung2022,
  title = {Anweisung (Programmierung)},
  booktitle = {Wikipedia},
  date = {2022-05-17T16:43:25Z},
  url = {https://de.wikipedia.org/w/index.php?title=Anweisung_(Programmierung)&oldid=222957636},
  urldate = {2022-09-13},
  abstract = {Als Anweisung oder Statement (aus englisch statement entlehnt) wird in der Informatik im Bereich der Programmierung ein zentrales Element vieler imperativer Programmiersprachen bezeichnet. Die Programme derartiger Sprachen setzen sich hauptsächlich aus einer oder mehreren Anweisungen zusammen. Eine Anweisung stellt eine in der Syntax einer Programmiersprache formulierte einzelne Vorschrift dar, die im Rahmen der Abarbeitung des Programms auszuführen ist. Wie eine Anweisung syntaktisch auszusehen hat, wird durch die jeweilige Programmiersprache oder deren Spezifikation festgelegt und ist innerhalb eines Programms (üblicherweise) nicht änderbar. In der maschinennahen Programmierung werden Anweisungen häufig auch als Befehl, Instruktion (aus englisch instruction) oder Kommando (aus englisch command) bezeichnet. Anweisungen sind üblicherweise Zuweisungen, Kontrollanweisungen (wie Sprünge, Schleifen und bedingte Anweisungen) und Prozeduraufrufe. Abhängig von der Programmiersprache sind teilweise auch Zusicherungen, Deklarationen, Klassen- und Funktionsdefinitionen Anweisungen. Im Gegensatz zu Ausdrücken haben Anweisungen nicht immer einen Wert. Einige Anweisungen können jedoch auch Ausdrücke sein, so z. B. Zuweisungen, Inkrementoperatoren oder Funktionsaufrufe. Umgekehrt sind viele Ausdruckstypen wie etwa Vergleiche oder arithmetische Ausdrücke keine syntaktisch vollständigen Anweisungen. Sequenzen von Anweisungen werden häufig in Blöcken zusammengefasst.},
  langid = {ngerman},
  annotation = {Page Version ID: 222957636},
  file = {/home/areo/Zotero/storage/TH8RYP3L/Anweisung_(Programmierung).html}
}

@inreference{Assembler2021,
  title = {Assembler},
  booktitle = {Wikipedia},
  date = {2021-05-23T07:48:36Z},
  url = {https://de.wikipedia.org/w/index.php?title=Assembler&oldid=212253092},
  urldate = {2022-09-13},
  abstract = {Assembler steht für: Assembler (Informatik), ein Computerprogramm, das eine Assemblersprache in Maschinensprache übersetzt Assemblersprache, eine Klasse von Programmiersprachen für Computer Assembler (Bioinformatik), ein Computerprogramm, das eine Genomassemblierung durchführt Assembler (Nanotechnologie), ein Roboter, der Atome und Moleküle manipuliertSiehe auch:},
  langid = {ngerman},
  annotation = {Page Version ID: 212253092},
  file = {/home/areo/Zotero/storage/5KSPVT46/Assembler.html}
}

@inreference{Assemblersprache2022,
  title = {Assemblersprache},
  booktitle = {Wikipedia},
  date = {2022-08-19T03:32:55Z},
  url = {https://de.wikipedia.org/w/index.php?title=Assemblersprache&oldid=225449545},
  urldate = {2022-09-13},
  abstract = {Eine Assemblersprache, kurz auch Assembler genannt (von englisch to assemble  ‚zusammenfügen‘), ist eine Programmiersprache, die auf den Befehlsvorrat eines bestimmten Computertyps (d. h. dessen Prozessorarchitektur) ausgerichtet ist. Assemblersprachen bezeichnet man deshalb als maschinenorientierte Programmiersprachen und – als Nachfolger der direkten Programmierung mit Zahlencodes – als Programmiersprachen der zweiten Generation: Anstelle eines Binärcodes der Maschinensprache können Befehle und deren Operanden durch leichter verständliche mnemonische Symbole in Textform (z. B. „MOVE“), Operanden z. T. als symbolische Adresse (z. B. „PLZ“), notiert und dargestellt werden.Der Quelltext eines Assemblerprogramms wird mit Hilfe einer Übersetzungssoftware (Assembler oder Assemblierer) in Maschinencode übersetzt. Dagegen übersetzt in höheren Programmiersprachen (Hochsprachen, dritte Generation) ein sogenannter Compiler abstraktere (komplexere, nicht auf den Prozessor-Befehlssatz begrenzte) Befehle in den Maschinencode der gegebenen Zielarchitektur – oder in eine Zwischensprache.Umgangssprachlich werden die Ausdrücke „Maschinensprache“ und „Assembler(sprache)“ häufig synonym verwendet.},
  langid = {ngerman},
  annotation = {Page Version ID: 225449545},
  file = {/home/areo/Zotero/storage/WVSP3VC8/Assemblersprache.html}
}

@software{astaninPythontabulate2022,
  title = {Python-Tabulate},
  author = {Astanin, Sergey},
  date = {2022-01-26},
  url = {https://github.com/astanin/python-tabulate},
  urldate = {2022-01-28},
  abstract = {Pretty-print tabular data in Python, a library and a command-line utility. Repository migrated from bitbucket.org/astanin/python-tabulate.}
}

@inreference{Aufrufstapel2021,
  title = {Aufrufstapel},
  booktitle = {Wikipedia},
  date = {2021-03-20T18:12:21Z},
  url = {https://de.wikipedia.org/w/index.php?title=Aufrufstapel&oldid=210008829},
  urldate = {2022-09-13},
  abstract = {Unter einem Aufrufstapel (englisch call stack, procedure stack) versteht man in der Softwaretechnik und Informatik einen besonders genutzten Stapelspeicher, der zur Laufzeit eines Programms den Zustand der gerade aufgerufenen Unterprogramme enthält. Er ist vorgesehener Bestandteil der meisten Prozessorarchitekturen und seine Benutzung wird daher von speziellen Instruktionen und Registern unterstützt oder sogar erfordert. Als Stack Machine (engl. für Stapelmaschine, nicht zu verwechseln mit Kellerautomat) wird eine Klasse von Prozessorarchitekturen bezeichnet, die gänzlich um einen Aufrufstapel herum konstruiert sind, demgegenüber verwenden Registermaschinen zwar üblicherweise einen Aufrufstapel, sind jedoch nicht ausschließlich auf seine Nutzung angewiesen. Die Verwaltung des Aufrufstapels wird in Hochsprachen üblicherweise abstrahiert und stattdessen von Compiler und Betriebssystem übernommen. Anders als beim paradigmatischen Stapelspeicher sind die Zugriffsmöglichkeiten auf den Aufrufstapel in vielen Architekturen jedoch nicht auf das oberste Element beschränkt und die Klassifizierung als Stapel ergibt sich aus der Verwendung als Stapelspeicher für Rücksprungadressen von Unterprogrammen. Zudem ist der Inhalt des Speichers sehr inhomogen und verknüpft Nutzdaten mit Verwaltungsdaten.},
  langid = {ngerman},
  annotation = {Page Version ID: 210008829},
  file = {/home/areo/Zotero/storage/A43ICZ6T/Aufrufstapel.html}
}

@inreference{AusdruckProgrammierung2021,
  title = {Ausdruck (Programmierung)},
  booktitle = {Wikipedia},
  date = {2021-06-14T19:25:24Z},
  url = {https://de.wikipedia.org/w/index.php?title=Ausdruck_(Programmierung)&oldid=212957642},
  urldate = {2022-09-13},
  abstract = {Ein Ausdruck ist in vielen Programmiersprachen ein Konstrukt, das gemäß einer gegebenen Semantik in Bezug auf einen Kontext ausgewertet werden kann, also einen Wert liefert. In vielen formalen Sprachen sind Ausdrücke eines der wichtigsten Konstrukte, wenn nicht gar das einzige. Einige Beispiele: Arithmetische Ausdrücke 2*3; 2(x − a); x2 = 2x; y= sin(x); usw. Aussagenlogische Ausdrücke a und b; wenn b dann a; a oder nicht b; usw. Prädikatenlogische Ausdrücke wenn verheiratet(A, B) dann verheiratet(B, A); wenn Mensch(A) dann (Mann(A) oder Frau(A)); usw.Ausdrücke in Programmiersprachen Literale (Konstanten): 2, 3.14, … (Aber auch Zeichenketten (Strings) und Zeichen: "Hallo Welt", 'c', …) Variablen: x, betragInEuro, wochentagsNummer, … Funktionen: sin(phi), random(), aktMonatsNummer(), … Operationen: 2*3, 2(x - a), x\^3, cos(2*x + 3.14), … Kombinierte Ausdrücke, zum Teil auch mit Zuweisungen oder Ausdrucksanweisungen: x++, --y, y = x = 2*z, y = sin(x), …Neben den Ausdrücken sind in vielen formalen Sprachen Deklarationen wichtig, die den Kontext für die Ausdrücke definieren. Diese werden manchmal (vor allem in funktionalen Programmiersprachen und Skriptsprachen) selbst ebenfalls als Ausdrücke betrachtet.},
  langid = {ngerman},
  annotation = {Page Version ID: 212957642},
  file = {/home/areo/Zotero/storage/DM6IUCA4/Ausdruck_(Programmierung).html}
}

@online{awesoonAnswerWhyConst2013,
  title = {Answer to "why Const Char *pt2=\{'1', '2', '3', '\textbackslash textbackslash0'\}; Can't Compile?"},
  shorttitle = {Answer to "why Const Char *pt2=\{'1', '2', '3', '\textbackslash textbackslash0'\}; Can't Compile?},
  author = {{awesoon}},
  date = {2013-05-29},
  url = {https://stackoverflow.com/a/16808070},
  urldate = {2022-05-07},
  file = {/home/areo/Zotero/storage/H828L878/why-const-char-pt2-1-2-3-0-cant-compile.html}
}

@online{awesoonAnswerWhyConst2013a,
  title = {Answer to "why Const Char *pt2=\{'1', '2', '3', '\textbackslash textbackslashtextbackslash0'\}; Can't Compile?"},
  shorttitle = {Answer to "why Const Char *pt2=\{'1', '2', '3', '\textbackslash textbackslashtextbackslash0'\}; Can't Compile?},
  author = {{awesoon}},
  date = {2013-05-29},
  url = {https://stackoverflow.com/a/16808070},
  urldate = {2022-05-07},
  file = {/home/areo/Zotero/storage/H2IUY5EF/why-const-char-pt2-1-2-3-0-cant-compile.html}
}

@inreference{BackusNaurForm2022,
  title = {Backus–{{Naur}} Form},
  booktitle = {Wikipedia},
  date = {2022-06-15T13:31:34Z},
  url = {https://en.wikipedia.org/w/index.php?title=Backus%E2%80%93Naur_form&oldid=1093258638},
  urldate = {2022-07-31},
  abstract = {In computer science, Backus–Naur form () or Backus normal form (BNF) is a metasyntax notation for context-free grammars, often used to describe the syntax of languages used in computing, such as computer programming languages, document formats, instruction sets and communication protocols. They are applied wherever exact descriptions of languages are needed: for instance, in official language specifications, in manuals, and in textbooks on programming language theory. Many extensions and variants of the original Backus–Naur notation are used; some are exactly defined, including extended Backus–Naur form (EBNF) and augmented Backus–Naur form (ABNF).},
  langid = {english},
  annotation = {Page Version ID: 1093258638},
  file = {/home/areo/Zotero/storage/R4JLVZ75/Backus–Naur_form.html}
}

@inreference{BackusNaurForm2022a,
  title = {Backus-Naur-Form},
  booktitle = {Wikipedia},
  date = {2022-06-16T13:55:21Z},
  url = {https://de.wikipedia.org/w/index.php?title=Backus-Naur-Form&oldid=223748201},
  urldate = {2022-09-13},
  abstract = {Die Backus-Naur-Form oder Backus-Normalform (kurz BNF) ist eine kompakte formale Metasprache zur Darstellung kontextfreier Grammatiken (Typ-2-Grammatiken in der Chomsky-Hierarchie). Hierzu zählt die Syntax gängiger höherer Programmiersprachen. Sie wird auch für die Notation von Befehlssätzen und Kommunikationsprotokollen verwendet. Ursprünglich war sie nach John W. Backus benannt, später wurde sie (auf Anregung von Donald E. Knuth) auch nach Peter Naur benannt. Beide waren Pioniere der Informatik, die sich mit der Erstellung der Algol-60-Regeln und insbesondere mit der Kunst des Compilerbaus beschäftigten. Durch die Backus-Naur-Form im Algol 60 Report wurde es erstmals möglich, die Syntax einer Programmiersprache formal exakt, also ohne die Ungenauigkeiten natürlicher Sprachen, darzustellen. Es gibt viele Varianten der Backus-Naur-Form. Die erweiterte Backus-Naur-Form (EBNF) ist eine gebräuchliche Variante, die unter anderem eine kompakte Notation von sich wiederholenden Elementen erlaubt. Für Syntaxdefinitionen in Internetnormen wird überwiegend die angereicherte Backus-Naur-Form (ABNF) verwendet.},
  langid = {ngerman},
  annotation = {Page Version ID: 223748201},
  file = {/home/areo/Zotero/storage/GFXI68XJ/Backus-Naur-Form.html}
}

@online{Baeume,
  title = {Bäume},
  url = {https://www.stefan-marr.de/pages/informatik-abivorbereitung/baume/},
  urldate = {2022-07-17},
  langid = {ngerman}
}

@unpublished{bastProgrammieren2020,
  type = {Vorlesung},
  title = {Programmieren in C},
  author = {Bast, Hannah},
  date = {2020},
  url = {https://ad-wiki.informatik.uni-freiburg.de/teaching/ProgrammierenCplusplusSS2020},
  urldate = {2022-07-09},
  langid = {ngerman},
  venue = {{Universität Freiburg}}
}

@inreference{Bezeichner2020,
  title = {Bezeichner},
  booktitle = {Wikipedia},
  date = {2020-06-18T17:53:22Z},
  url = {https://de.wikipedia.org/w/index.php?title=Bezeichner&oldid=201100315},
  urldate = {2022-09-13},
  abstract = {Ein Bezeichner (selten auch Identifikator, englisch identifier) ist in der Informatik ein Identifikator, mit dem ein Programmierer in einem Programm ein Objekt, z. B. einen Datentyp, eine Variable oder eine Funktion, eindeutig benennt. Daher muss ein Bezeichner innerhalb eines Namensraums eindeutig sein, es sei denn, die Programmiersprache erlaubt das Überladen. In der Regel werden für Bezeichner Literale (aus Buchstaben) verwendet. Auch Numerale (aus Ziffern) sind üblich, erlauben aber keine gute Mnemonik, diese wird mit einer Kombination einer Zeichenfolge aus Buchstaben und Nummern erreicht. Zur Typenkennzeichnung werden häufig Präfixe oder Suffixe benutzt. Programmiersprachen verwenden verschiedene Konventionen für Bezeichner, z. B. welche (Sonder-)Zeichen darin vorkommen dürfen, ob Groß- und Kleinschreibung unterschieden wird und wie lang der Bezeichner maximal sein darf. Darüber hinaus können weitergehende Benennungsregeln angewendet werden, die zum Teil öffentlich definiert sind (zum Beispiel in der Ungarischen Notation) oder die als Unternehmensstandard, den Programmierstil betreffend, festgelegt wurden.},
  langid = {ngerman},
  annotation = {Page Version ID: 201100315},
  file = {/home/areo/Zotero/storage/J8HG72X9/Bezeichner.html}
}

@online{blckknghtAnswerWhatPythonic2016,
  title = {Answer to "{{What}} Is a Pythonic Way of Slicing a Set?"},
  shorttitle = {Answer to "{{What}} Is a Pythonic Way of Slicing a Set?},
  author = {{Blckknght}},
  date = {2016-11-22},
  url = {https://stackoverflow.com/a/40737853},
  urldate = {2022-05-09},
  file = {/home/areo/Zotero/storage/K459UJ9Y/what-is-a-pythonic-way-of-slicing-a-set.html;/home/areo/Zotero/storage/VEW5WPRH/what-is-a-pythonic-way-of-slicing-a-set.html}
}

@inproceedings{bolingbrokeTypesAreCalling2009,
  title = {Types Are Calling Conventions},
  booktitle = {Proceedings of the 2nd {{ACM SIGPLAN}} Symposium on {{Haskell}} - {{Haskell}} '09},
  author = {Bolingbroke, Maximilian C. and Peyton Jones, Simon L.},
  date = {2009},
  pages = {1},
  publisher = {{ACM Press}},
  location = {{Edinburgh, Scotland}},
  doi = {10.1145/1596638.1596640},
  url = {http://portal.acm.org/citation.cfm?doid=1596638.1596640},
  urldate = {2022-07-23},
  abstract = {It is common for compilers to derive the calling convention of a function from its type. Doing so is simple and modular but misses many optimisation opportunities, particularly in lazy, higher-order functional languages with extensive use of currying. We restore the lost opportunities by defining Strict Core, a new intermediate language whose type system makes the missing distinctions: laziness is explicit, and functions take multiple arguments and return multiple results.},
  eventtitle = {The 2nd {{ACM SIGPLAN}} Symposium},
  isbn = {978-1-60558-508-6},
  langid = {english},
  file = {/home/areo/Zotero/storage/ZUHHKDZ5/Bolingbroke and Peyton Jones - 2009 - Types are calling conventions.pdf}
}

@inreference{BootstrappingCompilers2022,
  title = {Bootstrapping (Compilers)},
  booktitle = {Wikipedia},
  date = {2022-08-30T09:30:34Z},
  url = {https://en.wikipedia.org/w/index.php?title=Bootstrapping_(compilers)&oldid=1107502446},
  urldate = {2022-09-13},
  abstract = {In computer science, bootstrapping is the technique for producing a self-compiling compiler – that is, a compiler (or assembler) written in the source programming language that it intends to compile. An initial core version of the compiler (the bootstrap compiler) is generated in a different language (which could be assembly language); successive expanded versions of the compiler are developed using this minimal subset of the language. The problem of compiling a self-compiling compiler has been called the chicken-or-egg problem in compiler design, and bootstrapping is a solution to this problem.Many compilers for many programming languages are bootstrapped, including compilers for BASIC, ALGOL, C, C\#, D, Pascal, PL/I, Haskell, Modula-2, Oberon, OCaml, Common Lisp, Scheme, Go, Java, Elixir, Rust, Python, Scala, Nim, Eiffel, TypeScript, Vala, Zig and more.},
  langid = {english},
  annotation = {Page Version ID: 1107502446},
  file = {/home/areo/Zotero/storage/53AATE5Y/Bootstrapping_(compilers).html}
}

@inreference{ChomskyHierarchie2022,
  title = {Chomsky-Hierarchie},
  booktitle = {Wikipedia},
  date = {2022-09-05T14:15:13Z},
  url = {https://de.wikipedia.org/w/index.php?title=Chomsky-Hierarchie&oldid=225920254},
  urldate = {2022-09-13},
  abstract = {Chomsky-Hierarchie, gelegentlich Chomsky-Schützenberger-Hierarchie (benannt nach dem Linguisten Noam Chomsky und dem Mathematiker Marcel Schützenberger), ist ein Begriff aus der Theoretischen Informatik. Sie ist eine Hierarchie von Klassen formaler Grammatiken, die formale Sprachen erzeugen, und wurde 1956 erstmals von Noam Chomsky beschrieben. Die Hierarchiestufen unterscheiden sich darin, wie rigide die Einschränkungen für die Form zulässiger Produktionsregeln auf der jeweiligen Stufe sind; bei Typ-0-Grammatiken sind sie uneingeschränkt, bei höheren Stufen fortschreitend stärker beschränkt. Grammatiken niedrigeren Typs sind erzeugungsmächtiger als die höherer Typen. Eine Sprache, die von einer Grammatik des Typs k erzeugt wird, heißt eine Sprache des Typs k. Neben die Chomsky-Hierarchie der Grammatiken tritt in diesem Sinne eine Chomsky-Hierarchie der Sprachen.},
  langid = {ngerman},
  annotation = {Page Version ID: 225920254},
  file = {/home/areo/Zotero/storage/5W6ZQVF6/Chomsky-Hierarchie.html}
}

@online{ClangCompiler,
  title = {Clang: {{C}}++ {{Compiler}}},
  url = {http://clang.org/},
  urldate = {2022-07-29}
}

@online{ClockwiseSpiralRule,
  title = {Clockwise/{{Spiral Rule}}},
  url = {https://c-faq.com/decl/spiral.anderson.html},
  urldate = {2022-07-29}
}

@online{Cmd2IndexRst2022,
  title = {Cmd2/Index.Rst at Bef3c758829fe2aa82d58699d61fa78aa961f29d · Python-Cmd2/Cmd2},
  date = {2022-01-28},
  url = {https://github.com/python-cmd2/cmd2},
  urldate = {2022-01-28},
  abstract = {cmd2 - quickly build feature-rich and user-friendly interactive command line applications in Python - cmd2/index.rst at bef3c758829fe2aa82d58699d61fa78aa961f29d · python-cmd2/cmd2}
}

@inreference{Compiler2022,
  title = {Compiler},
  booktitle = {Wikipedia},
  date = {2022-08-22T13:26:56Z},
  url = {https://de.wikipedia.org/w/index.php?title=Compiler&oldid=225542576},
  urldate = {2022-09-13},
  abstract = {Ein Compiler (auch Kompilierer; von englisch compile ‚zusammentragen‘ bzw. lateinisch compilare ‚aufhäufen‘) ist ein Computerprogramm, das Quellcodes einer bestimmten Programmiersprache in eine Form übersetzt, die von einem Computer (direkter) ausgeführt werden kann. Daraus entsteht ein mehr oder weniger direkt ausführbares Programm. Davon zu unterscheiden sind Interpreter, etwa für frühe Versionen von BASIC, die keinen Maschinencode erzeugen. Teils wird zwischen den Begriffen Übersetzer und Compiler unterschieden. Ein Übersetzer übersetzt ein Programm aus einer formalen Quellsprache in ein semantisches Äquivalent in einer formalen Zielsprache. Compiler sind spezielle Übersetzer, die Programmcode aus problemorientierten Programmiersprachen, sogenannten Hochsprachen, in ausführbaren Maschinencode einer bestimmten Architektur oder einen Zwischencode (Bytecode, p-Code oder .NET-Code) überführen. Diese Trennung zwischen den Begriffen Übersetzer und Compiler wird nicht in allen Fällen vorgenommen. Der Vorgang der Übersetzung wird auch als Kompilierung oder Umwandlung (bzw. mit dem entsprechenden Verb) bezeichnet. Das Gegenteil, also die Rückübersetzung von Maschinensprache in Quelltext einer bestimmten Programmiersprache, wird Dekompilierung und entsprechende Programme Decompiler genannt.},
  langid = {ngerman},
  annotation = {Page Version ID: 225542576},
  file = {/home/areo/Zotero/storage/KPR8E2SG/Compiler.html}
}

@online{CompilerDesignPhases,
  title = {Compiler {{Design}} - {{Phases}} of {{Compiler}}},
  url = {https://www.tutorialspoint.com/compiler_design/compiler_design_phases_of_compiler.htm},
  urldate = {2022-06-19}
}

@inreference{ControlFlowAnalysis2022,
  title = {Control Flow Analysis},
  booktitle = {Wikipedia},
  date = {2022-02-05T15:55:55Z},
  url = {https://en.wikipedia.org/w/index.php?title=Control_flow_analysis&oldid=1070083426},
  urldate = {2022-09-13},
  abstract = {In computer science, control-flow analysis (CFA) is a static-code-analysis technique for determining the control flow of a program. The control flow is expressed as a control-flow graph (CFG). For both functional programming languages and object-oriented programming languages, the term CFA, and elaborations such as k-CFA, refer to specific algorithms that compute control flow.For many imperative programming languages, the control flow of a program is explicit in a program's source code.  As a result, interprocedural control-flow analysis implicitly usually refers to a static analysis technique for determining the receiver(s) of function or method calls in computer programs written in a higher-order programming language. For example, in a programming language with higher-order functions like Scheme, the target of a function call may not be explicit: in the isolated expression it is unclear to which procedure f may refer.  A control-flow analysis must consider where this expression could be invoked and what argument it may receive to determine the possible targets. Techniques such as abstract interpretation, constraint solving, and type systems may be used for control-flow analysis.},
  langid = {english},
  annotation = {Page Version ID: 1070083426},
  file = {/home/areo/Zotero/storage/PCLUJIQK/Control_flow_analysis.html}
}

@inreference{CrossCompiler2022,
  title = {Cross Compiler},
  booktitle = {Wikipedia},
  date = {2022-06-26T21:29:28Z},
  url = {https://en.wikipedia.org/w/index.php?title=Cross_compiler&oldid=1095178458},
  urldate = {2022-09-13},
  abstract = {A cross compiler is a compiler capable of creating executable code for a platform other than the one on which the compiler is running.  For example, a compiler that runs on a PC but generates code that runs on an Android smartphone is a cross compiler. A cross compiler is useful to compile code for multiple platforms from one development host. Direct compilation on the target platform might be infeasible, for example on embedded systems with limited computing resources. Cross compilers are distinct from source-to-source compilers. A cross compiler is for cross-platform software generation of machine code, while a source-to-source compiler translates from one coding language to another in text code. Both are programming tools.},
  langid = {english},
  annotation = {Page Version ID: 1095178458},
  file = {/home/areo/Zotero/storage/ET4VYYY2/Cross_compiler.html}
}

@inreference{DeklarationProgrammierung2022,
  title = {Deklaration (Programmierung)},
  booktitle = {Wikipedia},
  date = {2022-07-05T06:58:39Z},
  url = {https://de.wikipedia.org/w/index.php?title=Deklaration_(Programmierung)&oldid=224245160},
  urldate = {2022-09-13},
  abstract = {In der Informatik und Programmierung ist eine Deklaration die Festlegung von Dimension, Bezeichner, Datentyp und weiteren Aspekten einer Variable oder eines Unterprogramms. Durch die Deklaration wird dem Übersetzer (Compiler oder Interpreter) diese Variable bzw. dieses Unterprogramm bekannt gemacht; es ist damit möglich, diese an anderen Stellen im selben Quelltext zu verwenden. Häufig werden die Ausdrücke Deklaration und Definition mit der allgemeinen Bedeutung „Daten/Datenstrukturen/Datentypen festlegen/beschreiben“ als Synonyme verwendet. Beispiele siehe „eigene Datentypen definieren“ in, „definierte Variable“ in oder „definieren einer Klasse“ in Klasse. Programmiersprachenabhängig werden diese Begriffe jedoch zum Teil auch unterschiedlich verwendet. So werden zum Beispiel in Haskell per Deklaration auch Funktionen spezifiziert, in den Programmiersprachen C++ und C wird dies ‚Definition‘ genannt. ‚Definition‘ wird dabei als Sonderfall der Deklaration verstanden. Bei Variablen spricht man von Definition, wenn der Übersetzer Code erzeugt, der entweder statisch (im Datensegment) oder dynamisch (zur Laufzeit) Speicherplatz für diese Variable reserviert. Bei Unterprogrammen spricht man von Definition, wenn an dieser Stelle der Quelltext des Unterprogramms angegeben ist. Die Deklaration eines Unterprogramms ohne Definition wird auch oft als Prototyp bezeichnet. Bei der Referenzierung einer deklarierten (nicht definierten) Variable bzw. Unterprogrammes überprüft der Linker, dass die Variable bzw. das Unterprogramm an anderer Stelle definiert wurde und verknüpft die Referenzen mit der Definition. Erst nach der Deklaration kann einer Variablen ein Ausdruck zugewiesen werden. Neben der expliziten Deklaration gibt es in einigen Programmiersprachen (z. B. Fortran, BASIC, PL/I) aber auch die Möglichkeit einer impliziten Deklaration von Variablen: In diesem Fall führt das erste Auftreten einer Variablen zu einer automatischen Typzuordnung.},
  langid = {ngerman},
  annotation = {Page Version ID: 224245160},
  file = {/home/areo/Zotero/storage/PDNGE5SM/Deklaration_(Programmierung).html}
}

@online{developersDrawFreelyInkscape,
  title = {Draw {{Freely}} | {{Inkscape}}},
  author = {Developers, Inkscape Website},
  url = {https://inkscape.org/},
  urldate = {2022-08-03},
  abstract = {Inkscape is professional quality vector graphics software which runs on Linux, Mac OS X and Windows desktop computers.},
  langid = {english},
  file = {/home/areo/Zotero/storage/7WYZ7LL2/inkscape.org.html}
}

@inreference{DisjunktiveNormalform2023,
  title = {Disjunktive Normalform},
  booktitle = {Wikipedia},
  date = {2023-02-08T14:08:34Z},
  url = {https://de.wikipedia.org/w/index.php?title=Disjunktive_Normalform&oldid=230680696},
  urldate = {2023-04-27},
  abstract = {Als disjunktive Normalform (kurz DNF) wird in der Booleschen Algebra eine in besonderer Weise normierte Funktionsdarstellung Boolescher Funktionen bezeichnet.},
  langid = {ngerman},
  annotation = {Page Version ID: 230680696},
  file = {/home/areo/Zotero/storage/SXQLX3QN/Disjunktive_Normalform.html}
}

@online{DownloadWhiteBackground,
  title = {Download {{White}} Background with Orange Geometric for Free},
  url = {https://www.vecteezy.com/vector-art/11171111-white-background-with-orange-geometric},
  urldate = {2023-04-25},
  abstract = {Download the White background with orange geometric 11171111 royalty-free Vector from Vecteezy for your project and explore over a million other vectors, icons and clipart graphics!},
  langid = {english},
  organization = {{Vecteezy}},
  file = {/home/areo/Zotero/storage/4UXYW48J/11171111-white-background-with-orange-geometric.html}
}

@software{drewOthneildrewBestREADMETemplate2022,
  title = {Othneildrew/{{Best-README-Template}}},
  author = {Drew, Othneil},
  date = {2022-01-28},
  url = {https://github.com/othneildrew/Best-README-Template},
  urldate = {2022-01-28},
  abstract = {An awesome README template to jumpstart your projects!},
  keywords = {readme,readme-template}
}

@online{DudenPatchRechtschreibung,
  title = {Duden | Patch | Rechtschreibung, Bedeutung, Definition, Herkunft},
  url = {https://www.duden.de/rechtschreibung/Patch_Software_Programm},
  urldate = {2022-07-23},
  abstract = {Definition, Rechtschreibung, Synonyme und Grammatik von 'Patch' auf Duden online nachschlagen. Wörterbuch der deutschen Sprache.},
  langid = {ngerman},
  file = {/home/areo/Zotero/storage/QERL6R42/Patch_Software_Programm.html}
}

@article{earleyEfiicientContextfreeParsing1968,
  title = {An Efiicient Context-Free Parsing},
  author = {Earley, Jay},
  date = {1968},
  journaltitle = {Commun.ACM},
  volume = {13},
  url = {https://web.archive.org/web/20040708052627/http://www-2.cs.cmu.edu/afs/cs.cmu.edu/project/cmt-55/lti/Courses/711/Class-notes/p94-earley.pdf},
  urldate = {2022-08-10},
  file = {/home/areo/Zotero/storage/T44BWJJP/2004 - Wayback Machine.pdf}
}

@article{earleyFormalismTranslatorInteractions1970,
  title = {A Formalism for Translator Interactions},
  author = {Earley, J. and Sturgis, Howard E.},
  date = {1970},
  journaltitle = {CACM},
  doi = {10.1145/355598.362740},
  abstract = {A formalism is presented for describing the actions of processors for programming languages—compilers, interpreters, assemblers—and their interactions in complex systems such as compiler-compilers or extendible languages. The formalism here might be used to define and answer such a question as “Can one do bootstrapping using a metacompiler whose metaphase is interpretive?” In addition an algorithm is presented for deciding whether or not a given system can be produced from a given set of component processors.}
}

@online{EarleyParser,
  title = {Earley {{Parser}}},
  url = {https://rahul.gopinath.org/post/2021/02/06/earley-parsing/},
  urldate = {2022-06-20}
}

@inreference{EarleyParser2022,
  title = {Earley Parser},
  booktitle = {Wikipedia},
  date = {2022-05-31T18:52:44Z},
  url = {https://en.wikipedia.org/w/index.php?title=Earley_parser&oldid=1090848932},
  urldate = {2022-08-15},
  abstract = {In computer science, the Earley parser is an algorithm for parsing strings that belong to a given context-free language, though (depending on the variant) it may suffer problems with certain nullable grammars. The algorithm, named after its inventor, Jay Earley, is a chart parser that uses dynamic programming; it is mainly used for parsing in computational linguistics. It was first introduced in his dissertation in 1968 (and later appeared in an abbreviated, more legible, form in a journal). Earley parsers are appealing because they can parse all context-free languages, unlike LR parsers and LL parsers, which are more typically used in compilers but which can only handle restricted classes of languages.  The Earley parser executes in cubic time in the general case                                    O                  (                    n                        3                             )                 \{\textbackslash displaystyle \{O\}(n\^\{3\})\}   , where n is the length of the parsed string, quadratic time for unambiguous grammars                                    O                  (                    n                        2                             )                 \{\textbackslash displaystyle \{O\}(n\^\{2\})\}   , and linear time for all deterministic context-free grammars. It performs particularly well when the rules are written left-recursively.},
  langid = {english},
  annotation = {Page Version ID: 1090848932}
}

@inreference{EarleyParser2022a,
  title = {Earley Parser},
  booktitle = {Wikipedia},
  date = {2022-05-31T18:52:44Z},
  url = {https://en.wikipedia.org/w/index.php?title=Earley_parser&oldid=1090848932},
  urldate = {2022-09-13},
  abstract = {In computer science, the Earley parser is an algorithm for parsing strings that belong to a given context-free language, though (depending on the variant) it may suffer problems with certain nullable grammars. The algorithm, named after its inventor, Jay Earley, is a chart parser that uses dynamic programming; it is mainly used for parsing in computational linguistics. It was first introduced in his dissertation in 1968 (and later appeared in an abbreviated, more legible, form in a journal). Earley parsers are appealing because they can parse all context-free languages, unlike LR parsers and LL parsers, which are more typically used in compilers but which can only handle restricted classes of languages.  The Earley parser executes in cubic time in the general case                                    O                  (                    n                        3                             )                 \{\textbackslash displaystyle \{O\}(n\^\{3\})\}   , where n is the length of the parsed string, quadratic time for unambiguous grammars                                    O                  (                    n                        2                             )                 \{\textbackslash displaystyle \{O\}(n\^\{2\})\}   , and linear time for all deterministic context-free grammars. It performs particularly well when the rules are written left-recursively.},
  langid = {english},
  annotation = {Page Version ID: 1090848932},
  file = {/home/areo/Zotero/storage/CQL5E3PS/Earley_parser.html}
}

@online{EarleyParsera,
  title = {Earley {{Parser}}},
  url = {https://rahul.gopinath.org/post/2021/02/06/earley-parsing/},
  urldate = {2022-08-10},
  file = {/home/areo/Zotero/storage/5HYW2WGJ/earley-parsing.html}
}

@inreference{EntartungInformatik2021,
  title = {Entartung (Informatik)},
  booktitle = {Wikipedia},
  date = {2021-09-11T14:39:03Z},
  url = {https://de.wikipedia.org/w/index.php?title=Entartung_(Informatik)&oldid=215501841},
  urldate = {2022-09-13},
  abstract = {Eine Datenstruktur wird als entartet bezeichnet, wenn sie final einen Zustand angenommen hat, in der sie anders als vor der Entartung nachteilig wirkt. Dies kann aufgrund ungünstiger Eingabedaten geschehen.},
  langid = {ngerman},
  annotation = {Page Version ID: 215501841},
  file = {/home/areo/Zotero/storage/UBJKYCPZ/Entartung_(Informatik).html}
}

@online{ErrorsGeeksforGeeks,
  title = {Errors in {{C}}/{{C}}++ - {{GeeksforGeeks}}},
  url = {https://www.geeksforgeeks.org/errors-in-cc/},
  urldate = {2022-05-10}
}

@inreference{EvaluationStrategy2022,
  title = {Evaluation Strategy},
  booktitle = {Wikipedia},
  date = {2022-09-12T23:01:04Z},
  url = {https://en.wikipedia.org/w/index.php?title=Evaluation_strategy&oldid=1109984435},
  urldate = {2022-09-13},
  abstract = {In a programming language, an evaluation strategy is a set of rules for evaluating expressions. The term is often used to refer to the more specific notion of a parameter-passing strategy that defines the kind of value that is passed to the function for each parameter (the binding strategy) and whether to evaluate the parameters of a function call, and if so in what order (the evaluation order). The notion of reduction strategy is distinct, although some authors conflate the two terms and the definition of each term is not widely agreed upon.To illustrate, executing a function call f(a,b) may first evaluate the arguments a and b, store the results in references or memory locations ref\_a and ref\_b, then evaluate the function's body with those references passed in. This gives the function the ability to look up the argument values, to modify them via assignment as if they were local variables, and to return values via the references. This is the call-by-reference evaluation strategy.Evaluation strategy is specified by the programming language definition, and is not a function of any specific implementation. The calling convention defines implementation-specific parameter passing details.},
  langid = {english},
  annotation = {Page Version ID: 1109984435}
}

@inreference{ExtendedBackusNaur2022,
  title = {Extended {{Backus}}–{{Naur}} Form},
  booktitle = {Wikipedia},
  date = {2022-06-17T13:55:45Z},
  url = {https://en.wikipedia.org/w/index.php?title=Extended_Backus%E2%80%93Naur_form&oldid=1093574831},
  urldate = {2022-07-31},
  abstract = {In computer science, extended Backus–Naur form (EBNF) is a family of metasyntax notations, any of which can be used to express a context-free grammar.  EBNF is used to make a formal description of a formal language such as a computer programming language. They are extensions of the basic Backus–Naur form (BNF) metasyntax notation. The earliest EBNF was developed by Niklaus Wirth incorporating some of the concepts (with a different syntax and notation) from Wirth syntax notation. However, many variants of EBNF are in use. The International Organization for Standardization adopted an EBNF standard (ISO/IEC 14977) in 1996. However, according to Zaytsev this standard "only ended up adding yet another three dialects to the chaos" and, after noting its lack of success, also notes that the ISO EBNF is not even used in all ISO standards. Wheeler argues against using the ISO standard when using an EBNF, and recommends considering alternative EBNF notations such as the one from the W3C Extensible Markup Language (XML) 1.0 (Fifth Edition). This article uses EBNF as specified by the ISO for examples applying to all EBNFs. Other EBNF variants use somewhat different syntactic conventions.},
  langid = {english},
  annotation = {Page Version ID: 1093574831},
  file = {/home/areo/Zotero/storage/HB4NQHVX/Extended_Backus–Naur_form.html}
}

@online{FAQPyinstallerPyinstaller2022,
  title = {{{FAQ}} · Pyinstaller/Pyinstaller {{Wiki}}},
  date = {2022-01-28},
  url = {https://github.com/pyinstaller/pyinstaller},
  urldate = {2022-01-28},
  abstract = {Freeze (package) Python programs into stand-alone executables - FAQ · pyinstaller/pyinstaller Wiki}
}

@online{FileHandshakeIcon2020,
  title = {File:{{Handshake}} Icon Black Circle.Svg - {{Wikipedia}}},
  shorttitle = {File},
  date = {2020-05-21},
  url = {https://commons.wikimedia.org/wiki/File:Handshake_icon_black_circle.svg},
  urldate = {2023-04-27},
  langid = {english},
  file = {/home/areo/Zotero/storage/WTU6IBT3/FileHandshake_icon_black_circle.html}
}

@inreference{Funktionsprototyp2020,
  title = {Funktionsprototyp},
  booktitle = {Wikipedia},
  date = {2020-01-22T18:19:47Z},
  url = {https://de.wikipedia.org/w/index.php?title=Funktionsprototyp&oldid=196075270},
  urldate = {2022-09-13},
  abstract = {Als Funktionsprototyp oder Funktionskopf bezeichnet man in verschiedenen Programmiersprachen (vor allem C und C++) die Deklaration einer Funktion – inklusive Angaben über Anzahl und Typ der Parameter und Typ des Rückgabewertes – getrennt von ihrer Implementierung (Definition). Man spricht auch ungenau von der Vorausdeklaration (englisch: forward declaration, oft falsch als „Vorwärtsdeklaration“ übersetzt) einer Funktion, diese muss aber nicht in jedem Fall einen vollwertigen Funktionsprototypen darstellen. Beispiel: int funktion(); wäre in C eine gültige Vorausdeklaration, aber kein Prototyp, da keinerlei Angaben über Funktionsparameter gemacht werden. Jede Definition einer Funktion liefert hingegen automatisch immer auch eine Prototypdeklaration für nachfolgenden Programmcode.},
  langid = {ngerman},
  annotation = {Page Version ID: 196075270},
  file = {/home/areo/Zotero/storage/JDMCGWPC/Funktionsprototyp.html}
}

@book{g.siekEssentialsCompilation2022,
  title = {Essentials of {{Compilation}}},
  author = {G. Siek, Jeremy},
  date = {2022-01-28},
  url = {https://iucompilercourse.github.io/IU-Fall-2021/},
  urldate = {2022-01-28}
}

@online{GCCGNUCompiler,
  title = {{{GCC}}, the {{GNU Compiler Collection}} - {{GNU Project}}},
  url = {https://gcc.gnu.org/},
  urldate = {2022-07-13}
}

@online{GDBGNUProject,
  title = {{{GDB}}: {{The GNU Project Debugger}}},
  url = {https://www.sourceware.org/gdb/},
  urldate = {2022-07-13}
}

@online{GitHubMarpteamMarpcli2022,
  title = {{{GitHub}} - Marp-Team/Marp-Cli: {{A CLI}} Interface for {{Marp}} and {{Marpit}} Based Converters},
  date = {2022-01-28},
  url = {https://github.com/marp-team/marp-cli},
  urldate = {2022-01-28}
}

@online{GrammarLanguageLanguages,
  title = {Grammar: {{The}} Language of Languages ({{BNF}}, {{EBNF}}, {{ABNF}} and More)},
  url = {https://matt.might.net/articles/grammars-bnf-ebnf/},
  urldate = {2022-07-30}
}

@online{GrammarReferenceLark,
  title = {Grammar {{Reference}} — {{Lark}} Documentation},
  url = {https://lark-parser.readthedocs.io/en/latest/grammar.html},
  urldate = {2022-07-31}
}

@online{GrammarReferenceLarka,
  title = {Grammar {{Reference}} — {{Lark}} Documentation},
  url = {https://lark-parser.readthedocs.io/en/latest/grammar.html},
  urldate = {2022-09-13},
  file = {/home/areo/Zotero/storage/TZ8WEC4E/grammar.html}
}

@inreference{GraphColoring2022,
  title = {Graph Coloring},
  booktitle = {Wikipedia},
  date = {2022-09-13T13:50:58Z},
  url = {https://en.wikipedia.org/w/index.php?title=Graph_coloring&oldid=1110085555},
  urldate = {2022-09-13},
  abstract = {In graph theory, graph coloring is a special case of graph labeling; it is an assignment of labels traditionally called "colors" to elements of a graph subject to certain constraints. In its simplest form, it is a way of coloring the vertices of a graph such that no two adjacent vertices are of the same color; this is called a vertex coloring. Similarly, an edge coloring assigns a color to each edge so that no two adjacent edges are of the same color, and a face coloring of a planar graph assigns a color to each face or region so that no two faces that share a boundary have the same color. Vertex coloring is often used to introduce graph coloring problems, since other coloring problems can be transformed into a vertex coloring instance. For example, an edge coloring of a graph is just a vertex coloring of its line graph, and a face coloring of a plane graph is just a vertex coloring of its dual. However, non-vertex coloring problems are often stated and studied as-is. This is partly pedagogical, and partly because some problems are best studied in their non-vertex form, as in the case of edge coloring. The convention of using colors originates from coloring the countries of a map, where each face is literally colored. This was generalized to coloring the faces of a graph embedded in the plane. By planar duality it became coloring the vertices, and in this form it generalizes to all graphs. In mathematical and computer representations, it is typical to use the first few positive or non-negative integers as the "colors". In general, one can use any finite set as the "color set". The nature of the coloring problem depends on the number of colors but not on what they are. Graph coloring enjoys many practical applications as well as theoretical challenges. Beside the classical types of problems, different limitations can also be set on the graph, or on the way a color is assigned, or even on the color itself. It has even reached popularity with the general public in the form of the popular number puzzle Sudoku. Graph coloring is still a very active field of research. Note: Many terms used in this article are defined in Glossary of graph theory.},
  langid = {english},
  annotation = {Page Version ID: 1110085555},
  file = {/home/areo/Zotero/storage/PL34J7VD/Graph_coloring.html}
}

@software{griffithsScottgriffithsBitstring2022,
  title = {Scott-Griffiths/Bitstring},
  author = {Griffiths, Scott},
  date = {2022-01-20},
  url = {https://github.com/scott-griffiths/bitstring},
  urldate = {2022-01-28},
  abstract = {A Python module to help you manage your bits},
  keywords = {binary-data,bit-manipulation,bitarray,bitstring,python}
}

@online{HistoryGCCWiki,
  title = {History - {{GCC Wiki}}},
  url = {https://gcc.gnu.org/wiki/History},
  urldate = {2022-08-06},
  file = {/home/areo/Zotero/storage/YPIYF74M/History.html}
}

@online{HomeNeovim,
  title = {Home - {{Neovim}}},
  url = {http://neovim.io/},
  urldate = {2022-08-04}
}

@inreference{IdentifierComputerLanguages2022,
  title = {Identifier (Computer Languages)},
  booktitle = {Wikipedia},
  date = {2022-04-05},
  url = {https://en.wikipedia.org/w/index.php?title=Identifier_(computer_languages)&oldid=1081115854},
  urldate = {2022-04-13},
  abstract = {In computer programming languages, an identifier is a lexical token (also called a symbol, but not to be confused with the symbol primitive data type) that names the language's entities. Some of the kinds of entities an identifier might denote include variables, data types, labels, subroutines, and modules.},
  file = {/home/areo/Zotero/storage/5XP2639V/Identifier_(computer_languages).html;/home/areo/Zotero/storage/L6UGYSD2/Identifier_(computer_languages).html}
}

@inreference{ImperativeProgrammierung2022,
  title = {Imperative Programmierung},
  booktitle = {Wikipedia},
  date = {2022-01-24T15:11:03Z},
  url = {https://de.wikipedia.org/w/index.php?title=Imperative_Programmierung&oldid=219505017},
  urldate = {2022-09-13},
  abstract = {Imperative Programmierung (lateinisch imperare ‚anordnen‘, ‚befehlen‘) ist ein Programmierparadigma, nach dem „ein Programm aus einer Folge von Anweisungen besteht, die vorgeben, in welcher Reihenfolge was vom Computer getan werden soll“.Die imperative Programmierung ist das am längsten bekannte Programmierparadigma. Diese Vorgehensweise war, bedingt durch den Sprachumfang früherer Programmiersprachen, ehemals die klassische Art des Programmierens. Sie liegt dem Entwurf von vielen Programmiersprachen, zum Beispiel ALGOL, BASIC, Fortran, Pascal, Ada, PL/I, Cobol, C und allen Assemblersprachen zugrunde.Abweichende Bezeichnungen: In der Literatur wird dieses Entwicklungskonzept zum Teil auch „imperativ/prozedural“, „algorithmisch“ oder auch „zustandsorientiert“ genannt. Auch die Bezeichnung „prozedurale Programmierung“ wird zum Teil synonym verwendet, was jedoch abweichend auch mit „Verwendung von Prozeduren“ definiert wird.},
  langid = {ngerman},
  annotation = {Page Version ID: 219505017},
  file = {/home/areo/Zotero/storage/QUVJN2CV/Imperative_Programmierung.html}
}

@inreference{Interpreter2022,
  title = {Interpreter},
  booktitle = {Wikipedia},
  date = {2022-06-16T13:48:37Z},
  url = {https://de.wikipedia.org/w/index.php?title=Interpreter&oldid=223748000},
  urldate = {2022-09-13},
  abstract = {Als Interpreter wird ein Computerprogramm bezeichnet, das eine Abfolge von Anweisungen anscheinend direkt ausführt, wobei das Format der Anweisungen vorgegeben ist. Der Interpreter liest dazu eine oder mehrere Quelldateien ein, analysiert diese und führt sie anschließend Anweisung für Anweisung aus, indem er den dafür vorgesehenen Programmcode (eventuell über Zwischenschritte schließlich als Maschinencode für das jeweilige Computersystem) direkt ausführt. Interpreter sind deutlich langsamer als Compiler, bieten im Allgemeinen jedoch eine bessere Fehleranalyse.Interpreter werden sowohl bei Programmiersprachen als auch bei Computerprogrammen sowie Kommandozeileninterpreter verwendet.},
  langid = {ngerman},
  annotation = {Page Version ID: 223748000},
  file = {/home/areo/Zotero/storage/8LKPH8TT/Interpreter.html}
}

@online{JSONParserTutorial,
  title = {{{JSON}} Parser - {{Tutorial}} — {{Lark}} Documentation},
  url = {https://lark-parser.readthedocs.io/en/latest/json_tutorial.html},
  urldate = {2022-07-09},
  file = {/home/areo/Zotero/storage/CJHCPS2F/json_tutorial.html}
}

@online{keithSingletonPatternPython2022,
  title = {Singleton {{Pattern In Python}}},
  author = {{Keith}},
  date = {2022-01-28},
  url = {https://stackoverflow.com/questions/52351312/singleton-pattern-in-python},
  urldate = {2022-01-28}
}

@software{klocknerPuDBConsolebasedVisual2022,
  title = {{{PuDB}}: A Console-Based Visual Debugger for {{Python}}},
  shorttitle = {{{PuDB}}},
  author = {Klöckner, Andreas},
  date = {2022-01-25},
  url = {https://github.com/inducer/pudb},
  urldate = {2022-01-28},
  abstract = {Full-screen console debugger for Python},
  keywords = {bpython,debug,debugger,ipython,pdb,pytest,pytest-plugin,python,urwid}
}

@inreference{KontextfreieGrammatik2021,
  title = {Kontextfreie Grammatik},
  booktitle = {Wikipedia},
  date = {2021-07-17T13:04:47Z},
  url = {https://de.wikipedia.org/w/index.php?title=Kontextfreie_Grammatik&oldid=213960399},
  urldate = {2022-09-13},
  abstract = {In der Theorie der formalen Sprachen ist eine kontextfreie Grammatik (englisch context-free grammar, CFG) eine formale Grammatik, die nur solche Ersetzungsregeln enthält, bei denen immer genau ein Nichtterminalsymbol auf eine beliebig lange Folge von Nichtterminal- und Terminalsymbolen abgeleitet wird. Die Ersetzungsregeln haben also die Form                         V         →         w                 \{\textbackslash displaystyle V\textbackslash rightarrow w\}    (mit Nichtterminalsymbol                         V                 \{\textbackslash displaystyle V\}    und Zeichenkette                         w                 \{\textbackslash displaystyle w\}    bestehend aus Nichtterminal- und/oder Terminalsymbolen). Weil die linke Seite einer Regel nur aus einem einzigen Nichtterminalsymbol                         V                 \{\textbackslash displaystyle V\}    besteht, hängt ihre Anwendbarkeit auf eine Zeichenkette nur davon ab, ob das Nichtterminalsymbol                         V                 \{\textbackslash displaystyle V\}    in der Zeichenkette vorkommt, nicht aber davon, in welchem Kontext es sich befindet, d. h. welche Zeichen links und/oder rechts davon stehen. Die Regeln sind also kontextfrei. Die kontextfreien Grammatiken sind identisch mit den Typ-2-Grammatiken der Chomsky-Hierarchie.},
  langid = {ngerman},
  annotation = {Page Version ID: 213960399}
}

@inreference{Kontrollfluss2021,
  title = {Kontrollfluss},
  booktitle = {Wikipedia},
  date = {2021-04-10T11:38:48Z},
  url = {https://de.wikipedia.org/w/index.php?title=Kontrollfluss&oldid=210777251},
  urldate = {2022-09-13},
  abstract = {Der Kontrollfluss oder Programmablauf bezeichnet in der Informatik die zeitliche Abfolge der einzelnen Befehle eines Computerprogramms. Der Kontrollfluss eines Programms ist gewöhnlich durch die Reihenfolge der Befehle innerhalb des Programms vorgegeben, jedoch erlauben Kontrollstrukturen von der sequenziellen Abarbeitung des Programms abzuweichen. Die Abarbeitungsreihenfolge der einzelnen Befehle, welche das Programm vorgibt, wird von Kontrollflussabhängigkeiten festgelegt: Ein einzelner Befehl wird entweder dann ausgeführt, wenn der unmittelbar vorhergehende Befehl abgearbeitet und der Programmzähler inkrementiert wurde oder wenn ein Sprungbefehl auf die entsprechende Stelle im Speicher zeigt und dem Programmzähler durch den Sprungbefehl ein neuer Wert zugewiesen wird. Beide Kontrollflussabhängigkeiten müssen bei der parallelen Ausführung von Befehlen des Programms berücksichtigt werden.},
  langid = {ngerman},
  annotation = {Page Version ID: 210777251},
  file = {/home/areo/Zotero/storage/RJYZK98V/Kontrollfluss.html}
}

@inreference{Kontrollflussgraph2022,
  title = {Kontrollflussgraph},
  booktitle = {Wikipedia},
  date = {2022-03-27T11:00:15Z},
  url = {https://de.wikipedia.org/w/index.php?title=Kontrollflussgraph&oldid=221536594},
  urldate = {2022-09-13},
  abstract = {Ein Kontrollflussgraph ist ein Begriff aus der Informatik und bezeichnet einen gerichteten Graphen, der dazu dient, den Kontrollfluss eines Computerprogramms zu beschreiben. Sie werden unter anderem zur Programmoptimierung eingesetzt.},
  langid = {ngerman},
  annotation = {Page Version ID: 221536594},
  file = {/home/areo/Zotero/storage/LEU2GLSD/Kontrollflussgraph.html}
}

@inreference{LabelProgrammierung2022,
  title = {Label (Programmierung)},
  booktitle = {Wikipedia},
  date = {2022-01-03T17:53:52Z},
  url = {https://de.wikipedia.org/w/index.php?title=Label_(Programmierung)&oldid=218756487},
  urldate = {2022-09-13},
  abstract = {Ein Label (zu Deutsch: Sprungmarke) in einem Quellcode eines Computerprogramms ist eine durch einen Bezeichner eindeutig gekennzeichnete Marke, die üblicherweise als Sprungziel dient.},
  langid = {ngerman},
  annotation = {Page Version ID: 218756487},
  file = {/home/areo/Zotero/storage/8QL2KGAV/Label_(Programmierung).html}
}

@software{LarkParsingToolkit2022,
  title = {Lark - a Parsing Toolkit for {{Python}}},
  date = {2022-04-26},
  url = {https://github.com/lark-parser/lark},
  urldate = {2022-04-28},
  abstract = {Lark is a parsing toolkit for Python, built with a focus on ergonomics, performance and modularity.},
  organization = {{Lark - Parsing Library \& Toolkit}},
  keywords = {cyk,earley,grammar,lalr,lark,parse,parser,parser-library,parsing-engine,parsing-library,python,tree}
}

@online{Lecturenotes20212022,
  title = {Lecture-Notes-2021},
  date = {2022-01-20},
  url = {https://github.com/Compiler-Construction-Uni-Freiburg/lecture-notes-2021/blob/56300e6649e32f0594bbbd046a2e19351c57dd0c/material/lexical-analysis.pdf},
  urldate = {2022-04-28}
}

@book{lefeverArtExplanationMaking2012,
  title = {The Art of Explanation: Making your Ideas, Products, and Services Easier to Understand},
  shorttitle = {The Art of Explanation},
  author = {LeFever, Lee},
  date = {2012-11-20},
  edition = {1},
  publisher = {{Wiley}},
  langid = {Englisch}
}

@inreference{LexicalAnalysis2022,
  title = {Lexical Analysis},
  booktitle = {Wikipedia},
  date = {2022-08-16T20:38:19Z},
  url = {https://en.wikipedia.org/w/index.php?title=Lexical_analysis&oldid=1104772145},
  urldate = {2022-09-13},
  abstract = {In computer science, lexical analysis, lexing or tokenization is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of lexical tokens (strings with an assigned and thus identified meaning). A program that performs lexical analysis may be termed a lexer, tokenizer, or scanner, although scanner is also a term for the first stage of a lexer. A lexer is generally combined with a parser, which together analyze the syntax of programming languages, web pages, and so forth.},
  langid = {english},
  annotation = {Page Version ID: 1104772145},
  file = {/home/areo/Zotero/storage/AWPPTLGL/Lexical_analysis.html}
}

@inreference{LexikalischeAnalyse2022,
  title = {Lexikalische Analyse},
  booktitle = {Wikipedia},
  date = {2022-08-22T13:24:45Z},
  url = {https://de.wikipedia.org/w/index.php?title=Lexikalische_Analyse&oldid=225542512},
  urldate = {2022-09-13},
  abstract = {Lexikalische Analyse ist in der Informatik die Zerlegung einer Zeichenkette (z. B.  Quelltext) in eine Folge von logisch zusammengehörigen Einheiten, sogenannte Token. Ein Computerprogramm, das eine lexikalische Analyse durchführt, wird Lexer, Tokenizer oder lexikalischer Scanner genannt. Ein Lexer ist meist Teil eines Compilers und wird als erster Schritt in der Analysephase ausgeführt. Das Ergebnis des Lexers wird im nächsten Schritt von einem Parser weiterverarbeitet.},
  langid = {ngerman},
  annotation = {Page Version ID: 225542512},
  file = {/home/areo/Zotero/storage/FYYFGHRM/Lexikalische_Analyse.html}
}

@online{lindleyAnswerAssignArray2013,
  title = {Answer to "{{Assign}} Array to Array"},
  author = {Lindley, Benjamin},
  date = {2013-09-23},
  url = {https://stackoverflow.com/a/18962507},
  urldate = {2022-05-07}
}

@inreference{LinkerComputerprogramm2022,
  title = {Linker (Computerprogramm)},
  booktitle = {Wikipedia},
  date = {2022-08-04T10:27:28Z},
  url = {https://de.wikipedia.org/w/index.php?title=Linker_(Computerprogramm)&oldid=225065452},
  urldate = {2022-09-13},
  abstract = {Unter einem Linker oder Binder (auch: „Bindelader“) versteht man ein Computerprogramm, das einzelne Programmmodule zu einem ausführbaren Programm zusammenstellt (verbindet). Auf IBM-Großrechnersystemen wird der Linker linkage editor (englisch) genannt.Die meisten Programme enthalten Bestandteile oder Module, die in anderen Programmen Verwendung finden können. Mehrere kompilierte Module mit Funktionen (so genannte Objektdateien) können zu Funktionsbibliotheken (Programmbibliotheken) zusammengefasst werden. Der Code wird durch den Linker zum Hauptprogramm hinzugefügt, falls die entsprechende Funktion benötigt wird. Um ein Programmmodul in einem anderen Programm verwenden zu können, müssen die symbolischen Adressen der Funktionen und Variablen des Moduls in Speicheradressen umgewandelt werden. Diese Aufgabe übernimmt der Linker. Der Linkvorgang erfolgt nach der Kompilierung und ist meistens der letzte Arbeitsschritt zur Erstellung eines Programms. Man unterscheidet generell zwischen statischem und dynamischem Linken.},
  langid = {ngerman},
  annotation = {Page Version ID: 225065452},
  file = {/home/areo/Zotero/storage/AQR5YPYA/Linker_(Computerprogramm).html}
}

@inreference{Literal2021,
  title = {Literal},
  booktitle = {Wikipedia},
  date = {2021-10-17T11:39:17Z},
  url = {https://de.wikipedia.org/w/index.php?title=Literal&oldid=216440695},
  urldate = {2022-09-13},
  abstract = {Ein Literal ist ein spezieller Bestandteil einer formalen Sprache.},
  langid = {ngerman},
  annotation = {Page Version ID: 216440695},
  file = {/home/areo/Zotero/storage/6PFHTBSI/Literal.html}
}

@online{ljohhuhWhatImmediateValue2018,
  title = {What Is an Immediate Value?},
  author = {{Ljohhuh}},
  date = {2018-04-04},
  url = {https://reverseengineering.stackexchange.com/q/17671},
  urldate = {2022-04-13},
  file = {/home/areo/Zotero/storage/HN866RIB/what-is-an-immediate-value.html;/home/areo/Zotero/storage/WKSVNG3G/what-is-an-immediate-value.html}
}

@inreference{LLGrammatik2015,
  title = {LL(k)-Grammatik},
  booktitle = {Wikipedia},
  date = {2015-07-07T18:05:56Z},
  url = {https://de.wikipedia.org/w/index.php?title=LL(k)-Grammatik&oldid=143824732},
  urldate = {2022-09-13},
  abstract = {Dieser Artikel setzt Vorkenntnisse im Bereich Theoretische Informatik und Compilerbau voraus. Eine LL(k)-Grammatik (im Gegensatz zu LF(k)-Grammatik auch schwache LL(k)-Grammatik) ist eine spezielle kontextfreie Grammatik, welche die Grundlage eines LL(k)-Parsers bildet. Eine kontextfreie Grammatik heißt LL(k)-Grammatik für eine natürliche Zahl k, wenn jeder Ableitungsschritt eindeutig durch die nächsten k Symbole der Eingabe (Lookahead) bestimmt ist. Das bedeutet, die Frage, welches Nichtterminalsymbol mit welcher Regel als Nächstes expandiert werden soll, kann eindeutig mit Hilfe der nächsten k Symbole der Eingabe bestimmt werden. Generell gilt, je größer k gewählt wird, umso mächtiger wird die Sprachklasse, wobei die Ausdrucksstärke von kontextfreien Grammatiken nie erreicht wird. Damit gibt es kontextfreie Sprachen, die für kein k von einer LL(k)-Grammatik erzeugt werden.                                                L                             (                    L           L                  (         1         )         )         ⊊                                 L                             (                    L           L                  (         2         )         )         ⊊         ⋯         ⊊                                 L                             (                    L           L                  (         k         )         )         ⊊                                 L                             (                    L           R                  (         1         )         )         =                                 L                             (                    D           P           D           A                  )                 \{\textbackslash displaystyle \{\textbackslash mathcal \{L\}\}(\textbackslash mathrm \{LL\} (1))\textbackslash subsetneq \{\textbackslash mathcal \{L\}\}(\textbackslash mathrm \{LL\} (2))\textbackslash subsetneq \textbackslash dots \textbackslash subsetneq \{\textbackslash mathcal \{L\}\}(\textbackslash mathrm \{LL\} (k))\textbackslash subsetneq \{\textbackslash mathcal \{L\}\}(\textbackslash mathrm \{LR\} (1))=\{\textbackslash mathcal \{L\}\}(\textbackslash mathrm \{DPDA\} )\}    Dabei steht DPDA für die deterministischen Kellerautomaten. Diese können genau die deterministisch kontextfreien Sprachen erkennen.},
  langid = {ngerman},
  annotation = {Page Version ID: 143824732},
  file = {/home/areo/Zotero/storage/R8YD8EN6/LL(k)-Grammatik.html}
}

@online{mahajanScalerTopics2022,
  title = {Scaler {{Topics}}},
  author = {Mahajan, Urvish},
  date = {2022-01-28},
  url = {https://www.scaler.com/topics/c/types-of-errors-in-c/},
  urldate = {2022-05-10},
  abstract = {This article by Scaler Topics explains errors \& their types in C, covering the explanation \& examples for each type of error in C Programming Language.},
  file = {/home/areo/Zotero/storage/CB27JXAK/types-of-errors-in-c.html;/home/areo/Zotero/storage/CLLE8Y7I/types-of-errors-in-c.html}
}

@online{Manjaro2022,
  title = {Manjaro},
  date = {2022-01-28},
  url = {https://wallpapercave.com/w/wp9774690},
  urldate = {2022-01-28}
}

@online{margusAnswerIteratingEvery2011,
  title = {Answer to "{{Iterating}} over Every Two Elements in a List"},
  author = {{Margus}},
  date = {2011-03-22},
  url = {https://stackoverflow.com/a/5389578},
  urldate = {2022-05-03}
}

@inreference{Maschinensprache2022,
  title = {Maschinensprache},
  booktitle = {Wikipedia},
  date = {2022-05-31T06:13:39Z},
  url = {https://de.wikipedia.org/w/index.php?title=Maschinensprache&oldid=223307867},
  urldate = {2022-09-13},
  abstract = {Eine Maschinensprache, wie sie bei Maschinencode bzw. nativem Code verwendet wird, ist eine Programmiersprache, bei der die Instruktionen, die vom Prozessor ausgeführt werden sollen, als formale Sprachelemente festgelegt sind. Aufgrund ihrer Nähe zur Hardware wird sie auch verallgemeinernd als die „Programmiersprache eines Computers“ bezeichnet. Umfang und Syntax der Maschinenbefehle sind im Befehlssatz definiert und abhängig vom Prozessortyp. Maschinensprache wird meistens als Binärcode oder vereinfacht mithilfe von Hexadezimalzahlen dargestellt. Ein Maschinenbefehl ist hierbei eine Anweisung an den Prozessor, eine Operation durchzuführen, beispielsweise eine Addition oder einen Wertevergleich. Jede funktionelle Leistung eines Prozessors ist daher Ergebnis der Ausführung von Maschinencode, eines in Maschinensprache vorliegenden Programms. Programme in Maschinensprache werden üblicherweise nicht vom Programmierer direkt erzeugt, sondern unter Nutzung einer höheren Programmiersprache oder einer Assemblersprache, wobei erst mithilfe eines Compilers bzw. Assemblers ausführbarer Maschinencode entsteht. Wird von „Programmierung in Maschinensprache“ gesprochen, ist damit manchmal fälschlicherweise die Programmierung in Assemblersprache gemeint. Bei der Ausführung durch Interpreter werden dagegen die Maschinenbefehle beim Programmstart oder während der Laufzeit erzeugt. Manchmal werden Ausdrücke wie „Maschinencode, Maschinensprache, Binärcode, nativer Code, Programmcode“ synonym verwendet. Sie können jedoch zwei unterschiedliche Bedeutungen haben: Für die typisierende Bezeichnung des verwendeten Codes als Syntaxbestimmung. Beispiel: „Quellcode (für die Programmiersprache XYZ)“ Für den Programmcode eines bestimmten Programms. Beispiel „Binärcode (für Programm ABC)“},
  langid = {ngerman},
  annotation = {Page Version ID: 223307867},
  file = {/home/areo/Zotero/storage/SYBR2DXU/Maschinensprache.html}
}

@inreference{MehrdeutigeGrammatik2013,
  title = {Mehrdeutige Grammatik},
  booktitle = {Wikipedia},
  date = {2013-03-27T03:11:30Z},
  url = {https://de.wikipedia.org/w/index.php?title=Mehrdeutige_Grammatik&oldid=115943783},
  urldate = {2022-09-13},
  abstract = {Existieren bzgl. einer formalen Grammatik für ein Wort mehrere Rechtsableitungen oder Linksableitungen, bzw. gibt es zu einem Wort der Grammatik zwei verschiedene Rechts- oder zwei verschiedene Linksableitungsbäume, die nicht isomorph zueinander sind, dann heißt diese Grammatik mehrdeutig.},
  langid = {ngerman},
  annotation = {Page Version ID: 115943783},
  file = {/home/areo/Zotero/storage/BUT94F4I/Mehrdeutige_Grammatik.html}
}

@inreference{Metasprache2020,
  title = {Metasprache},
  booktitle = {Wikipedia},
  date = {2020-07-26T13:22:35Z},
  url = {https://de.wikipedia.org/w/index.php?title=Metasprache&oldid=202231184},
  urldate = {2022-09-13},
  abstract = {Eine Metasprache ist eine „Sprache über Sprache“. Die Sprache, über die eine Metasprache spricht, ist die zugehörige Objektsprache.Meta kommt aus dem Griechischen (μετά) und bedeutet unter anderem so viel wie ‚hinter‘, ‚über‘.},
  langid = {ngerman},
  annotation = {Page Version ID: 202231184},
  file = {/home/areo/Zotero/storage/JCGC8IVD/Metasprache.html}
}

@inreference{Metasyntax2022,
  title = {Metasyntax},
  booktitle = {Wikipedia},
  date = {2022-04-16T06:49:55Z},
  url = {https://en.wikipedia.org/w/index.php?title=Metasyntax&oldid=1082973684},
  urldate = {2022-09-13},
  abstract = {In logic and computer science, a metasyntax describes the allowable structure and composition of phrases and sentences of a metalanguage, which is used to describe either a natural language or a computer programming language. Some of the widely used formal metalanguages for computer languages are Backus–Naur form (BNF), extended Backus–Naur form (EBNF), Wirth syntax notation (WSN), and augmented Backus–Naur form (ABNF). These metalanguages have their own metasyntax each composed of terminal symbols, nonterminal symbols, and metasymbols. A terminal symbol, such as a word or a token, is a stand-alone structure in a language being defined. A nonterminal symbol represents a syntactic category, which defines one or more valid phrasal or sentence structure consisted of an n-element subset. Metasymbols provide syntactic information for denotational purposes in a given metasyntax. Terminals, nonterminals, and metasymbols do not apply across all metalanguages. Typically, the metalanguage for token-level languages (formally called "regular languages") does not have nonterminals because nesting is not an issue in these regular languages. English, as a metalanguage for describing certain languages, does not contain metasymbols since all explanation could be done using English expression. There are only certain formal metalanguages used for describing recursive languages (formally called context-free languages) that have terminals, nonterminals, and metasymbols in their metasyntax.},
  langid = {english},
  annotation = {Page Version ID: 1082973684},
  file = {/home/areo/Zotero/storage/ZCEMV45C/Metasyntax.html}
}

@online{MethodComplements2023,
  title = {Method of Complements},
  date = {2023-03-29T10:06:07Z},
  url = {https://en.wikipedia.org/w/index.php?title=Method_of_complements&oldid=1147184194},
  urldate = {2023-06-08},
  abstract = {In mathematics and computing, the method of complements is a technique to encode a symmetric range of positive and negative integers in a way that they can use the same algorithm (hardware) for addition throughout the whole range. For a given number of places half of the possible representations of numbers encode the positive numbers, the other half represents their respective additive inverses. The pairs of mutually additive inverse numbers are called complements.  Thus subtraction of any number is implemented by adding its complement. Changing the sign of any number is encoded by generating its complement, which can be done by a very simple and efficient algorithm. This method was commonly used in mechanical calculators and is still used in modern computers. The generalized concept of the radix complement (as described below) is also valuable in number theory, such as in Midy's theorem. The nines' complement of a number given in decimal representation is formed by replacing each digit with nine minus that digit. To subtract a decimal number y (the subtrahend) from another number x (the minuend) two methods may be used: In the first method the nines' complement of x is added to y. Then the nines' complement of the result obtained is formed to produce the desired result. In the second method the nines' complement of y is added to x and one is added to the sum.  The leftmost digit '1' of the result is then discarded. Discarding the leftmost '1' is especially convenient on calculators or computers that use a fixed number of digits: there is nowhere for it to go so it is simply lost during the calculation. The nines' complement plus one is known as the ten's complement. The method of complements can be extended to other number bases (radices); in particular, it is used on most digital computers to perform subtraction, represent negative numbers in base 2 or binary arithmetic and test underflow and overflow in calculation.},
  langid = {english},
  organization = {{Wikipedia}},
  annotation = {Page Version ID: 1147184194},
  file = {/home/areo/Zotero/storage/NZ4U8KFU/Method_of_complements.html}
}

@inreference{NamingConventionProgramming2022,
  title = {Naming Convention (Programming)},
  booktitle = {Wikipedia},
  date = {2022-07-24T02:02:57Z},
  url = {https://en.wikipedia.org/w/index.php?title=Naming_convention_(programming)&oldid=1100066005},
  urldate = {2022-07-30},
  abstract = {In computer programming, a naming convention is a set of rules for choosing the character sequence to be used for identifiers which denote variables, types, functions, and other entities in source code and documentation. Reasons for using a naming convention (as opposed to allowing programmers to choose any character sequence) include the following: To reduce the effort needed to read and understand source code; To enable code reviews to focus on issues more important than syntax and naming standards. To enable code quality review tools to focus their reporting mainly on significant issues other than syntax and style preferences.The choice of naming conventions can be an enormously controversial issue, with partisans of each holding theirs to be the best and others to be inferior. Colloquially, this is said to be a matter of dogma. Many companies have also established their own set of conventions.},
  langid = {english},
  annotation = {Page Version ID: 1100066005},
  file = {/home/areo/Zotero/storage/QG2XJGAC/Naming_convention_(programming).html}
}

@unpublished{nebelTheoretischeInformatik2020,
  type = {Vorlesung},
  title = {Theoretische Informatik},
  author = {Nebel, Bernhard},
  date = {2020},
  url = {http://gki.informatik.uni-freiburg.de/teaching/ss20/info3/index_de.html},
  urldate = {2022-07-09},
  langid = {ngerman},
  venue = {{Universität Freiburg}}
}

@online{neelamWhatDifferenceFunction2014,
  title = {What Is the Difference between Function Signature and Function Prototype?},
  author = {Neelam},
  date = {2014-06-22T15:33:17+00:00},
  url = {https://www.queryhome.com/tech/48466/difference-between-function-signature-function-prototype},
  urldate = {2022-07-18},
  abstract = {What is the difference between function signature and function prototype?},
  langid = {american},
  organization = {{QueryHome}},
  file = {/home/areo/Zotero/storage/BAKB4WP8/difference-between-function-signature-function-prototype.html}
}

@software{nemecCopyFileAnother2022,
  title = {Copy\_file\_to\_another\_repo\_action},
  author = {Nemec, Devin},
  date = {2022-07-27T21:31:16Z},
  origdate = {2020-08-24T19:25:58Z},
  url = {https://github.com/dmnemec/copy_file_to_another_repo_action},
  urldate = {2022-08-03},
  abstract = {This GitHub Action copies a file from the current repository to a location in another repository},
  keywords = {hacktoberfest}
}

@software{NeovimTreesitterPlayground2022,
  title = {Neovim {{Treesitter Playground}}},
  date = {2022-05-03},
  url = {https://github.com/nvim-treesitter/playground},
  urldate = {2022-05-03},
  abstract = {Treesitter playground integrated into Neovim},
  organization = {{nvim-treesitter}},
  keywords = {hacktoberfest,neovim,nvim-treesitter,tree-sitter}
}

@software{Nvimtreesitter2022,
  title = {Nvim-Treesitter},
  date = {2022-05-03},
  url = {https://github.com/nvim-treesitter/nvim-treesitter},
  urldate = {2022-05-03},
  abstract = {Nvim Treesitter configurations and abstraction layer},
  organization = {{nvim-treesitter}},
  keywords = {hacktoberfest,neovim,nvim-treesitter,tree-sitter}
}

@book{nystromParsingExpressionsCrafting2021,
  title = {Parsing {{Expressions}} · {{Crafting Interpreters}}},
  author = {Nystrom, Robert},
  date = {2021},
  publisher = {{Genever Benning}},
  url = {https://www.craftinginterpreters.com/parsing-expressions.html},
  urldate = {2022-07-09}
}

@inreference{Objektcode2019,
  title = {Objektcode},
  booktitle = {Wikipedia},
  date = {2019-11-27T15:00:17Z},
  url = {https://de.wikipedia.org/w/index.php?title=Objektcode&oldid=194427842},
  urldate = {2022-09-13},
  abstract = {Objektcode ist ein Zwischenergebnis eines Compiler- bzw. Übersetzungsvorgangs von einem Computerprogramm.  Einfache Compiler können diesen Schritt überspringen. Der Objektcode besteht hauptsächlich aus Maschinencode für die Architektur, für die das Programm übersetzt wurde. Er enthält üblicherweise kompakten und vorgeparsten Code und oft benutzte Programmbibliotheken, die dann mit anderen Objektdateien gebunden werden. Das Format eines Objektcodes ist abhängig von Programmiersprache, Compiler und der Maschine. Nach dem Erstellen von Objektcode erfolgt normalerweise das Linken, welches als Ergebnis das fertige, ausführbare Programm liefert.},
  langid = {ngerman},
  annotation = {Page Version ID: 194427842},
  file = {/home/areo/Zotero/storage/UVPVKL7H/Objektcode.html}
}

@online{OnlineRechnerBinarInversion,
  title = {Online-{{Rechner}}: {{Binär}}, {{Inversion}} Und {{Komplementcodes}}},
  url = {https://de.planetcalc.com/747/},
  urldate = {2023-06-08},
  file = {/home/areo/Zotero/storage/5E4N28AA/747.html}
}

@online{OnlineRechnerNumerischeKomplemente,
  title = {Online-{{Rechner}}: {{Numerische Komplemente}}},
  url = {https://de.planetcalc.com/8574/},
  urldate = {2023-06-08},
  file = {/home/areo/Zotero/storage/FQM2SGC7/8574.html}
}

@online{ooijenAnswerOneTwo2012,
  title = {Answer to "{{One}} or Two {{UART}} Stop Bits?"},
  shorttitle = {Answer to "{{One}} or Two {{UART}} Stop Bits?},
  author = {family=Ooijen, given=Wouter, prefix=van, useprefix=false},
  date = {2012-04-15},
  url = {https://electronics.stackexchange.com/a/29949},
  urldate = {2022-11-13},
  organization = {{Electrical Engineering Stack Exchange}},
  file = {/home/areo/Zotero/storage/SGMVPYYS/one-or-two-uart-stop-bits.html}
}

@online{OperatorPrecedenceCppreference,
  title = {C {{Operator Precedence}} - Cppreference.Com},
  url = {https://en.cppreference.com/w/c/language/operator_precedence},
  urldate = {2022-04-27},
  file = {/home/areo/Zotero/storage/6W5H2M4R/operator_precedence.html;/home/areo/Zotero/storage/KAN6J8BH/operator_precedence.html}
}

@inreference{Operatorrangfolge2022,
  title = {Operatorrangfolge},
  booktitle = {Wikipedia},
  date = {2022-05-25T15:01:39Z},
  url = {https://de.wikipedia.org/w/index.php?title=Operatorrangfolge&oldid=223157277},
  urldate = {2022-09-13},
  abstract = {Als Operatorrangfolge, -wertigkeit, -priorität oder -präzedenz bezeichnet man in Mathematik, Logik und Informatik eine definierte Halbordnung, in der die Operatoren eines in Infix-Schreibweise vorliegenden Ausdrucks auszuwerten sind. Die Operatorrangfolge ist keine Totalordnung, sondern eine Halbordnung, weil es keine strikte Reihenfolge zwischen allen Operatoren geben muss. Es können auch mehrere Operatoren auf demselben Rang stehen. Zum Beispiel ist in der Arithmetik der Rang von Multiplikation und Division gleich, aber höher als der Rang von Addition und Subtraktion („Punktrechnung vor Strichrechnung“). Eine Klammerung bietet die Möglichkeit der Bevorrangung eines Teilstücks einer Formel: Der eingeklammerte, also von einem Klammerpaar „( ... )“ eingeschlossene Bereich ist rechnerisch zuerst auszuführen und durch das entsprechende Teilergebnis zu ersetzen. Die Klammerung muss die Operatoren samt ihren nötigen Operanden enthalten. Wird also                         a         ⋅         (         b         +         c         )                 \{\textbackslash displaystyle a\textbackslash cdot (b+c)\}    notiert, ist zuerst der Klammerausdruck zu berechnen, also die Summe                         (         b         +         c         )                 \{\textbackslash displaystyle (b+c)\}    zu bilden, bevor                         a                 \{\textbackslash displaystyle a\}    mit dieser Summe multipliziert wird. Durch die Rangfolge kann man explizite Klammerungen sparen. So ist in der Arithmetik                         a         +         b         ⋅         c                 \{\textbackslash displaystyle a+b\textbackslash cdot c\}    gleichbedeutend mit                         a         +         (         b         ⋅         c         )                 \{\textbackslash displaystyle a+(b\textbackslash cdot c)\}   , weil der Multiplikationsoperator einen höheren Rang hat. Für andere Anwendungen dieser Operatorsymbole können jedoch andere Rangordnungen definiert sein. Bei nicht kommutativen Operatoren bedarf es noch zusätzlicher Konvention darüber, ob gleichrangige Teilausdrücke von links nach rechts oder rechts nach links auszuwerten sind, um die Rechenreihenfolge eindeutig festzulegen.},
  langid = {ngerman},
  annotation = {Page Version ID: 223157277},
  file = {/home/areo/Zotero/storage/C53528ND/Operatorrangfolge.html}
}

@inreference{Operatorrangfolge2022a,
  title = {Operatorrangfolge},
  booktitle = {Wikipedia},
  date = {2022-05-25T15:01:39Z},
  url = {https://de.wikipedia.org/w/index.php?title=Operatorrangfolge&oldid=223157277},
  urldate = {2022-09-13},
  abstract = {Als Operatorrangfolge, -wertigkeit, -priorität oder -präzedenz bezeichnet man in Mathematik, Logik und Informatik eine definierte Halbordnung, in der die Operatoren eines in Infix-Schreibweise vorliegenden Ausdrucks auszuwerten sind. Die Operatorrangfolge ist keine Totalordnung, sondern eine Halbordnung, weil es keine strikte Reihenfolge zwischen allen Operatoren geben muss. Es können auch mehrere Operatoren auf demselben Rang stehen. Zum Beispiel ist in der Arithmetik der Rang von Multiplikation und Division gleich, aber höher als der Rang von Addition und Subtraktion („Punktrechnung vor Strichrechnung“). Eine Klammerung bietet die Möglichkeit der Bevorrangung eines Teilstücks einer Formel: Der eingeklammerte, also von einem Klammerpaar „( ... )“ eingeschlossene Bereich ist rechnerisch zuerst auszuführen und durch das entsprechende Teilergebnis zu ersetzen. Die Klammerung muss die Operatoren samt ihren nötigen Operanden enthalten. Wird also                         a         ⋅         (         b         +         c         )                 \{\textbackslash displaystyle a\textbackslash cdot (b+c)\}    notiert, ist zuerst der Klammerausdruck zu berechnen, also die Summe                         (         b         +         c         )                 \{\textbackslash displaystyle (b+c)\}    zu bilden, bevor                         a                 \{\textbackslash displaystyle a\}    mit dieser Summe multipliziert wird. Durch die Rangfolge kann man explizite Klammerungen sparen. So ist in der Arithmetik                         a         +         b         ⋅         c                 \{\textbackslash displaystyle a+b\textbackslash cdot c\}    gleichbedeutend mit                         a         +         (         b         ⋅         c         )                 \{\textbackslash displaystyle a+(b\textbackslash cdot c)\}   , weil der Multiplikationsoperator einen höheren Rang hat. Für andere Anwendungen dieser Operatorsymbole können jedoch andere Rangordnungen definiert sein. Bei nicht kommutativen Operatoren bedarf es noch zusätzlicher Konvention darüber, ob gleichrangige Teilausdrücke von links nach rechts oder rechts nach links auszuwerten sind, um die Rechenreihenfolge eindeutig festzulegen.},
  langid = {ngerman},
  annotation = {Page Version ID: 223157277},
  file = {/home/areo/Zotero/storage/B78Y6N4N/Operatorrangfolge.html}
}

@book{parrLanguageImplementationPatterns2009,
  title = {Language {{Implementation Patterns}}: {{Create Your Own Domain-Specific}} and {{General Programming Languages}}},
  shorttitle = {Language {{Implementation Patterns}}},
  author = {Parr, Terence},
  date = {2009-12-31},
  publisher = {{Pragmatic Bookshelf}},
  abstract = {Learn to build configuration file readers, data readers, model-driven code generators, source-to-source translators, source analyzers, and interpreters. You don't need a background in computer science–ANTLR creator Terence Parr demystifies language implementation by breaking it down into the most common design patterns. Pattern by pattern, you'll learn the key skills you need to implement your own computer languages.Knowing how to create domain-specific languages (DSLs) can give you a huge productivity boost. Instead of writing code in a general-purpose programming language, you can first build a custom language tailored to make you efficient in a particular domain.The key is understanding the common patterns found across language implementations. Language Design Patterns identifies and condenses the most common design patterns, providing sample implementations of each.The pattern implementations use Java, but the patterns themselves are completely general. Some of the implementations use the well-known ANTLR parser generator, so readers will find this book an excellent source of ANTLR examples as well. But this book will benefit anyone interested in implementing languages, regardless of their tool of choice. Other language implementation books focus on compilers, which you rarely need in your daily life. Instead, Language Design Patterns shows you patterns you can use for all kinds of language applications.You'll learn to create configuration file readers, data readers, model-driven code generators, source-to-source translators, source analyzers, and interpreters. Each chapter groups related design patterns and, in each pattern, you'll get hands-on experience by building a complete sample implementation. By the time you finish the book, you'll know how to solve most common language implementation problems.},
  isbn = {978-1-68050-374-6},
  pagetotal = {456},
  keywords = {Computers / General,Computers / Programming / Compilers,Computers / Programming / General,Computers / Software Development \& Engineering / General}
}

@inreference{Parser2022,
  title = {Parser},
  booktitle = {Wikipedia},
  date = {2022-09-08T10:15:27Z},
  url = {https://de.wikipedia.org/w/index.php?title=Parser&oldid=225991691},
  urldate = {2022-09-13},
  abstract = {Ein Parser [ˈpɑːʁzɐ] (englisch to parse, „analysieren“, bzw. lateinisch pars, „Teil“; im Deutschen gelegentlich auch Zerteiler) ist ein Computerprogramm, das in der Informatik für die Zerlegung und Umwandlung einer Eingabe in ein für die Weiterverarbeitung geeigneteres Format zuständig ist. Häufig werden Parser eingesetzt, um im Anschluss an den Analysevorgang die Semantik der Eingabe zu erschließen und daraufhin Aktionen durchzuführen. Im Vergleich zu einem Recognizer, der die Eingabe analysiert und ausgibt, ob diese im Sinne der Vorgaben richtig oder falsch ist, gibt der Parser die Analyse einer Eingabe in einer gewünschten Form aus und erzeugt zusätzlich Strukturbeschreibungen. Die Syntaxanalyse (Parsing) findet auch außerhalb der Informatik Anwendung, z. B. bei der Untersuchung der Struktur von natürlichen Sprachen. In der Grammatik würde die Syntaxanalyse eines Satzes dem Zerlegen des Satzes in seine grammatikalischen Bestandteile (Syntax) entsprechen. Siehe dazu Linguistik.},
  langid = {ngerman},
  annotation = {Page Version ID: 225991691},
  file = {/home/areo/Zotero/storage/JWL9W3GV/Parser.html}
}

@online{ParsersLarkDocumentation,
  title = {Parsers — {{Lark}} Documentation},
  url = {https://lark-parser.readthedocs.io/en/latest/parsers.html},
  urldate = {2022-06-20},
  file = {/home/areo/Zotero/storage/7NQDT5BF/parsers.html}
}

@online{PEP20Zen,
  title = {{{PEP}} 20 – {{The Zen}} of {{Python}} \textbackslash textbar Peps.Python.Org},
  url = {https://peps.python.org/pep-0020/#id3},
  urldate = {2022-04-13},
  file = {/home/areo/Zotero/storage/56SF22DD/pep-0020.html}
}

@online{PEP20Zena,
  title = {{{PEP}} 20 – {{The Zen}} of {{Python}} \textbackslash textbackslashtextbar Peps.Python.Org},
  url = {https://peps.python.org/pep-0020/#id3},
  urldate = {2022-04-13},
  file = {/home/areo/Zotero/storage/I27S9G7L/pep-0020.html}
}

@inreference{PipesUndFilter2021,
  title = {Pipes und Filter},
  booktitle = {Wikipedia},
  date = {2021-06-18T19:11:59Z},
  url = {https://de.wikipedia.org/w/index.php?title=Pipes_und_Filter&oldid=213086457},
  urldate = {2022-09-04},
  abstract = {Pipes und Filter (engl. pipes-and-filters, auch Datenfluss-System) ist ein Architekturmuster aus dem Bereich der Softwareentwicklung. Es beschreibt die Struktur für Systeme, die Datenströme verarbeiten.},
  langid = {ngerman},
  annotation = {Page Version ID: 213086457}
}

@inreference{PipesUndFilter2021a,
  title = {Pipes und Filter},
  booktitle = {Wikipedia},
  date = {2021-06-18T19:11:59Z},
  url = {https://de.wikipedia.org/w/index.php?title=Pipes_und_Filter&oldid=213086457},
  urldate = {2022-09-13},
  abstract = {Pipes und Filter (engl. pipes-and-filters, auch Datenfluss-System) ist ein Architekturmuster aus dem Bereich der Softwareentwicklung. Es beschreibt die Struktur für Systeme, die Datenströme verarbeiten.},
  langid = {ngerman},
  annotation = {Page Version ID: 213086457},
  file = {/home/areo/Zotero/storage/UKX32EXP/Pipes_und_Filter.html}
}

@inreference{ProzeduraleProgrammierung2021,
  title = {Prozedurale Programmierung},
  booktitle = {Wikipedia},
  date = {2021-07-19T15:14:16Z},
  url = {https://de.wikipedia.org/w/index.php?title=Prozedurale_Programmierung&oldid=214023278},
  urldate = {2022-09-13},
  abstract = {Prozedurale Programmierung ist ein Programmierparadigma, nach dem Computerprogramme entwickelt werden können. Die Bezeichnung ist nicht eindeutig; in der Literatur wird sie für verschiedene Bedeutungen verwendet: als Erweiterung des imperativen Paradigmas um den Ansatz, Algorithmen in überschaubare Teile zu zerlegen, die anhand einer definierten Schnittstelle aufrufbar sind. innerhalb des imperativen Paradigmas als Gegenstück zur objektorientierten ProgrammierungVereinzelt wird prozedurale Programmierung auch als Synonym zur imperativen Programmierung an sich oder zur strukturierten Programmierung verstanden.},
  langid = {ngerman},
  annotation = {Page Version ID: 214023278},
  file = {/home/areo/Zotero/storage/3TI9BRLI/Prozedurale_Programmierung.html}
}

@online{Pseudocode2023,
  title = {Pseudocode},
  date = {2023-05-30T21:14:02Z},
  origdate = {2016-03-09T05:32:33Z},
  url = {https://github.com/aimacode/aima-pseudocode},
  urldate = {2023-06-04},
  abstract = {Pseudocode descriptions of the algorithms from Russell And Norvig's "Artificial Intelligence - A Modern Approach"}
}

@online{PubliclyAvailableStandards,
  title = {Publicly {{Available Standards}}},
  url = {https://standards.iso.org/ittf/PubliclyAvailableStandards/},
  urldate = {2022-07-31},
  file = {/home/areo/Zotero/storage/T5PD2E7F/PubliclyAvailableStandards.html}
}

@software{PyInstallerOverview2022,
  title = {{{PyInstaller Overview}}},
  date = {2022-01-28},
  url = {https://github.com/pyinstaller/pyinstaller},
  urldate = {2022-01-28},
  abstract = {Freeze (package) Python programs into stand-alone executables},
  organization = {{PyInstaller}},
  keywords = {bundle,package,py2app,py2exe,pyinstaller,python,python-3,python-to-exe}
}

@online{QualifiersSizeSign2020,
  title = {Qualifiers in {{C}} [ {{Size}}, {{Sign}} and {{Type Qualifiers}} in {{Detail}} ]},
  date = {2020-05-18},
  url = {https://learnprogramo.com/qualifiers-in-c-9/},
  urldate = {2022-04-13},
  abstract = {Qualifiers in C. The Qualifiers are the keywords which are applied to the data types. There are three types of qualifiers in C. 1.Type Qualifiers 2.Size Qua},
  file = {/home/areo/Zotero/storage/9HMPRTT2/qualifiers-in-c-9.html;/home/areo/Zotero/storage/P2SCX2H7/qualifiers-in-c-9.html}
}

@inreference{Recognizer2021,
  title = {Recognizer},
  booktitle = {Wikipedia},
  date = {2021-10-17T08:51:42Z},
  url = {https://de.wikipedia.org/w/index.php?title=Recognizer&oldid=216435306},
  urldate = {2022-09-13},
  abstract = {Ein Recognizer (engl. to recognize: „erkennen“), auch Erkenner, ist in der Informatik ein bestimmtes abstraktes Maschinenmodell, ein sogenannter Automat. Dieser Automat stellt auf Grundlage einer formalen Grammatik fest, ob ein konkretes Wort Element einer formalen Sprache ist oder nicht. Die Sprache wird dabei durch die zugrundegelegte formale Grammatik definiert bzw. erzeugt. Der Recognizer entscheidet nur, ob ein Eingabetext hinsichtlich der Vorgaben „richtig“ oder „falsch“ ist; das unterscheidet ihn von einem Parser, der zusätzlich die analysierte grammatikalische Struktur beschreiben und ausgeben kann. Ein typisches Beispiel für einen Recognizer in der Automatentheorie ist der Kellerautomat.},
  langid = {ngerman},
  annotation = {Page Version ID: 216435306},
  file = {/home/areo/Zotero/storage/S2HXFXBE/Recognizer.html}
}

@inreference{RegisterAllocation2022,
  title = {Register Allocation},
  booktitle = {Wikipedia},
  date = {2022-08-16T21:22:05Z},
  url = {https://en.wikipedia.org/w/index.php?title=Register_allocation&oldid=1104778380},
  urldate = {2022-09-13},
  abstract = {In compiler optimization, register allocation is the process of assigning local automatic variables and expression results to a limited number of processor registers. Register allocation can happen over a basic block (local register allocation), over a whole function/procedure (global register allocation), or across function boundaries traversed via call-graph (interprocedural register allocation). When done per function/procedure the calling convention may require insertion of save/restore around each call-site.},
  langid = {english},
  annotation = {Page Version ID: 1104778380},
  file = {/home/areo/Zotero/storage/F3FD5DMZ/Register_allocation.html}
}

@inreference{RegulaereGrammatik2021,
  title = {Reguläre Grammatik},
  booktitle = {Wikipedia},
  date = {2021-04-03T13:39:14Z},
  url = {https://de.wikipedia.org/w/index.php?title=Regul%C3%A4re_Grammatik&oldid=210508085},
  urldate = {2022-09-13},
  abstract = {Eine reguläre Grammatik ist in der Informatik eine formale Grammatik vom Typ 3 der Chomsky-Hierarchie. Die von solchen Grammatiken erzeugten Sprachen heißen reguläre Sprachen.},
  langid = {ngerman},
  annotation = {Page Version ID: 210508085}
}

@software{reinhartJonathonReinhartStaticx2022,
  title = {{{JonathonReinhart}}/Staticx},
  author = {Reinhart, Jonathon},
  date = {2022-01-23},
  url = {https://github.com/JonathonReinhart/staticx},
  urldate = {2022-01-28},
  abstract = {Create static executable from dynamic executable}
}

@inreference{RekursiverAbstieg2021,
  title = {Rekursiver Abstieg},
  booktitle = {Wikipedia},
  date = {2021-11-08T16:36:18Z},
  url = {https://de.wikipedia.org/w/index.php?title=Rekursiver_Abstieg&oldid=217102237},
  urldate = {2022-09-13},
  abstract = {Rekursiver Abstieg (englisch: recursive descent) ist eine Technik aus dem Compilerbau, die auf direkte Weise (d. h. ohne Tabelle) einen Top-Down-Parser implementiert. Sie zeichnet sich durch geringe Komplexität aus, das Verwenden eines Parsergenerators ist nicht nötig. Bei diesem Verfahren kommt jedem Nichtterminalsymbol eine Prozedur zu, welche die Produktionsregel zu diesem Symbol charakterisiert. Erlauben die Produktionsregeln eine Rekursion, dann rufen sich daher auch diese Prozeduren wechselseitig rekursiv auf. Ein rekursiver Abstieg kann Backtracking enthalten. Ein Verzicht darauf ist jedoch garantiert, wenn eine LL(k)-Grammatik für die zu parsende Sprache gegeben ist. Im Folgenden wird der häufige Fall                         k         =         1                 \{\textbackslash displaystyle k=1\}    angenommen.},
  langid = {ngerman},
  annotation = {Page Version ID: 217102237},
  file = {/home/areo/Zotero/storage/2R84VDHK/Rekursiver_Abstieg.html}
}

@online{ReleasesJgraphDrawiodesktop2022,
  title = {Releases · Jgraph/Drawio-Desktop},
  date = {2022-01-28},
  url = {https://github.com/jgraph/drawio-desktop/releases},
  urldate = {2022-01-28},
  abstract = {Official electron build of diagrams.net. Contribute to jgraph/drawio-desktop development by creating an account on GitHub.}
}

@online{RunningBashScript2020,
  title = {Running a Bash Script - {{Code}} to {{Cloud}} / {{GitHub Actions}}},
  date = {2020-11-04},
  url = {https://github.community/t/running-a-bash-script/141584/2},
  urldate = {2022-04-11},
  abstract = {With that setup the path to the script is relative to the root of your repository, so if your script is .github/script.sh that’s all that’s needed in the run step. Remember that the file must be marked as executable, or you need to explicitly call bash with the script as parameter.},
  file = {/home/areo/Zotero/storage/H466UYLR/2.html;/home/areo/Zotero/storage/X9VD8GKM/2.html}
}

@book{russell2010artificial,
  title = {Artificial Intelligence a Modern Approach},
  author = {Russell, Stuart J},
  date = {2010},
  publisher = {{Pearson Education, Inc.}}
}

@unpublished{schollBetriebssysteme2020,
  type = {Vorlesung},
  title = {Betriebssysteme},
  author = {Scholl, Christoph},
  date = {2020},
  url = {https://abs.informatik.uni-freiburg.de/src/teach_main.php?id=157},
  urldate = {2022-07-09},
  langid = {ngerman},
  venue = {{Universität Freiburg}}
}

@unpublished{schollEinfuhrungEmbeddedSystems2021,
  type = {Vorlesung},
  title = {Einführung in Embedded Systems},
  author = {Scholl, Philipp},
  date = {2021},
  url = {https://earth.informatik.uni-freiburg.de/uploads/es-2122/},
  urldate = {2022-07-09},
  langid = {Englisch},
  venue = {{Universität Freiburg}}
}

@unpublished{schollTechnischeInformatik2022,
  type = {Vorlesung},
  title = {Technische Informatik},
  author = {Scholl, Christoph},
  date = {2022-08-03},
  langid = {ngerman},
  venue = {{Universität Freiburg}}
}

@inreference{Semantik2022,
  title = {Semantik},
  booktitle = {Wikipedia},
  date = {2022-08-18T08:31:25Z},
  url = {https://de.wikipedia.org/w/index.php?title=Semantik&oldid=225429979},
  urldate = {2022-09-13},
  abstract = {Semantik (von altgriechisch σημαίνειν sēmaínein, deutsch ‚bezeichnen, ein Zeichen geben‘), auch Bedeutungslehre, ist eine der drei Disziplinen der Semiotik, der wissenschaftlichen Betrachtung von Zeichen. Die Semantik behandelt die verschiedenen Beziehungen zwischen Zeichen und Bezeichnetem, vor allem für sprachliche Zeichen. Mit dieser Einschränkung ist sie Teil der Linguistik, aber sie kann sich auch mit Zeichen und Symbolen aller Art, etwa auch von Artefakten oder Kunstwerken befassen. Innerhalb der Semiotik hat abgrenzend die Syntaktik die interne Struktur sprachlicher und anderer Zeichensysteme zum Gegenstand und die Pragmatik ist die Theorie der Zeichenverwendung. Eine klaren Abgrenzung ist aus verschiedenen Gründen umstritten. Allgemein ist die Semantik die Wissenschaft der Bedeutung. Die exakte Fixierung einer Bedeutung insbesondere von Sätzen, Satzteilen, Wörtern oder Wortteilen natürlicher oder formaler Sprachen ist Gegenstand der formalen Semantik.},
  langid = {ngerman},
  annotation = {Page Version ID: 225429979},
  file = {/home/areo/Zotero/storage/CCLDFT3I/Semantik.html}
}

@software{shinanLarkModernParsing,
  title = {Lark: A Modern Parsing Library},
  shorttitle = {Lark},
  author = {Shinan, Erez},
  url = {https://github.com/lark-parser/lark},
  urldate = {2022-07-31},
  version = {1.1.2},
  keywords = {ast,{Earley,},{LALR,},{parser,},{parsing,},Software Development - Libraries - Python Modules,Text Processing - General,Text Processing - Linguistic}
}

@online{skochinskyAnswerWhatImmediate2018,
  title = {Answer to "{{What}} Is an Immediate Value?"},
  shorttitle = {Answer to "{{What}} Is an Immediate Value?},
  author = {Skochinsky, Igor},
  date = {2018-03-13},
  url = {https://reverseengineering.stackexchange.com/a/17678},
  urldate = {2022-04-13},
  file = {/home/areo/Zotero/storage/IK8DZHCG/what-is-an-immediate-value.html;/home/areo/Zotero/storage/XUSS6BHA/what-is-an-immediate-value.html}
}

@online{skochinskyAnswerWhatImmediate2018a,
  title = {Answer to "{{What}} Is an Immediate Value?"},
  shorttitle = {Answer to "{{What}} Is an Immediate Value?},
  author = {Skochinsky, Igor},
  date = {2018-03-13},
  url = {https://reverseengineering.stackexchange.com/a/17678},
  urldate = {2022-06-28},
  organization = {{Reverse Engineering Stack Exchange}}
}

@inreference{StrukturierteProgrammierung2021,
  title = {Strukturierte Programmierung},
  booktitle = {Wikipedia},
  date = {2021-06-15T13:59:11Z},
  url = {https://de.wikipedia.org/w/index.php?title=Strukturierte_Programmierung&oldid=212983400},
  urldate = {2022-09-13},
  abstract = {Strukturierte Programmierung ist ein programmiersprachenübergreifendes Programmierparadigma, aus den 1960er Jahren, also noch vor der Softwarekrise. Es beinhaltet zum einen die baumartige Zerlegung eines Programms in Teilprogramme (Prozeduren) und enthält somit das Paradigma der prozeduralen Programmierung. Zudem verlangt die strukturierte Programmierung auf der untersten Ebene die Beschränkung auf lediglich drei Kontrollstrukturen: Sequenz (hintereinander auszuführende Programmanweisungen) Auswahl/Selektion (Verzweigung) Wiederholung/Iteration (Schleifen)Die bekannteste Konsequenz dieses Prinzips ist die Vermeidung oder – abhängig von der Programmiersprache – der eingeschränkte und standardisierte Einsatz der Sprunganweisung, des GOTO. Das Ergebnis der häufigen Verwendung dieser Anweisungen wird häufig abfällig als Spaghetticode bezeichnet.  Durch die konsequente Implementierung von Teilprogrammen mit lokaler Sichtbarkeit von Identifikatoren und Kontrollstrukturen vermeiden strukturierte Programme Codewiederholungen, was Vorteile bei der Suche von Programmfehlern mit sich bringt, die Programme kürzer und übersichtlicher macht und daher die Wartung von Software vereinfacht. Strukturierte Programmierung ist heute in fast allen Bereichen, in denen professionell Software entwickelt wird, eine Selbstverständlichkeit. Die neueren Programmierparadigmen wie generative Programmierung, aspektorientierte Programmierung oder objektorientierte Programmierung bauen auf der strukturierten Programmierung auf und erweitern oder ergänzen diese.},
  langid = {ngerman},
  annotation = {Page Version ID: 212983400},
  file = {/home/areo/Zotero/storage/EYA2CJJM/Strukturierte_Programmierung.html}
}

@inreference{Symboltabelle2013,
  title = {Symboltabelle},
  booktitle = {Wikipedia},
  date = {2013-05-07T19:42:28Z},
  url = {https://de.wikipedia.org/w/index.php?title=Symboltabelle&oldid=118290830},
  urldate = {2022-09-13},
  abstract = {In der Informatik ist eine Symboltabelle eine von Übersetzerprogrammen wie Compiler oder Interpreter verwendete Datenstruktur, die jedem Symbol im Quellcode Angaben wie die Stelle des Auftretens, den Datentyp oder einen Zeiger auf eine Struktur im Speicher zuordnet. Der Begriff Symbol wird in diesem Zusammenhang im Sinne von Bezeichner verwendet. Meist wird eine Symboltabelle durch eine Hashtabelle implementiert. Sie kann entweder nur temporär während der Übersetzung aufgebaut werden oder auch länger vorgehalten werden, um eine spätere Fehlersuche etwa mit einem Debugger zu erleichtern. In Programmiersprachen wie Lisp spielt die Symboltabelle eine darüber hinausgehende Rolle, weil sie auch die zentrale Datenstruktur des Laufzeitsystems darstellt.},
  langid = {ngerman},
  annotation = {Page Version ID: 118290830},
  file = {/home/areo/Zotero/storage/6HLJBWFP/Symboltabelle.html}
}

@inreference{Syntax2022,
  title = {Syntax},
  booktitle = {Wiktionary},
  date = {2022-06-07T12:19:24Z},
  url = {https://de.wiktionary.org/w/index.php?title=Syntax&oldid=9196998},
  urldate = {2022-07-31},
  langid = {ngerman},
  annotation = {Page Version ID: 9196998}
}

@inreference{Syntax2022a,
  title = {Syntax},
  booktitle = {Wikipedia},
  date = {2022-03-26T15:03:34Z},
  url = {https://de.wikipedia.org/w/index.php?title=Syntax&oldid=221516032},
  urldate = {2022-09-13},
  abstract = {Unter Syntax (altgriechisch σύνταξις syntaxis, von σύν syn ‚zusammen‘ und τάξις taxis ‚Ordnung, Reihenfolge‘) versteht man allgemein ein Regelsystem zur Kombination elementarer Zeichen zu zusammengesetzten Zeichen in natürlichen oder künstlichen Zeichensystemen. Die Zusammenfügungsregeln der Syntax stehen hierbei den Interpretationsregeln der Semantik gegenüber. Insbesondere versteht man unter Syntax die Satzlehre, ein Teilgebiet der Grammatik natürlicher Sprachen, das die Zusammenfügung von Wörtern bzw. Wortgruppen zu Sätzen (Satzbau) auf Basis grammatikalischer Gesetzmäßigkeiten (etwa einer bestimmten vorgeschriebenen Satzstellung) behandelt bzw. den Sätzen zugrunde liegende regelmäßige Muster (Satzstruktur) beschreibt. Die Syntax wird in der Regel unterschieden von der linguistischen Morphologie, die den inneren Aufbau der Wörter behandelt, obwohl die Übergänge zwischen beiden Bereichen fließend sein können. Der Ausdruck Syntax wird für natürliche und formale Sprachen verwendet. Das Verhältnis zwischen natürlicher und formaler Syntax wird unterschiedlich gesehen. Für den Logiker Richard Montague (Universal Grammar, 1970) bestand kein prinzipieller Unterschied. Ebenso wie der Begriff Grammatik kann sich der Begriff Syntax auf die Struktureigenschaften von Zeichensystemen selbst oder auf die theoretisch-wissenschaftliche Beschreibung dieser Struktureigenschaften beziehen.},
  langid = {ngerman},
  annotation = {Page Version ID: 221516032}
}

@inreference{Syntaxbaum2022,
  title = {Syntaxbaum},
  booktitle = {Wikipedia},
  date = {2022-05-18T12:27:03Z},
  url = {https://de.wikipedia.org/w/index.php?title=Syntaxbaum&oldid=222977877},
  urldate = {2022-09-13},
  abstract = {Ein Syntax-, Ableitungs- oder Parsebaum ist ein Begriff aus der theoretischen Informatik und der Linguistik. Er bezeichnet eine hierarchische Darstellung der Zergliederung eines Textes.  Syntaxbäume werden sowohl als Hilfsmittel zur graphischen Visualisierung der Zerlegung eingesetzt als auch, in Form einer Datenstruktur, zur Darstellung dieser Zergliederung für die maschinelle Weiterverarbeitung z. B. in einem Compiler oder Übersetzer. Die verschiedenen Bezeichnungen werden in der Literatur nicht einheitlich verwendet. Formal präzise definiert ist nur der Terminus Ableitungsbaum, der sich auf den Begriff der Ableitung stützt. Andere Bezeichnungen für verschiedenartige Bäume können dann, wie unten beschrieben, bei Bedarf technisch näher definiert werden. Anders als in der Informatik, in der Sprachen auch den technischen Möglichkeiten folgend definiert werden können, findet die Linguistik bei der Behandlung natürlicher Sprachen schwierigere Voraussetzungen vor, vor allem weil die Reihenfolge der Bestandteile in einem Satz variieren kann.},
  langid = {ngerman},
  annotation = {Page Version ID: 222977877},
  file = {/home/areo/Zotero/storage/V448AQ9J/Syntaxbaum.html}
}

@unpublished{thiemannCompilerbau2021,
  type = {Vorlesung},
  title = {Compilerbau},
  author = {Thiemann, Peter},
  date = {2021},
  url = {http://proglang.informatik.uni-freiburg.de/teaching/compilerbau/2021ws/},
  urldate = {2022-07-09},
  langid = {Englisch},
  venue = {{Universität Freiburg}}
}

@unpublished{thiemannEinfuehrungProgrammierung2018,
  type = {Vorlesung},
  title = {Einführung in die Programmierung},
  author = {Thiemann, Peter},
  date = {2018},
  url = {http://proglang.informatik.uni-freiburg.de/teaching/info1/2018/},
  urldate = {2022-07-09},
  langid = {ngerman},
  venue = {{Universität Freiburg}}
}

@inreference{TokenUebersetzerbau2014,
  title = {Token (Übersetzerbau)},
  booktitle = {Wikipedia},
  date = {2014-09-06T18:08:37Z},
  url = {https://de.wikipedia.org/w/index.php?title=Token_(%C3%9Cbersetzerbau)&oldid=133785837},
  urldate = {2022-09-13},
  abstract = {Ein Token (Art.: „das“; Pl.: ‚Tokens‘) ist eine Zeichenkette, der von einer formalen Grammatik ein Typ zugewiesen wird. Das Token bildet die lexikalische Grundeinheit für den Parser. Ein Token entspricht in der Grammatik des Parsers einem Terminalsymbol. Im trivialen Fall sind Tokens die Zeichen der ursprünglichen Eingabe: Zum Beispiel der Buchstabe A wird als Token vom Typ A erkannt. Mehrere Zeichen können im Zuge einer lexikalischen Analyse zu Tokens zusammengefasst werden. Die einem Token zu Grunde liegende Zeichenkette heißt Lexem. Beispiele:},
  langid = {ngerman},
  annotation = {Page Version ID: 133785837},
  file = {/home/areo/Zotero/storage/QC63UBQQ/Token_(Übersetzerbau).html}
}

@online{TransformersVisitorsLark,
  title = {Transformers \& {{Visitors}} — {{Lark}} Documentation},
  url = {https://lark-parser.readthedocs.io/en/latest/visitors.html},
  urldate = {2022-07-09},
  file = {/home/areo/Zotero/storage/T8WPRTLG/visitors.html}
}

@software{uedaMakefileLaTeX2022,
  title = {Makefile for {{LaTeX}}},
  author = {Ueda, Takahiro},
  date = {2022-05-10T23:11:46Z},
  origdate = {2018-07-06T15:01:24Z},
  url = {https://github.com/tueda/makefile4latex},
  urldate = {2022-08-03},
  abstract = {A GNU Makefile for typesetting LaTeX documents.}
}

@online{VariablenUndDeklaration,
  title = {Variablen in {{C}} Und {{C}}++, {{Deklaration}} Und {{Definition}} | {{Coder-Welten}}.De},
  url = {https://www.coder-welten.de/einstieg/variablen-in-c-3.html},
  urldate = {2022-08-11},
  file = {/home/areo/Zotero/storage/3NIPZUPZ/variablen-in-c-3.html}
}

@inreference{VariableProgrammierung2022,
  title = {Variable (Programmierung)},
  booktitle = {Wikipedia},
  date = {2022-08-24T07:55:16Z},
  url = {https://de.wikipedia.org/w/index.php?title=Variable_(Programmierung)&oldid=225592766},
  urldate = {2022-09-13},
  abstract = {In der Programmierung ist eine Variable ein abstrakter Behälter für einen Wert, der bei der Ausführung eines Computerprogramm auftritt. Im Normalfall wird eine Variable im Quelltext durch einen Namen bezeichnet und hat eine Adresse im Speicher des Computers. Der durch eine Variable repräsentierte Wert und gegebenenfalls auch die Größe kann – im Unterschied zu einer Konstante – zur Laufzeit des Rechenprozesses verändert werden.},
  langid = {ngerman},
  annotation = {Page Version ID: 225592766},
  file = {/home/areo/Zotero/storage/C9YBDF5D/Variable_(Programmierung).html}
}

@online{vineetnayak28AnswerWhatDifference2016,
  title = {Answer to "{{What}}'s the Difference between Uniform-Cost Search and {{Dijkstra}}'s Algorithm?"},
  shorttitle = {Answer to "{{What}}'s the Difference between Uniform-Cost Search and {{Dijkstra}}'s Algorithm?},
  author = {VineetNayak28},
  date = {2016-09-08},
  url = {https://stackoverflow.com/a/39396812},
  urldate = {2023-06-05},
  organization = {{Stack Overflow}},
  file = {/home/areo/Zotero/storage/LD7FL7MQ/whats-the-difference-between-uniform-cost-search-and-dijkstras-algorithm.html}
}

@online{VisualWhereCan,
  title = {Visual C++ - {{Where}} Can {{I}} Get a List of All Errors \& Warnings? - {{Stack Overflow}}},
  url = {https://stackoverflow.com/questions/1392855/where-can-i-get-a-list-of-all-errors-warnings},
  urldate = {2022-05-10},
  file = {/home/areo/Zotero/storage/3A8CQ72W/where-can-i-get-a-list-of-all-errors-warnings.html;/home/areo/Zotero/storage/RNQABVXT/where-can-i-get-a-list-of-all-errors-warnings.html}
}

@online{VorrangregelnUndAssoziativitat,
  title = {2.1.7 {{Vorrangregeln}} Und {{Assoziativität}}},
  url = {https://www.tu-chemnitz.de/urz/archiv/kursunterlagen/C/kap2/vorrang.htm},
  urldate = {2022-09-05},
  file = {/home/areo/Zotero/storage/KDJYEHAR/vorrang.html}
}

@online{VorrangregelnUndAssoziativitata,
  title = {2.1.7 {{Vorrangregeln}} Und {{Assoziativität}}},
  url = {https://www.tu-chemnitz.de/urz/archiv/kursunterlagen/C/kap2/vorrang.htm},
  urldate = {2022-09-13},
  file = {/home/areo/Zotero/storage/L75NJ9YC/vorrang.html}
}

@online{WelcomeLarkDocumentation,
  title = {Welcome to {{Lark}}’s Documentation! — {{Lark}} Documentation},
  url = {https://lark-parser.readthedocs.io/en/latest/},
  urldate = {2022-07-31},
  file = {/home/areo/Zotero/storage/7V4MTB3F/latest.html}
}

@unpublished{westphalSoftwaretechnik2021,
  type = {Vorlesung},
  title = {Softwaretechnik},
  author = {Westphal, Dr. Bernd},
  date = {2021},
  url = {https://swt.informatik.uni-freiburg.de/teaching/SS2021/swtvl},
  urldate = {2022-07-19},
  langid = {Englisch},
  venue = {{Universität Freiburg}}
}

@online{WhatBootstrapDefinition,
  title = {What Is a {{Bootstrap}}? - {{Definition}} from {{Techopedia}}},
  shorttitle = {What Is a {{Bootstrap}}?},
  url = {http://www.techopedia.com/definition/3328/bootstrap},
  urldate = {2022-06-27},
  abstract = {This definition explains the meaning of Bootstrap and why it matters.},
  langid = {english},
  organization = {{Techopedia.com}}
}

@online{WhatBottomupParsing,
  title = {What Is {{Bottom-up Parsing}}?},
  url = {https://www.tutorialspoint.com/what-is-bottom-up-parsing},
  urldate = {2022-06-22},
  file = {/home/areo/Zotero/storage/YBQ7BSM4/what-is-bottom-up-parsing.html}
}

@online{WhatDifferenceFunction,
  title = {What Is the Difference between Function Prototype and Function Signature?},
  url = {https://www.sololearn.com/Discuss/171026/what-is-the-difference-between-function-prototype-and-function-signature/},
  urldate = {2022-07-18},
  abstract = {Check out what Vaibhav kumar has posted on SoloLearn},
  langid = {english},
  organization = {{SoloLearn}},
  file = {/home/areo/Zotero/storage/YJRVHBA5/what-is-the-difference-between-function-prototype-and-function-signature.html}
}

@online{WhatDifferenceToken,
  title = {What Is the Difference between a Token and a Lexeme?},
  url = {http://newbedev.com/what-is-the-difference-between-a-token-and-a-lexeme},
  urldate = {2022-06-17},
  abstract = {Using "Compilers Principles, Techniques, \& Tools, 2nd Ed." (WorldCat) by Aho, Lam, Sethi and Ullman, AKA the Purple Dragon Book, Lexeme pg. 111 A lexeme is a se},
  langid = {american},
  organization = {{NewbeDEV}},
  file = {/home/areo/Zotero/storage/RXBCRNFP/what-is-the-difference-between-a-token-and-a-lexeme.html;/home/areo/Zotero/storage/YY34L9DQ/what-is-the-difference-between-a-token-and-a-lexeme.html}
}

@online{WhatSpilling2021,
  title = {What Is {{Spilling}}},
  date = {2021-08-01T20:33:24+00:00},
  url = {https://www.geeksforgeeks.org/what-is-spilling/},
  urldate = {2022-08-07},
  abstract = {A Computer Science portal for geeks. It contains well written, well thought and well explained computer science and programming articles, quizzes and practice/competitive programming/company interview Questions.},
  langid = {american},
  organization = {{GeeksforGeeks}},
  file = {/home/areo/Zotero/storage/NKPMLZSK/what-is-spilling.html}
}

@online{WhatTopDownParsing,
  title = {What Is {{Top-Down Parsing}}?},
  url = {https://www.tutorialspoint.com/what-is-top-down-parsing},
  urldate = {2022-06-22},
  file = {/home/areo/Zotero/storage/6IU27G9Y/what-is-top-down-parsing.html}
}

@inreference{WortproblemBerechenbarkeitstheorie2022,
  title = {Wortproblem (Berechenbarkeitstheorie)},
  booktitle = {Wikipedia},
  date = {2022-02-28T18:14:14Z},
  url = {https://de.wikipedia.org/w/index.php?title=Wortproblem_(Berechenbarkeitstheorie)&oldid=220669412},
  urldate = {2022-09-13},
  langid = {ngerman},
  annotation = {Page Version ID: 220669412},
  file = {/home/areo/Zotero/storage/2U9R2QX7/Wortproblem_(Berechenbarkeitstheorie).html}
}

@online{ZahlendarstellungZurBasis,
  title = {Zahlendarstellung Zur {{Basis}}},
  url = {https://www.inf.hs-flensburg.de/lang/informatik/zahlendarstellung.htm},
  urldate = {2023-05-26},
  file = {/home/areo/Zotero/storage/WSWSRARI/zahlendarstellung.html}
}

@online{ziggystarAnswerWhatDifference2013,
  title = {Answer to "{{What}} Is the Difference between Graph Search and Tree Search?"},
  shorttitle = {Answer to "{{What}} Is the Difference between Graph Search and Tree Search?},
  author = {{ziggystar}},
  date = {2013-03-07},
  url = {https://stackoverflow.com/a/15281447},
  urldate = {2023-06-05},
  organization = {{Stack Overflow}},
  file = {/home/areo/Zotero/storage/SR2ALPD7/what-is-the-difference-between-graph-search-and-tree-search.html}
}

@online{ZoteroTextbackslashtextbarYour2022,
  title = {Zotero \textbackslash textbackslashtextbar {{Your}} Personal Research Assistant},
  date = {2022-01-28},
  url = {https://www.zotero.org/},
  urldate = {2022-01-28}
}

@online{ZoteroTextbarYour2022,
  title = {Zotero \textbackslash textbar {{Your}} Personal Research Assistant},
  date = {2022-01-28},
  url = {https://www.zotero.org/},
  urldate = {2022-01-28}
}
