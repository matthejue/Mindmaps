\documentclass[landscape, a4paper]{article}

\input{./content/packages}
\input{./content/desgin}
\input{./content/declarations}

\begin{document}
\fontsize{6.5pt}{6.5pt}\selectfont

\centering

\begin{minipage}[t]{0.19\linewidth}
	\raggedright
	\inlinebox{Important Terms}
	\begin{betterlist}
		\item \nul{State-based execution:} a \cul{path of execution} is described by a sequence of individual program states. The transition between the current and the next states is indicated with \verb|-->|. E.g. \verb|Main.Running --> (Main.Waiting, A.Blocked)|, \nul{Trace-based description of program execution}, \cul{Starvation:} Thread starves (does not progress), because the other threads always communicate with each other, \cul{Livelock:} Describes a situation in which always at least one thread is not blocked, but no thread progresses, \cul{Preemptive scheduling}, \cul{Cooperative scheduling}, Multithreading, \cul{Concurrency}, \cul{Parallelism}, \nul{only sending:} \verb|func snd(ch chan <- int) {}|, \nul{only receiving:} \verb|func rcv(ch <- chan int) {}|, \cul{Dynamic analysis}: Execute the program and observe its behavior, Determine if there is any potential bad behavior based on this specific program run, \cul{Static analysis}: Predict all possible program runs without actually executing the program, events are collected in a program \cul{trace}. A trace is a linear sequence of events and represents an interleaved execution of the program (of individual threads), an \cul{event} registers interesting program behavior. Each event is connected to one of the operations we are interested in, two events are \cul{conflicting events} if they are read/write events for the same variable that come from different threads and at least one of them is a write event, a \cul{data race} arises if two conflicting events appear right next to each other in the trace. That implies that both events may happen in any order, \cul{valid trace reorderings}: Reordering of a trace means that we change the order of its events such that the resulting sequence of events still represents a sensible execution sequence, \cul{Complete} means that all valid reorderings that exhibit some race can be predicted. If a method is \nul{incomplete}, we call every race that is not reported race a \nul{false negative}, \cul{Sound} means that all races reported by the method can be exhibited with some valid reordering of the trace. If a method is \nul{unsound}, it may report a trace as racy even if there is no valid reordering that exhibits a race. Such a report is a \nul{false positive}. A \cul{resource deadlock} arises if a set of threads are blocked and each thread in the set is waiting to acquire a lock held by another thread in the set, whenever we say deadlock we refer to a resource deadlock, \cul{communication deadlocks} arise if threads are blocked due to (missing) channel events such as send and receive, a \cul{promise} is a placeholder for a computation that is explicitly provided by the programmer. A \cul{future} can be viewed as a placeholder for a computation that will eventually become available. A future is then a \cul{specific kind of promise} where the computation is provided at initialization, \cul{Shared Memory Concurrency}: Processes interact by reading and writing shared variables, Locking etc. needed to demarcate critical regions, \cul{Message Passing Concurrency}: processes interact by sending and receiving messages on shared communication channels
		% \begin{betterlist}
		% \item \verb|pre(ch?)|/\verb|post(ch?)|: Wanting to receive / having received on channel \verb|ch|
		% \begin{betterlist}
		%   \item \verb|pre| describes the event before the corresponding operation takes place
		% \end{betterlist}
		% \begin{betterlist}
		%   \item \verb|post| describes the event after the corresponding operation has taken place
		% \end{betterlist}
		% \item \verb|pre(ch!)|/\verb|post(ch!)|: Wanting to send / having sent on channel \verb|ch|
		% \item in case of communication (send-receive), we assume that in the trace the post event of the send always occurs before the post event of the receive
		% \item \cul{Trace:} Sequence of events, expresses interleaved execution of threads
		% \item \cul{Deadlock:} Occurs when all threads are blocked
		% \item \cul{Data race:} Situation in which two unprotected, conflicting memory operations (at least one write) occur simultaneously
		% \begin{betterlist}
		% 	\item all events are post events. Ones simplifies the operation \verb|x++| to \verb|w(x)|
		% 	% \item in a program execution (represented as trace), a data race occurs when two conflicting write/read events occur directly after one another
		% \end{betterlist}
		% \end{betterlist}
	\end{betterlist}
	% \inlinebox{Channels}
	% \begin{betterlist}
	% 	\item \nul{Restricted communication:} \nul{only sending:} \verb|func snd(ch chan <- int) {}|, \nul{only receiving:} \verb|func rcv(ch <- chan int) {}|
	% 	% \item \nul{difference as follows:}
	% 	%   \begin{betterlist}
	% 	%     \item for an unbuffered channel, a sender always has to \cul{synchronize} with a recipient. Sender and recipient always block. The Go runtime system checks if there are blocking sender and recipient for the same channel. If so, they communicate with each other and become unblocked
	% 	%     \item for a buffered channel, the sender behaves \cul{asynchronously} and tries to write the message to the buffer. The sender only blocks if the buffer is full, then it tries again. The recipient always synchronizes with the buffer. If the buffer is empty, the recipient blocks. Otherwise, a message is taken from the buffer
	% 	%   \end{betterlist}
	% 	% \item \nul{Send value \texttt{y} on channel \texttt{ch}:} \verb|ch <- y|
	% 	% \item \nul{Receive from channel \texttt{ch} and save the value in \texttt{x}:} \verb|x = <- ch|
	% \end{betterlist}
	\inlinebox{Mutex and Mutable Variable}
	\vspace{-0.25cm}

	\adjustbox{scale=0.48}{
		% \begin{noindent}
    \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
        type Mutex (chan int)
        func mutex(ch chan int) {
          for {
            <- ch
            ch <- 1
          }
        }
        func newMutex() Mutex {
          var ch = make(chan int, 1)
          return ch
        }
        func newMutex 2 () Mutex {
          var ch = make(chan int) 
          go mutex(ch)
          return ch
        }
        func lock(m Mutex) {
          m <- 1
        }
        func unlock(m Mutex) {
          <- m
        }
        func putMVar2(m MVar, x int) {
          go func() { m <- x }()
        }
    \end{dnumberedcodebox}
    %\end{noindent}
	}
	\adjustbox{scale=0.48}{
		% \begin{noindent}
    \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
      type MVar (chan int)
      func newMVar(x int) MVar {
        var ch = make(chan int, 1)
        ch <- x
        return ch
      }
      func newMVar2(x int) MVar {
        var ch = make(chan int)
        go func() {
          for {
            ch <- x
            x = <- ch
          }
        }()
        return ch
      }
      func takeMVar(m MVar) int {
        var x int
        x = <- m
        return x
      }
      func putMVar(m MVar, x int) {
        m <- x
      }
    \end{dnumberedcodebox}
    %\end{noindent}
	}
	% \inlinebox{Quantified Semaphor}
	%
	% \begin{betterlist}
	% 	\item \nul{Difference Mutex and Semaphore:}
	% 	\begin{betterlist}
	% 		\item \cul{Mutex:} A mutex has the concept of ownership, meaning the thread that locks a mutex must be the one to unlock it. This is crucial for preventing issues like deadlocks or priority inversions.
	% 		\item \cul{Semaphore:} A semaphore does not have ownership rules. Any thread can increment or decrement the semaphore, making it more flexible but also easier to misuse.
	% 	\end{betterlist}
	% \end{betterlist}
\end{minipage}
\begin{minipage}[t]{0.19\linewidth}
	\raggedright

	\inlinebox{Channels of Channels and Quantified Semaphor}
	\begin{betterlist}
		\item \verb|var ch chan (chan int)|: channel that accepts channels of integers

		\vspace{-0.25cm}
		\begin{minipage}[t]{0.48\textwidth}
			\vspace{0.01cm}

			\adjustbox{scale=0.5}{
				% \begin{noindent}
    \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
    type Request struct {
        id  int
        ack chan int
    }
    func worker(req chan Request) {
        var c Request
        for {
            c = <-req
            fmt.Printf("received from %d \n", c.id)
            time.Sleep(1 * 1e9)
            c.ack <- 1
        }
    }
    func client(id int, req chan Request) {
        var ack = make(chan int)
        for {
            c := Request{id, ack}
            req <- c
            <-ack
        }

    }
    func main() {
        var req = make(chan Request)
        go worker(req)
        go client(1, req)
        client(2, req)
    }
    \end{dnumberedcodebox}
    %\end{noindent}
			}
			\inlinebox{Non-determ. Choice (\texttt{select}), Priorisation}
			\vspace{-0.5cm}

			\adjustbox{scale=0.5}{
				% \begin{noindent}
        \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
          select {
            case <-deer:
              numOfDeerSeen++
            case <-elves:
              numOfElvesSeen++
              select {
                case <-deer:
                  numOfDeerSeen++
                default:
              }
          }
          select {
            case <-deer:
              numOfDeerSeen++
            case <-elves:
              select {
              case <-deer:
                numOfDeerSeen++
                go func() { elves <- 1 }()
              default:
                numOfElvesSeen++
              }
            }
        \end{dnumberedcodebox}
      %\end{noindent}   }
			}
			% \adjustbox{scale=0.48}{
			% 	% \begin{noindent}
			%    \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
			%      select {
			%        case <-ch1:
			%        case ch2<-1:
			%        default:
			%      }
			%    \end{dnumberedcodebox}
			%  %\end{noindent}   }
			% }
			%
			% \adjustbox{scale=0.48}{
			% 	% \begin{noindent}
			%      \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
			%      timeout := time.After(4 * 1e9)
			%      select {
			%        case <-ch:
			%        case <-timeout:
			%          fmt.Println("timed out")
			%        return
			%      }
			%      \end{dnumberedcodebox}
			%    %\end{noindent}   }
			% }
		\end{minipage}
		\begin{minipage}[t]{0.48\textwidth}
			\vspace{0.01cm}

			\adjustbox{scale=0.5}{
				% \begin{noindent}
      \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
type QSem struct {
  q              int
  curr           int
  m              Mutex
  signalWaits    Mutex
  signalSignals  Mutex
  noBlockedWaits int
  noBlockedSignals int
}
func newQSem(q int) QSem {
  var m = newMutex()
  qsem := QSem{q, q, m, newMutex(), newMutex(), 
               0, 0}
  return qsem
}
// down
func wait(qsem *QSem) {
  lock(qsem.m)
  if qsem.curr > 0 {
    if qsem.noBlockedSignals > 0 {
      qsem.noBlockedSignals--
      unlock(qsem.m)
      unlock(qsem.signalSignals)
    } else {
      qsem.curr--
      unlock(qsem.m)
    }
  } else {
    qsem.noBlockedWaits++
    unlock(qsem.m)
    lock(qsem.signalWaits)
  }
}
// up
func signal(qsem *QSem) {
  lock(qsem.m)
  if qsem.curr < qsem.q {
    if qsem.noBlockedWaits > 0 {
      qsem.noBlockedWaits--
      unlock(qsem.m)
      unlock(qsem.signalWaits)
    } else {
      qsem.curr++
      unlock(qsem.m)
    }
  } else {
    qsem.noBlockedSignals++
    unlock(qsem.m)
    lock(qsem.signalSignals)
  }
}
      \end{dnumberedcodebox}
    %\end{noindent}   }
			}
		\end{minipage}
	\end{betterlist}
	% \inlinebox{Berrier pattern}
	% % \begin{betterlist}
	% % 	\item 
	% % 	\begin{betterlist}
	% % 		\item multiple tasks will be executed simultaneously. The program will continue as soon as all tasks are done. Effectively a \alert{counting semaphore} is modeled
	% % \end{betterlist}
	% \vspace{-0.25cm}
	%
	% \adjustbox{scale=0.48}{
	% 	% \begin{noindent}
	%          \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
	%          func barrier() {
	%            var ch = make(chan int)
	%            go func() {
	%                task1()
	%                ch <- 1 // signal done
	%            }()
	%            go func() {
	%                task2()
	%                ch <- 1
	%            }()
	%            go func() {
	%                task3()
	%                ch <- 1
	%            }()
	%          \end{dnumberedcodebox}
	%        %\end{noindent}   }
	% }
	% \adjustbox{scale=0.48}{
	% 	% \begin{noindent}
	%          \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
	%          func barrier() {
	%            var ch = make(chan int)
	%            timeout := time.After(4 * 1e9)
	%            for i := 0; i < 3; i++ {
	%                select {
	%                  case <-ch:
	%                  case <-timeout:
	%                      fmt.Println("timed out")
	%                      return
	%                }
	%
	%            }
	%            fmt.Println("done")
	%          }
	%          \end{dnumberedcodebox}
	%        %\end{noindent}   }
	% }
	% \end{betterlist}
	% \inlinebox{Priorisation}
	% \vspace{-0.25cm}

	% \inlinebox{Lists}
	%
	% \adjustbox{scale=0.5}{
	% 	% \begin{noindent}
	%      \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
	%        subs := list.New()
	%        subs.PushBack(s)
	%        for e := subs.Front(); e != nil; e = e.Next() {
	%          s := e.Value.(Sub)
	%          if s.topic == m.topic {
	%            s.news <- m
	%          }
	%        }
	%      \end{dnumberedcodebox}
	%    %\end{noindent}   }
	% }
	% \begin{betterlist}
	% 	\item lists in Go are \alert{heterogeneous}. That is, when one takes an element from the list, one needs to cast its type explicitly
	% \end{betterlist}
	\inlinebox{Conditions for a valid trace reordering}:
	% \textcolor{gray}{Reordering the trace means that one simply permutes the elements}
	\begin{enumerate}
		\item The elements in the reordered trace must be part of the original trace
		\begin{betterlist}
			\item A valid reordering only needs to include a subset of the events of the original trace
		\end{betterlist}

		\item \cul{Program order Condition}: Let P be some trace and P' be a permutation of P. P' preserves program order if, for each thread T, P arrowdown T = P' arrowdown T
		\begin{betterlist}
			\item \nul{notation}: for a trace P and thread T, we write P arrowdown T for the list of events in thread T contained in P
		\end{betterlist}
		\item \cul{Lock Semantics Condition}: Let P be some trace and P' be some reordering of P. If P' = P\textsubscript{1} acq(y) P\textsubscript{2} acq(y) P\textsubscript{3}, then there must be some event rel(y) in P\textsubscript{2}. If P' = P\textsubscript{1} rel(y) P\textsubscript{2}, then there must be some acq(y) such that P\textsubscript{1} = P'\textsubscript{1} acq(y) P''\textsubscript{1} and there is no rel(y) in P''\textsubscript{1}
		\item \cul{Last Writer Condition}: Let P be some trace with a read event r(x) and P' be some reordering of P. The event r(x) must have the same \cul{last writer} in P' as in P
		\begin{betterlist}
			\item If P\textsubscript{1} r(x) P\textsubscript{2} is a trace, then the \cul{last writer} of r(x) is some w(x) such that P\textsubscript{1} = P\textsubscript{1}' w(x) P\textsubscript{1}'' and P\textsubscript{1}'' does not contain another w(x)
		\end{betterlist}
	\end{enumerate}
\end{minipage}
\begin{minipage}[t]{0.19\linewidth}
	\raggedright

	% \inlinebox{Examples for Deadlocks, Livelocks and Starvation via Traces}
	%
	% \adjustbox{scale=0.5}{
	% 	% \begin{noindent}
	%          \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
	%                  import (
	%                    "time"
	%                    "math/rand"
	%                  )
	%                  n := rand.Intn(4)
	%                  time.Sleep(time.Duration(n) * time.Second)
	%                  time.Sleep(100 * time.Millisecond)
	%          \end{dnumberedcodebox}
	%        %\end{noindent}   }
	% }

	% \begin{betterlist}
	% 	\item Santa gives priority to the reindeer in the case that there is both a group of elves and a group of reindeer waiting.
	% \end{betterlist}
	% \inlinebox{Dynamic data race prediction}
	% \item for each event, the trace records the \alert{thread} where the event happened. Each event can be identified by its position in the trace
	% \nul{Motivation}: Rerunning a program over and over again to encounter a trace that detects a data race is very time consuming. 
	\inlinebox{Lamport's \cul{happens-before (HB method, incomplete and unsound) relation}}
	\begin{betterlist}
		% \item Instead of explicitly constructing a reordering, we calculate a happens before relation. It approximates the possible reorderings and thus can be computed efficiently but may lead to \nul{false positives} and \nul{false negatives}%, it approximates the possible reorderings. The HB relation can be computed efficiently but may lead to false positives and false negatives
		% \item \cul{a partial order} on events to determine if one event happens before another event. If events are unordered, we assume that these events may happen concurrently (i.e., in any order). \nul{Ground truth:} the \cul{must happen before relation (mhb)}
		\item any \nul{happens-before (partial) order} (HB relation) approximates the \nul{must happen before relation} (the possible reorderings)
		\begin{betterlist}
			\item if the order is \nul{too large}, it orders events that may not be ordered by mhb: it misses data races and may yield false negatives
			\item if the order is \nul{too small}, it does not order events that may be ordered by mhb: it hallucinates data races and may thus yield false positives
		\end{betterlist}
		% \item if two \nul{conflicting operations} are unordered under the happens-before relation, then we report that these operations are in a \nul{(data) race}
		% \item \textcolor{gray}{One ignores the details of how to instrument programs to carry out tracing of events. In practice, the entire trace does not need to be present as events can be processed \alert{online} in a stream-based fashion. A more detailed \alert{offline} analysis may get better results if the full trace is available}
		% \item in practice, the entire trace does not need to be present as events can be processed \alert{online} in a stream-based fashion. A more detailed \alert{offline} analysis may get better results if the full trace is available
		\item Let T be a trace. We define the HB relation < as the smallest strict partial order that satisfies the following conditions:
		\begin{enumerate}
			\item \cul{Program order:} If t\#e\textsubscript{i}, t\#f\textsubscript{i + n} ‚Ç¨ T for some n > 0, then t\#e\textsubscript{i} < t\#f\textsubscript{i + n}
			\begin{betterlist}
				\item states that events in the same thread are ordered according to their trace position
				\item \cul{Trace and event notation}: We write t\#e\textsubscript{i} to denote event e at trace position i in thread t
			\end{betterlist}
			\item \cul{Critical section order:} If t\textsubscript{1}\#rel(x)\textsubscript{k}, t\textsubscript{2}\#acq(x)\textsubscript{k + n} ‚Ç¨ T with t\textsubscript{1} != t\textsubscript{2} and n > 0, then t\textsubscript{1}\#rel(x)\textsubscript{k} < t\textsubscript{2}\#acq(x)\textsubscript{k + n}
			\begin{betterlist}
				\item states that critical sections are ordered according to their trace position
				\item for each acquire the matching release must be in the same thread. Hence, the critical section order only needs to consider a release and a subsequent acquire
			\end{betterlist}
		\end{enumerate}
		\item \cul{Happens-before data race check:} If there are conflicting events e and f but neither e < f nor f < e , then (e, f) is a HB data race pair. The argument is that if neither e < f nor f < e we are able to reorder the trace such that e and f appear right next to each other (in some reordered trace)
		% \begin{betterlist}
		% \item \nul{note}: if (e, f) is a HB data race pair then so is (f, e). In such a situation, we consider (e, f) and (f, e) as two distinct representative for the same data race. When reporting (and counting) HB data races we only consider a specific representative
		% \end{betterlist}
		\item \nul{False negatives and False positives:}
		\begin{betterlist}
			\item the HB method has \cul{false negatives} because the textual order between critical sections is preserved. That is, valid reorderings that swap critical sections are ignored
			\item the first race reported by the HB method is an \enquote{actual} race. However, subsequent races may be \cul{false positives}
			\begin{betterlist}
				\item the HB relation does not take into account write-read dependencies and therefore HB data races may not correspond to actual data races
				\item we say \enquote{may not} because based on the trace alone we cannot decide if the write-read dependency actually affects the control flow
			\end{betterlist}
		\end{betterlist}
	\end{betterlist}
	% \item \cul{dynamic data race prediction}: we record the trace of a specific program run. Two conflicting events may not appear in the trace right next to each other. However, we may be able to predict that there is some trace reordering under which the two conflicting events appear right next to each other (in the reordered trace)
	% \begin{betterlist}
	% \item to identify conflicting events that are in a race, we could check if there is a valid reordering of the trace under which both events occur right next to each other
	% Exhaustive predictive methods attempt to identify as many reorderings as possible. 
	% \item \cul{Exhaustive data race prediction methods:} A \enquote{simple} data race prediction method seems to compute all possible (valid) reorderings and checks if they contain any data race. Such exhaustive methods do not scale to real-world settings because program runs and the resulting traces may be large and considering all possible reorderings generally leads to an \nul{exponential blow up}
	% \item \cul{Approximative data race prediction methods:} As we favor efficiency (by efficient one means a run-time that is \nul{linear} in the size of the trace. \nul{Efficient methods} approximate by only considering certain reorderings) over exhaustiveness, we may compromise \nul{completeness} and \nul{soundness}:
	% \end{betterlist}
	\inlinebox{Event sets}
	\begin{betterlist}
		\item \cul{Event set }ES\textsubscript{e}: Set of events that happen up-to and including event e. That is, ES\textsubscript{e} = \{ f | f < e \} U \{e\}
		% \item \nul{Observations:} To enforce the critical section order we add the event set ES\textsubscript{rel(y)} of some release event to the event set ES\textsubscript{acq}(y) of some subsequent acquire event, To enforce the program order, we accumulate events within one thread (in essence, building the transitive closure)
		\item to decide if e < f we can check for ES\textsubscript{e} C ES\textsubscript{f}. Consider two conflicting events e and f where e appears before f in the trace. To decide if e and f are in a race, we check for e ‚Ç¨ ES\textsubscript{f} or f ‚Ç¨ ES\textsubscript{e}. If yes, then there is no race (because e < f or f < e). Otherwise, there is a race.

		\item \cul{Set-based race predictor:}
		% \begin{betterlist}
		% \item we compute event sets by processing the events in the trace from beginning to end. We maintain the following state variables when processing event $e_i$: \script{105}{Overview}
		% \item \cul{state variables:}
		% \item each event invokes its processing function: \script{106}{Overview}. We write $e@operation$ for the processing function for event $e$ of the form $operation$. We add thread information as an additional argument
		% \begin{betterlist}
		% 	\item D(t): Each thread t maintains the set of events that happen before e\textsubscript{i}. (initially empty)
		% 	\item R(x): Most recent set of concurrent read events on x. (initially empty)
		% 	\item W(x): Most recent write event on x. (initially undefined)
		% 	\item Rel(y): Contains the event set of the most recent release event on lock y. (initially empty)
		% \end{betterlist}
		% \end{betterlist}
		% \item \nul{e@operation for the processing function for event e of the form operation}:
		\vspace{-0.25cm}

		\adjustbox{scale=0.48}{
			% \begin{noindent}
                \begin{dnumberedcodebox}[minted language=text,minted options={autogobble, fontsize=\large}, box align=top]
                  e@acq(t,y) {
                    D(t) = D(t) U Rel(y) U { e }
                  }
                  e@rel(t,y) {
                    D(t) = D(t) U { e }
                    Rel(y) = D(t)
                  }
                  e@fork(t1,t2) {
                    D(t1) = D(t1) U { e }
                    D(t2) = D(t1)
                  }
                  e@join(t1,t2) {
                    D(t1) = D(t1) U D(t2) U { e }
                  }
                  \end{dnumberedcodebox}
                %\end{noindent}   }
		}
		\adjustbox{scale=0.48}{
			% \begin{noindent}
                \begin{dnumberedcodebox}[minted language=text,minted options={autogobble, fontsize=\large}, box align=top]
                  e@write(t,x) {
                    If W(x) exists and W(x) not in D(t)
                    then write-write race (W(x),e)

                    For each r in R(x),
                    if r not in D(t)
                    then read-write race  (r,e)

                    D(t) = D(t) U { e }
                    W(x) = e
                  }
                  e@read(t,x) {
                    If W(x) exists and W(x) not in D(t)
                    then write-read race (W(x),e)

                    R(x) = {e} U (R(x) \ D(t))
                    D(t) = D(t) cup { e }
                  }
                  \end{dnumberedcodebox}
                %\end{noindent}   }
		}
		\item the size of D(t) may grow linearly in the size of the trace. To check for a race we check if some element is in D(t). If there are n events, set-based race prediction requires O(n\textsuperscript{2}) time
	\end{betterlist}
\end{minipage}
\begin{minipage}[t]{0.19\linewidth}
	\raggedright

\end{minipage}
\begin{minipage}[t]{0.19\linewidth}
	\raggedright

	\inlinebox{Vector Clocks}
	\begin{betterlist}
		% \item \cul{Vector clocks}: A distributed timestamp, A representation for a happens-before relation
		\item Let e be an event in thread t and j its timestamp. Then, we can uniquely identify e via t and j. We write t\#j to represent event e. In the literature, t\#j is called an \cul{epoch}
		\begin{betterlist}
			\item \cul{Timestamps:} Each thread maintains a timestamp, We represent a timestamp as a natural number% One generallly uses the timestamp \enquote{before} processing the event, Each time we process an event we increase the thread‚Äôs timestamp, Initially, the timestamp for each thread is 1. 
			\item for each thread only keep most recent timestamp. E.g. in case of \{1\#\{1, 2\}\} we write \{1\#2\}
		\end{betterlist}
		% \item \cul{set of epochs:} We group together epochs belonging to the same thread. For example, in case of \{1\#1, 1\#2\} we write \{1\#\{1, 2\}\}
		\item a \cul{vector clock} encodes a set of most recent timestamps from n threads as a vector of length n. V ::= [i\textsubscript{1},\ldots ,i\textsubscript{n}] is vector clock with n time stamps. The entry i\textsubscript{t} is the timestamp for thread t. The above vector clock V stands for the set of timestamps V  \sim\sim  \{1\#i\textsubscript{1}, \ldots, n\#i\textsubscript{n}\} % We use the entry 0 to indicate missing information about a thread
		\begin{betterlist}
			\item mapping Phi from event sets to vector clocks as follows: Phi({1\#E\textsubscript{1} , \ldots, n\#E\textsubscript{n}}) = [max(E\textsubscript{1}), \ldots, max(E\textsubscript{n})]
			\begin{betterlist}
				\item each event set can be represented as the set \{1\#E\textsubscript{1}, \ldots, ùëõ\#E\textsubscript{n}\} where sets E\textsubscript{j} are of the form \{1, \ldots, k\}
			\end{betterlist}
			\item \cul{Properties:}
			\begin{enumerate}
				\item D\textsubscript{e} C D\textsubscript{f} iff Phi(D\textsubscript{e}) < Phi(D\textsubscript{f})
				\begin{betterlist}
					\item strict order on vector clocks [i\textsubscript{1},...,i\textsubscript{n}]  < [j\textsubscript{1},...,j\textsubscript{n}]) if i\textsubscript{k}<=j\textsubscript{k} for all k=1\ldots n and there exists k such that i\textsubscript{k}<j\textsubscript{k}
				\end{betterlist}
				\item (D\textsubscript{e} U D\textsubscript{f}) = sync(Phi(D\textsubscript{e}), Phi(D\textsubscript{f}))
				\begin{betterlist}
					\item synchronize two vector clocks by taking the larger time stamp: sync([i\textsubscript{1},...,i\textsubscript{n}],[j\textsubscript{1},...,j\textsubscript{n}]) = [max(i\textsubscript{1},j\textsubscript{1}), ..., max(i\textsubscript{n},j\textsubscript{n})]
				\end{betterlist}
				\item Let e, f be two events where e appears before f and e = t\#k. Then, e !‚Ç¨ D\textsubscript{f} iff k > Phi(D\textsubscript{f})(t)
			\end{enumerate}
		\end{betterlist}
		\item \cul{FastTrack:} A race detector based on vector clocks
		% \begin{betterlist}
		% \item Lookup of time stamp: $[i_1,\ldots,i_t,\ldots,i_n](t) = i_t$
		% \item Increment the time stamp of thread $t$: $inc([\ldots,i_t,\ldots],t) = [\ldots,i_t+1,\ldots]$
		% \item \alert{State variables:}
		% \begin{betterlist}
		% 	\item $Th(t)$: Vector clock of thread $t$
		% 	\item $R(x)$: Vector clock for reads from $x$
		% 	\item $W(x)$: Epoch of most recent write on $x$
		% 	\item $Rel(y)$: Vector clock of the most recent release on lock $y$
		% \end{betterlist}
		% \item initially, the timestamps in $R(x)$, $W(x)$, and $Rel(y)$ are all set to zero
		% \item in $Th(t)$, all time stamps are set to zero except the time stamp for entry $t$, which is set to one
		% \item \alert{Event processing:}
		\vspace{-0.25cm}

		\adjustbox{scale=0.48}{
			% \begin{noindent}
                \begin{dnumberedcodebox}[minted language=text,minted options={autogobble, fontsize=\large}, box align=top]
                acq(t,y) {
                  Th(t) = sync(Th(t), Rel(y))
                  inc(Th(t),t)
                }
                rel(t,y) {
                  Rel(y) = Th(t)
                  inc(Th(t),t)
                }
                fork(t1,t2) {
                  Th(t2) = sync(Th(t1), Th(t2))
                  inc(Th(t1),t1)
                }
                join(t1,t2) {
                  Th(t1) = sync(Th(t1),Th(t2))
                  inc(Th(t1),t1)
                }
                \end{dnumberedcodebox}
              %\end{noindent}   }
		}
		\adjustbox{scale=0.48}{
			% \begin{noindent}
                \begin{dnumberedcodebox}[minted language=text,minted options={autogobble, fontsize=\large}, box align=top]
                write(t,x) {
                  If not (R(x) < Th(t))
                  then write-read race detected
                  If W(x) != 0
                  then let j#k = W(x)
                      if k > Th(t)(j)
                      then write-write race detected
                  W(x) = t#Th(t)(t)
                  inc(Th(t),t)
                }
                read(t,x) {
                  If W(x) != 0
                  then let j#k = W(x)
                      if k > Th(t)(j)
                      then read-write race detected
                  R(x) = sync(Th(t), R(x))
                }
                \end{dnumberedcodebox}
              %\end{noindent}   }
		}
		% \end{betterlist}
	\end{betterlist}
	\inlinebox{Lockset Method (complete but unsound)}
	\begin{betterlist}
		% \item \alert{lockset:} is the set of locks that are held when processing a read/write event
		% \item if the locksets of two conflicting events $e$ and $f$ are \alert{disjoint}, then $(e, f)$ is a \alert{Lockset data race pair}
		% \begin{betterlist}
		% 	\item if two conflicting events hold the same lock $y$, then both events must belong to two distinct critical sections involving lock $y$. As critical sections are mutually exclusive, two conflicting events that share the same lock cannot be in a data race
		% \end{betterlist}
		% \item $(t1\#acq(y)_k, t2\#rel(y)_l)$ is a matching acquire/release pair if
		% \begin{enumerate}
		% 	\item $t1 = t2$, and
		% 	\begin{betterlist}
		% 		\item states that $acq(y)$ and $rel(y)$ belong to the same thread
		% 	\end{betterlist}
		% 	\item $k < l$ and there is no $t\#rel(y)_m$ where $k < m < l$
		% 	\begin{betterlist}
		% 		\item states that there is no other $rel(y)$ between $acq(y)_k$ and $rel(y)_l$
		% 		\item $t\#e_k$ denotes some event $e$ in thread $t$ at trace position $k$
		% 	\end{betterlist}
		% \end{enumerate}
		% \item $CS(t\#acq(y)_k, t\#rel(y)_l)$ denotes the set of events that are part of the critical section for a matching acquire/release pair $(t\#acq(y)k, t\#rel(y)l)$. We only accept events from the same thread $t$
		% \begin{betterlist}
		% 	\item $t'\#e_m \in CS(t\#acq(y)_k, t\#rel(y)_l)$ if $t = t'$ and $k \le m \le l$
		% 	\item $acq(y)$ and $rel(y)$ are part of the critical section; and any event in the same thread between them is also part of this critical section
		% \end{betterlist}
		% \item \alert{lockset of an event $e$:} $LS(e) = \{y \mid \exists a = t\#acq(y)_k, r = t\#rel(y)_l .e \in CS(a, r)\}$
		% \begin{betterlist}
		% 	\item consists of all locks $y$ such that $e$ appears in a critical section belonging to lock $y$
		% \end{betterlist}
		\item \nul{state variables:}
		\begin{betterlist}
			\item ls(t): Set(Lock): The set of locks held by thread t at a certain time
			\item LS : Event -> Set(Lock): A mapping from an event e to its lockset
		\end{betterlist}
		\item \nul{Lockset computation}:
		\vspace{-0.25cm}

		\adjustbox{scale=0.48}{
			% \begin{noindent}
            \begin{dnumberedcodebox}[minted language=text,minted options={autogobble, fontsize=\large}, box align=top]
              e@acq(t,y) {
                ls(t) = ls(t) U {y}
              }
              e@rel(t,y) {
                ls(t) = ls(t) - {y}
              e@fork(t1,t2) {
              }
            \end{dnumberedcodebox}
          %\end{noindent}
		}
		\adjustbox{scale=0.48}{
			% \begin{noindent}
            \begin{dnumberedcodebox}[minted language=text,minted options={autogobble, fontsize=\large}, box align=top]
              e@join(t1,t2) {
              }
              e@write(t,x) {
                LS(e) = ls(t)
              }
              e@read(t,x) {
                LS(e) = ls(t)
              }
            \end{dnumberedcodebox}
          %\end{noindent}
		}
		% \begin{betterlist}
		% \item $S_1 - S_2$ is set difference
		% \item the computation of locksets is agnostic to the presence of fork and join events
		% \end{betterlist}
		% \item after lockset computation for a program finished one considers all possible pairs of confliciting events (read-write ($r(x)_i$, $w(x)_j$) and write-write events ($w(x)_i$ and $w(x)_j$)) and checks:
		\begin{betterlist}
			\item if two locksets are disjoint: LS(c(x)\textsubscript{i}) n LS(c(x)\textsubscript{j}) = \{\} then the conflicting events c(x)\textsubscript{i} and c(x)\textsubscript{j} represent a data race
		\end{betterlist}
		\item \cul{complete}: Because any conflicting pair of events that represent a data race can be shown to be a lockset data race pair
		\item \cul{unsound}: Like HB, the lockset method ignores write-read dependencies (therefore the HB unsoundness example also applies to lockset)
		\begin{betterlist}
			\item There is a further reason for unsoundness because lockset enables reordering of critical sections. By reordering critical sections (to exhibit the data race) we may run into a deadlock
		\end{betterlist}
		\item \nul{comparison and combination with HB method:}
		\begin{betterlist}
			\item in practice, it appears that the lockset method gives rise to significantly \cul{more false positives} than the HB method
			% \item one can combine the HB and lockset method to achieve Efficient, Near Complete and Often Sound Hybrid Dynamic Data Race Prediction (extended version)
			\item unlike Lamport‚Äôs happens-before that is sensitive to the order of critical sections, the computation of locksets is \cul{not affected} if we \cul{reorder critical sections}
		\end{betterlist}
		% \item To be efficient, an implementation based on the lockset method only keeps track of the most recent locksets. That is, each thread maintains a list of the most recent reads/writes and their locksets
		% \item \enquote{fork} information is not recorded in the trace. As one only compares locksets, one can encounter false positives
		% \item Lock variable only included if the write is in that trace
	\end{betterlist}
\end{minipage}
\begin{minipage}[t]{0.19\linewidth}
	\raggedright

	\inlinebox{Lock graphs (Dynamic deadlock prediction)}
	\begin{betterlist}
		% \item \nul{assumptions:} 
		% \begin{betterlist}
		% 	\item concurrent programs making use of acquire and release (mutex operations)
		% 	\item single program run where events that took place are recorded in some trace
		% \end{betterlist}
		\item \nul{Construction:} Locks are nodes. There is an edge from lock x to lock y if a thread holds lock $x$ while it acquires lock $y$
		\begin{betterlist}
			\item B-acq to denote that the acquire is blocked
		\end{betterlist}

		% \item This can be calculated based on lock sets. Check for cycles in the lock graph. If there is a \alert{cycle}, we report that there is a \alert{potential deadlock}
		\item If the lock graph contains a cycle, then there is a potential deadlock
		\item \nul{Precision:} False positive possible. All events take place in the same thread. Common guard lock z.
		\begin{betterlist}
			\item Deadlock prediction based on lock graph for Go-style mutexes results in further false positives
		\end{betterlist}
	\end{betterlist}
	\inlinebox{Lock dependencies}
	\begin{betterlist}
		\item instead of a lock graph we compute lock dependencies on a \cul{per thread} basis. Thus, we can eliminate some of the false positives that arise using lock graphs (but not all)%. A lock dependency ùê∑ = (t, l, ls) is constructed if thread t acquires lock l while holding locks ls . 
		\item we write D = (id, l, ls) to refer to some lock dependency in thread id where lock l is acquired while holding locks ls
		\item \nul{state variables}:
		\begin{betterlist}
			\item ls(t): The set of locks hold by thread t at a certain time
			\item Ds: The set of lock dependencies
		\end{betterlist}
		\item \nul{processing function}:

		\adjustbox{scale=0.5}{
			% \begin{noindent}
            \begin{dnumberedcodebox}[minted language=text,minted options={autogobble, fontsize=\large}, box align=top]
            acq(t,y) {
                Ds = Ds U { (t,y,ls(t)) } if ls(t) != emptyset
                ls(t) = ls(t) U {y}
            }
            rel(t,y) {
                ls(t) = ls(t) \ {y}
            }
            fork(t1,t2) {
            }
            ...
            \end{dnumberedcodebox}
          %\end{noindent}   }
		}
		% \begin{betterlist}
		% 	% \item \nul{set difference:} $S_1 \setminus S_2$ contains all elements in $S_1$ that are not in $S_2$
		% \end{betterlist}
		\item \cul{Cycle check}: A deadlock (warning) is issued if there is a cyclic lock dependency chain D\textsubscript{1}, \ldots, D\textsubscript{n} (each D\textsubscript{i} results from some distinct thread i):
		\begin{betterlist}
			\item (LD-1) ls\textsubscript{i} n ls\textsubscript{j} = \{\} for i != j, and
			\item (LD-2) l\textsubscript{i} ‚Ç¨ ls\textsubscript{i + 1} for i = 1, \ldots, n ‚àí 1, and
			\item (LD-3) l\textsubscript{n} ‚Ç¨ ls\textsubscript{1}
		\end{betterlist}
		\item \nul{Precision:}
		\begin{betterlist}
			\item No deadlock warning is issued if the dependencies are from the same thread
			\item No deadlock warning is issued for common guard lock $z$
			\item \nul{False positive possible:} Due to the \cul{write-read dependency}, events in thread T\textsubscript{1} must happen before the events in thread T\textsubscript{2}
			\item \nul{False negative possible:} \cul{Cross-thread critical} section that includes several events due to the \cul{fork/join dependency}. However, the computation of lock dependencies is \cul{agnostic} to \cul{cross-thread critical sections}
		\end{betterlist}
	\end{betterlist}
	\inlinebox{Tricks}
	\begin{betterlist}
		\item immer bis zu einer Stelle wo es nicht mehr weitergeht ausf√ºhren und dann threads ansehen wo blockierender Channel drin steht
    \item am Ende muss true ingesamt rauskommen, damit trace satisfied bei LTL
    \item bei a U B geht es nur darum, dass in dem Trace etwas existiert, was es erf√ºllt
    \item bei a v b, angeben welcher Trace von welchem von beiden erf√ºllt ist, falls von beiden ist es unn√∂tig, bei oder reicht einer von beiden. Formel mit einem von beiden Operanden entfernt schreiben
	\end{betterlist}
	% \inlinebox{Dining Philosophers}
	% \begin{betterlist}
	% 	\item \nul{Solutions:}
	% 	\begin{betterlist}
	% 		\item in general break the cycle
	% 		\item avoid deadlock by controlling the number of philosophers:
	% 		\begin{betterlist}
	% 			\item if there are only four philosophers at the table, then in the worst case each one picks up a fork. Even then, there is a fork left on the table, and that fork has two neighbors, each of which is holding another fork. Therefore, either of these neighbors can pick up the remaining fork and eat
	% 			\item in addition to avoiding deadlock, this solution also guarantees that no philosopher starves. Imagine that you are sitting at the table and both of your neighbors are eating. You are blocked waiting for your right fork. Eventually your right neighbor will put it down, because eat can‚Äôt run forever. Since you are the only thread waiting for that fork, you will necessarily get it next. By a similar argument, you cannot starve waiting for your left fork
	% 		\end{betterlist}
	% 		\item avoid deadlock by changing the order in which the philosophers pick up forks:
	% 		\begin{betterlist}
	% 			\item there has to be at least one leftie and at least one rightie at the table
	% 			\item \nul{proof by contradiction:} First, assume that deadlock is possible. Then choose one of the supposedly deadlocked philosophers. If she‚Äôs a leftie, you can prove that the philosophers are all lefties, which is a contradiction. Similarly, if she‚Äôs a rightie, you can prove that they are all righties. Either way you get a contradiction; therefore, deadlock is not possible
	% 		\end{betterlist}
	% 	\end{betterlist}
	% \end{betterlist}
\end{minipage}

\newpage

\begin{minipage}[t]{0.19\linewidth}
	\raggedright

	\inlinebox{Future}
	% \begin{betterlist}
	% \item high-level concurrency constructs to support asynchronous programming
	% \item \nul{implementation of futures via channels:}
	% \begin{betterlist}
	% 	% \item \verb|interface{}| to represent a value of arbitrary type
	% 	% \item asynchronously execute some http request. Don't have to wait for the request to complete
	% \end{betterlist}
	\vspace{-0.25cm}

	\adjustbox{scale=0.48}{
		% \begin{noindent}
          \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
          type Comp struct {
              val    interface{}
              status bool
          }
          type Future chan Comp
          func future(f func() (interface{}, bool)) Future {
              ch := make(chan Comp)
              go func() {
                  r, s := f()
                  v := Comp{r, s}
                  for {
                      ch <- v
                  }
              }()
              return ch
          }
          func (ft Future) get() (interface{}, bool) {
          }
          func (ft Future) onSuccess(cb func(interface{})) {
              go func() {
                  c := <- ft
                  v, o := c.val, c.status
                  if o {
                      cb(v)
                  }
              }()
          }
          func (ft Future) onFailure(cb func()) {
              go func() {
                  c := <- ft
                  _, o := c.val, c.status
                  if !o {
                      cb()
                  }
              }()
          }
          \end{dnumberedcodebox}
        %\end{noindent}   }
	}
	\adjustbox{scale=0.48}{
		% \begin{noindent}
            \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
            func getSite(url string) Future {
                return future(func() (interface{}, bool) {
                    resp, err := http.Get(url)
                    if err == nil {
                        return resp, true
                    }
                    return nil, false
                })
            }
            func printResponse(response *http.Response) {
                fmt.Println(response.Request.URL)
                date := response.Header.Get("Date")
                fmt.Println(date)
            }
            func example1() {
                stern := getSite("http://www.stern.de")
                stern.onSuccess(func(result interface{}) {
                    response := result.(*http.Response)
                    printResponse(response)
                })
                stern.onFailure(func() {
                    fmt.Println("failure")
                })
                fmt.Printn("do something else")
                time.Sleep(2 * time.Second)
            }
                        \end{dnumberedcodebox}
          %\end{noindent}   }
	}

	% 	\item \nul{simultaneously waiting for multiple futures:}
	% 	\begin{betterlist}
	% 		\item suppose one has e.g. several http requests and would like to retrieve the first available result. A naive (inefficient) solution would check for each result one after the other. One can be more efficient by using \verb|select| to check for the first available future result
	% 	\end{betterlist}
	%
	%
	% 	\adjustbox{scale=0.5}{
	% 		% \begin{noindent}
	%          \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
	%          func (ft1 Future) first(ft2 Future) Future {
	%              return future(func() (interface{}, bool) {
	%                  var v interface{}
	%                  var o bool
	%
	%                  select {
	%                  case x1 := <-ft1:
	%                      v = x1.val
	%                      o = x1.status
	%
	%                  case x2 := <-ft2:
	%                      v = x2.val
	%                      o = x2.status
	%                  }
	%
	%                  return v, o
	%              })
	%          }
	%
	%          func (ft1 Future) firstSucc(ft2 Future) Future {
	%              return future(func() (interface{}, bool) {
	%                  var v interface{}
	%                  var o bool
	%
	%                  select {
	%                  case x1 := <-ft1:
	%                      if x1.status {
	%                          v = x1.val
	%                          o = x1.status
	%                      }
	%                      else {
	%                          v, o = ft2.get()
	%                      }
	%
	%                  case x2 := <-ft2:
	%                      if x2.status {
	%                          v = x2.val
	%                          o = x2.status
	%                      }
	%                      else {
	%                          v, o = ft.get()
	%                      }
	%                  }
	%
	%                  return v, o
	%              })
	%          }
	%          \end{dnumberedcodebox}
	%        %\end{noindent}   }
	% 	}
	% 	\adjustbox{scale=0.5}{
	% 		% \begin{noindent}
	%          \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
	%          func example2() {
	%              spiegel := getSite("http://www.spiegel.de")
	%              stern := getSite("http://www.stern.de")
	%              welt := getSite("http://www.welt.com")
	%
	%              req := spiegel.first(stern.first(welt))
	%
	%              req.onSuccess(func(result interface{}) {
	%                  response := result.(*http.Response)
	%                  printResponse(response)
	%              })
	%
	%              req.onFailure(func() {
	%                  fmt.Println("failure")
	%              })
	%
	%              fmt.Println("do something else")
	%              time.Sleep(2 * time.Second)
	%          }
	%
	%          func example3() {
	%              booking := func() (int, bool) {
	%                  time.Sleep((time.Duration)(rand.Intn(999)) 
	%                    * time.Millisecond)
	%                  return rand.Intn(50), true
	%              }
	%
	%              ft1 := future(func() (interface{}, bool) {
	%                  return booking()
	%              })
	%
	%              ft2 := future(func() (interface{}, bool) {
	%                  return booking()
	%              })
	%
	%              ft := ft1.firstSucc(ft2)
	%
	%              ft.onSuccess(func(result interface{}) {
	%                  quote := result.(int)
	%                  fmt.Printf("Hotel asks for %d Euros\n", 
	%                    quote)
	%              })
	%
	%              time.Sleep(2 * time.Second)
	%          }
	%          \end{dnumberedcodebox}
	%        %\end{noindent}   }
	% 	}
	% 	\item \nul{implementation with generics:}
	% 	\begin{betterlist}
	% 		\item \verb|interface{}| entails explicit type assertions
	% 	\end{betterlist}
	% 	\adjustbox{scale=0.5}{
	% 		% \begin{noindent}
	%        \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
	%        type Comp[T any] struct {
	%            val    T
	%            status bool
	%        }
	%
	%        type Future[T any] chan Comp[T]
	%
	%        func future[T any](f func() (T, bool)) Future[T] {
	%            ch := make(chan Comp[T])
	%            go func() {
	%                r, s := f()
	%                v := Comp{r, s}
	%                for {
	%                    ch <- v
	%                }
	%            }()
	%            return ch
	%        }
	%        \end{dnumberedcodebox}
	%      %\end{noindent}   }
	% 	}
	% 	% func future[T any](f func() (T, bool)) *Future[T] {
	% 	%     p := newPromise[T]()
	% 	%     go func() {
	% 	%         r, s := f()
	% 	%         if s {
	% 	%             p.setSucc(r)
	% 	%         } else {
	% 	%             p.setFail()
	% 	%         }
	% 	%     }()
	% 	%     return p
	% 	% }
	% 	\adjustbox{scale=0.5}{
	% 		% \begin{noindent}
	%        \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
	%        func example3b() {
	%            booking := func() (int, bool) {
	%                time.Sleep((time.Duration)(rand.Intn(999)) 
	%                  * time.Millisecond)
	%                return rand.Intn(50), true
	%            }
	%
	%            ft1 := future[int](booking)
	%
	%            ft2 := future[int](booking)
	%
	%            ft := ft1.firstSucc(ft2)
	%
	%            ft.onSuccess(func(quote int) {
	%                fmt.Printf("Hotel asks for %d euros\n", 
	%                  quote)
	%            })
	%
	%            time.Sleep(2 * time.Second)
	%        }
	%        \end{dnumberedcodebox}
	%      %\end{noindent}   }
	% 	}
	% % \end{betterlist}
\end{minipage}
\begin{minipage}[t]{0.19\linewidth}
	\raggedright

	\inlinebox{Promises}
	% \begin{betterlist}
	% \item redefine futures in terms of promises. In the process, one \alert{reduces} the \alert{number of goroutines} which optimizes performance.
	% \item previous implementation uses a lot of goroutines: Each future creates a goroutine. Each onSuccess/onFailure call creates a goroutine. first/firstSucc create further futures and therefore further goroutines. \textcolor{gray}{Goroutines in Go are relatively cheap. Still, one should avoid them if possible}. Idea: Each future maintains a list of callback functions. One list for the success case. Another list for the failure case. Each onSuccess/onFailure call adds the callback to the respective list. If the \enquote{future} value is already present there‚Äôs no need to register the callback. We can immediately apply the \enquote{future} value and process the callback
	% \item instead of providing a computation at initialization, promises are futures that are set explicitly (at any time) by the user
	\vspace{-0.25cm}

	\adjustbox{scale=0.48}{
		% \begin{noindent}
        \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
        type Promise[T any] struct {
            val           T
            status        bool
            m             chan int
            succCallBacks []func(T)
            failCallBacks []func()
            empty         bool
        }
        func newPromise[T any]() *Promise[T] {
            p := Promise[T]{empty: true, m: 
              make(chan int, 1), succCallBacks: 
              make([]func(T), 0), failCallBacks: 
              make([]func(), 0)}
            return &p
        }
        func (p *Promise[T]) setSucc(v T) {
            p.m <- 1
            if p.empty {
                p.val = v
                p.status = true
                p.empty = false
                succs := p.succCallBacks
                p.succCallBacks = make([]func(T), 0)
                <- p.m
                go func() {
                    for _, cb := range succs {
                        cb(v)
                    }
                }()
            } else {
                <- p.m
            }
        }
        func (p *Promise[T]) setFail() {
            p.m <- 1
            if p.empty {
                p.status = false
                p.empty = false
                fails := p.failCallBacks
                p.failCallBacks = make([]func(), 0)
                <- p.m
                go func() {
                    for _, cb := range fails {
                        cb()
                    }
                }()
            } else {
                <-p.m
            }
        }
        func future[T any](f func() (T, bool)) *Promise[T] {
            p := newPromise[T]()
            go func() {
                r, s := f()
                if s {
                    p.setSucc(r)
                } else {
                    p.setFail()
                }
            }()
            return p
        }
        func (p *Promise[T]) complete(f func() (T, bool)) {
            go func() {
                r, s := f()
                if s {
                    p.setSucc(r)
                } else {
                    p.setFail()
                }
            }()
        }
        \end{dnumberedcodebox}
      %\end{noindent}   }
	}
	\adjustbox{scale=0.48}{
		% \begin{noindent}
        \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\large}, box align=top]
        func example1() {
            booking := func() (int, bool) {
                time.Sleep((time.Duration)(rand.Intn(999))
                  * time.Millisecond)
                return rand.Intn(50), true
            }
            p1 := newPromise[int]()
            p1.complete(booking)
            p2 := newPromise[int]()
            p2.complete(booking)
            p := p1.firstSucc(p2)
            p.onSuccess(func(quote int) {
                fmt.Printf("Hotel asks for %d euros\n", 
                  quote)
            })
            time.Sleep(2 * time.Second)
        }
        func example2() {
            booking := func() (int, bool) {
                time.Sleep((time.Duration)(rand.Intn(999)) 
                  * time.Millisecond)
                return rand.Intn(50), true
            }
            ft1 := future[int](booking)
            ft2 := future[int](booking)
            ft := ft1.firstSucc(ft2)
            ft.onSuccess(func(quote int) {
                fmt.Printf("Hotel asks for %d euros\n", 
                  quote)
            })
            time.Sleep(2 * time.Second)
        }
        func (p *Promise[T]) onSuccess(cb func(T)) {
            p.m <- 1
            if p.empty {
                p.succCallBacks = append(p.succCallBacks, 
                  cb)
            } else if !p.empty && p.status {
                go cb(p.val)
            } else { }
            <-p.m
        }
        func (p *Promise[T]) onFailure(cb func()) {
            p.m <- 1
            if p.empty {
                p.failCallBacks = append(p.failCallBacks, 
                  cb)
            } else if !p.empty && !p.status {
                go cb()
            } else {}
            <-p.m
        }
        func (p1 *Promise[T]) tryCompleteWith(p2 
          *Promise[T]) {
            p2.onSuccess(func(v T) {
                p1.setSucc(v)
            })
        }
        func (p1 *Promise[T]) firstSucc(p2 *Promise[T]) 
          *Promise[T] {
            p := newPromise[T]()
            p.tryCompleteWith(p1)
            p.tryCompleteWith(p2)
            return p
        }
        \end{dnumberedcodebox}
      %\end{noindent}   }
	}
	% \end{betterlist}
\end{minipage}
\begin{minipage}[t]{0.19\linewidth}
	\raggedright

	\inlinebox{Linear Temporal Logic (LTL)}
	\begin{betterlist}
		\item \nul{syntax:}
		\begin{betterlist}
			\item phi  ::= true | a | phi\textsubscript{1} \raisebox{-0.5mm}{\^{}} phi\textsubscript{2} | \raisebox{-0.5mm}{\~{}}phi | ()p (next) | phi\textsubscript{1} U phi\textsubscript{2} (until)
      \item <>phi = true U phi (eventually)\quad []phi = \raisebox{-0.5mm}{\~{}}<>\raisebox{-0.5mm}{\~{}}phi (always)
			\item{} []<>phi (infinitely often)\quad <>[]phi (almost always)
		\end{betterlist}
		\item \nul{semantics:}
		\begin{betterlist}
			\item sigma |\raisebox{0.5mm}{=} true
			\item sigma |\raisebox{0.5mm}{=} a iff A\textsubscript{0} |\raisebox{0.5mm}{=} a ,i.e., a ‚Ç¨ A\textsubscript{0}
			\item sigma |\raisebox{0.5mm}{=} phi\textsubscript{1} \raisebox{-0.5mm}{\^{}} phi\textsubscript{2} iff sigma |\raisebox{0.5mm}{=} phi\textsubscript{1} and sigma |\raisebox{0.5mm}{=} phi\textsubscript{2}
			\item sigma |\raisebox{0.5mm}{=} \raisebox{-0.5mm}{\~{}}phi iff sigma !|\raisebox{0.5mm}{=} phi
			\item sigma |\raisebox{0.5mm}{=} ()phi iff suffix(sigma, 1) = A1 A2 A3 \ldots |\raisebox{0.5mm}{=}phi
			\item sigma |\raisebox{0.5mm}{=} phi\textsubscript{1} U phi\textsubscript{2} iff there exists j >= 0 s.t.
			\begin{betterlist}
				\item suffix(sigma, j) = Aj Aj+1 Aj+2 \ldots |\raisebox{0.5mm}{=} phi\textsubscript{2} and
				\item suffix(sigma, i) = Ai Ai+1 Ai+2 \ldots |\raisebox{0.5mm}{=} phi\textsubscript{1} for 0 <= i < j
			\end{betterlist}
		\end{betterlist}
		% \item sigma |\raisebox{0.5mm}{=} phi 1 U phi 2 iff there exists j >= 0 such that
		% \begin{betterlist}
		% 	\item Aj Aj+1 Aj+2 \ldots |\raisebox{0.5mm}{=} phi\textsubscript{2} and
		% 	\item Ai Ai+1 Ai+2 \ldots |\raisebox{0.5mm}{=} phi\textsubscript{1} for 0 <= i < j
		% \end{betterlist}
		\item sigma |\raisebox{0.5mm}{=} <>phi iff there exists j >= 0 s.t. Aj Aj+1 Aj+2 \ldots |\raisebox{0.5mm}{=}phi
		\item sigma |\raisebox{0.5mm}{=} []phi iff for all j >= 0 we have Aj Aj+1 Aj+2 \ldots |\raisebox{0.5mm}{=} phi
		% \item sigma |\raisebox{0.5mm}{=} ‚ô¶phi iff there exists j >= 0 such that
		% \begin{betterlist}
		% 	\item Aj Aj+1 Aj+2 \ldots |\raisebox{0.5mm}{=} phi
		% \end{betterlist}
		% \item sigma |\raisebox{0.5mm}{=} phi iff for all j >= 0 we have:
		% \begin{betterlist}
		% 	\item Aj Aj+1 Aj+2 \ldots |\raisebox{0.5mm}{=} phi
		% \end{betterlist}
		\item sigma |\raisebox{0.5mm}{=} []<>phi iff there are \nul{infinitely many} j >= 0 s.t. A j A j+1 A j+2 \ldots |\raisebox{0.5mm}{=} phi
		\item sigma |\raisebox{0.5mm}{=} <>[]phi iff for \nul{almost all} j >= 0 we have Aj Aj+1 Aj+2 \ldots |\raisebox{0.5mm}{=} phi
    \item inf. path fragment = state0 state1 state2  \ldots |\raisebox{0.4mm}{=} phi iff \cul{trace(inf. path fragment) |}\raisebox{0.4mm}{=} \cul{phi} iff \cul{trace(path) }‚Ç¨ \cul{Words(phi)} (inf. path fragment doesn't need to start at initial state)
    \item \cul{state |}\raisebox{0.4mm}{=} \cul{phi} iff trace(path) |\raisebox{0.4mm}{=} phi for all path ‚Ç¨ Paths(state) iff \cul{Traces(state) C}\raisebox{0.3mm}{=} \cul{Words(phi)}
    \item \cul{T |}\raisebox{0.4mm}{=} \cul{phi} iff s\textsubscript{0} |\raisebox{0.4mm}{=} phi for all s\textsubscript{0} ‚Ç¨ S\textsubscript{0} iff trace(path) |\raisebox{0.4mm}{=} phi for all path ‚Ç¨ Paths(T) iff \cul{Traces(T) C}\raisebox{0.3mm}{=}\cul{ Words(phi)} iff T |\raisebox{0.4mm}{=} Words(phi)
    \item TODO: Die Sache mit maximal und initial execution / path fragment auch aufs Cheatsheet, trace genaue Definition
	\end{betterlist}
\end{minipage}
\begin{minipage}[t]{0.19\linewidth}
	\raggedright

	\inlinebox{Pi Calculus}
	\begin{betterlist}
		\item TODO: syntax a sind channels, y, z sind variablen
		\item \cul{alpha-conversion} (written P =alpha  Q) is the consistent renaming of bound variables or bound names. It must not change or hide free variables/names
		\item A \cul{substitution} [x := a] applied to a process P (as in P[x := a]) replaces all free occurrences of variable x by name a. Substitution is \cul{capture-avoiding}, that is, it alpha-converts bound names as needed.
		\item \cul{Structural Congruence (Axioms):}
		\begin{betterlist}
			\item P equiv  P (reflexivity)
			\item P equiv  Q =>  Q equiv  P (symmetry)
			\item P equiv  R and R equiv  Q =>  P equiv  Q (transitivity)
			\vspace{0.25cm}
			\item P equiv  Q =>  (v a)P equiv  (v a)Q (congruence-res)
			\item P equiv  Q =>  P | R equiv  Q | R (congruence-par)
			\item P equiv  Q =>  pi .P equiv  pi .Q (congruence-comm)
			\item P equiv  Q => !P equiv !Q (congruence-repl)
			\item P =a  Q => P equiv  Q
		\end{betterlist}
		\item \nul{Structural congruence equiv is the smallest congruence on terms P of the monadic pi-calculus}:
		\begin{betterlist}
			\item  P + 0 equiv  P, P + Q equiv  Q + P, P + (Q + R) equiv  (P + Q) + R
			\item  P | 0 equiv  P, P | Q equiv  Q | P, P | (Q | R) equiv  (P | Q) | R \nul{(same for ST)}
			\item (v a)(P | Q) equiv  P | (v a)Q if a !‚Ç¨ fn(P), (v a)0 equiv  0, (v a)(v b)P equiv  (v b)(v a)P (\nul{same for ST, Condition x, y !‚Ç¨ fv(Q) not necessary by variable convention})
			\item !P equiv P |!P
		\end{betterlist}
		\item \nul{The reduction relation is the smallest binary relation $\rightarrow$ on terms satisfying}:
		\begin{betterlist}
			\item (TAU) tau.P -> P (unobservable action)
			\item $\text{(STRUCT)}\dfrac{\text{P' equiv P\quad P-> Q\quad Q equiv Q'}}{\text{P'-> Q'}}$ (\nul{same for ST})
			\item (REACT) (a<v>.P1 + Q) | (a(z).P2 + R) -> P1 | P2 [z := v ]
			\item $\text{(PAR)}\dfrac{\text{P -> P'}}{\text{P | Q -> P' | Q}}$ (\nul{same for ST})
			\item $\text{(RES)}\dfrac{\text{P -> P'}}{\text{(nu a)P -> (nu a)P'}}$ (\nul{same for ST})
		\end{betterlist}
	\end{betterlist}
	% \begin{betterlist}
	% \item \nul{Expressiveness:} message passing may be implemented using shared variables (viz. consumer/producer message queue implementations)
	% \item \nul{expressiveness:} shared variables may be implemented using message passing
	% \end{betterlist}
	% \item \nul{Synchronous vs. Asynchronous}
	% \begin{betterlist}
	% 	\item receive operation blocks either way
	% 	\item given a channel with synchronous operations,
	% 	\begin{betterlist}
	% 		\item send asynchronously by sending in a spawned thread
	% 	\end{betterlist}
	% 	\item given a channel with asynchronous operations.
	% 	\begin{betterlist}
	% 		\item establish a protocol to acknowledge receipts
	% 		\item pair each send operation with a receive for the acknowledgment
	% 	\end{betterlist}
	% \end{betterlist}
	% \item \alert{Hoare‚Äôs Communicating Sequential Processes (CSP)}:

	% \includegraphics[width=0.6\linewidth]{./figures/csp.png}
	% \inlinebox{Confusion Matrix}
	% \begin{betterlist}
	% 	\item $1$st part is about whether \alert{actual condition $==$ predicted condition} and the $2$nd part is about the \alert{predicted condition}
	% \end{betterlist}
	%
	% \vspace{0.4cm}
	% \begin{longtblr}[
	% 	label = none,
	% 	entry = none,
	% 	]{
	% 	width = \linewidth,
	% 	colspec = {Q[267]Q[319]Q[337]},
	% 	cells = {c},
	% 	hlines = {0.1mm},
	% 	vlines = {0.1mm},
	% 	}
	% 	                & Predicted Positive  & Predicted Negative  \\
	% 	Actual Positive & True Positive (TP)  & False Negative (FN) \\
	% 	Actual Negative & False Positive (FP) & True Negative (TN)
	% \end{longtblr}
	% \vspace{-0.5cm}
	%
	% \begin{betterlist}
	% 	\item \alert{True Positive (TP):} Correctly predicted as positive (correct alarm)
	% 	\begin{betterlist}
	% 		\item all actual positives predicted correctly (no false positives) if \alert{sound}
	% 		\item $pred=True, real=True$, if the tool detects the hypothesis it's present in reality, thus it can't happen that the tool detects the hyptothesis but it's not present in reality, because else the tool wouldn't always be right when detecting the hypothesis
	% 	\end{betterlist}
	% 	\item \alert{True Negative (TN):} Correctly predicted as negative (correct non-detection)
	% 	\begin{betterlist}
	% 		\item all actual negatives predicted correctly (no false negatives) if \alert{complete}
	% 		\item $pred=False, real=False$, if the tool does not detect the hypothesis it isn't present in reality, thus it can't happen that the hypothesis is present in reality but can't be detected by the tool because else the tool wouldn't always be right when not detecting the hypothesis
	% 	\end{betterlist}
	% 	\item \alert{False Positive (FP):} Incorrectly predicted as positive (false alarm)
	% 	\begin{betterlist}
	% 		\item appear if \alert{unsound }
	% 		\item $pred=True, real=False$, if the tool sometimes detects the hypothesis but it's not present reality
	% 	\end{betterlist}
	% 	\item \alert{False Negative (FN):} Incorrectly predicted as negative (missed detection)
	% 	\begin{betterlist}
	% 		\item appear if \alert{incomplete}
	% 		\item $pred=False, real=True$, if the hypothesis is present in reality but it can't always be detected by the tool
	% 	\end{betterlist}
	% \end{betterlist}
\end{minipage}
\begin{minipage}[t]{0.19\linewidth}
	\raggedright

	\inlinebox{Session Types}
	\begin{betterlist}
		\item \nul{Processes:} P, Q ::= x<v>.P (send) | qx(y).P (receive) | P | Q (parallel composition) | if v then P else Q (conditional) | 0 (inaction) | (nu x y)P (scope restriction) | x < l.P (selection) | x > \{i : P\textsubscript{i}\}\textsubscript{i‚Ç¨I} (branching)
		\item \nul{Values:} v ::= x (variable) | true | false (boolean values)
		\item x is the server end and y the client end. x and y are \cul{co-variables}
		\begin{betterlist}
			\item \cul{Capture-free substitution} of x by v in P : P [v/x] ([x := v])
			\item \cul{Barendregt‚Äôs variable convention:} bound variables are pairwise distinct and distinct from free variables
			\item !P \^= (v x1 x2)(x1<x2> | un x2(y).(P | x1<y>)) where x1, x2, y !‚Ç¨ fv(P) where where x1 = mu a.un!a.a and x2 = mu b.un?b.b
		\end{betterlist}
		\item \nul{Reduction rules (P -> P):}
		\begin{betterlist}
			\item (R-LinCom) $\dfrac{}{\text{(nu x y)(xv.P | lin y(z).Q | R) -> (nu x y)(P | Q[v/z] | R)}}$
			\item (R-UnCom) $\dfrac{}{\text{(nu x y)(xv.P | un y(z).Q | R) -> (nu x y)(P | Q[v/z] | un y(z).Q | R)}}$
			\item (R-IfT / IfF) $\dfrac{}{\text{if true / false then P else Q -> P / Q}}$
			\item (R-Case) $\dfrac{\text{j‚Ç¨ I}}{\text{(nu x y)(x < j.P | y > \{i: Q\textsubscript{i}\}\textsubscript{i‚Ç¨I} | R) -> (nu x y)(P | Q\textsubscript{j} | R)}}$
		\end{betterlist}
		\item \nul{Types:}
		\begin{betterlist}
			\item \nul{Qualifiers:} q ::= lin (linear) | un (unrestricted)
			\item \nul{Pretypes:} p ::= ?T.S (receive) | !T.S (send) | +\{i : S\textsubscript{i}\}\textsubscript{i‚Ç¨I} (select) | \&\{i : S\textsubscript{i}\}\textsubscript{i‚Ç¨I} (branch)
			\item \nul{Types:} S, T, U ::= bool (boolean) | end (termination) | qp (qualified pretype) | a (type variable) | mu a.T (recursive type)
			\item \nul{Contexts:} gamma ::= \{\} (empty context) | gamma, x : T (assumption)
		\end{betterlist}
		\begin{betterlist}
			\item \cul{Linearity:} value of type lin T must be used exactly once
			\item \cul{Unrestricted:} value of type un T can be used zero or more times
			\item Variable x for \cul{(arbitrarily) qualified type}, a for \cul{unrestricted type}, c for \cul{linear type}
			\item mu a.T equiv T [mu a.T /a], *U \^= mu a.U.a.
			\item q\textsubscript{syntax} = un implies q\textsubscript{type} = un (only: {(un, un), (lin, lin), (lin, un)})
		\end{betterlist}
		\item \nul{server‚Äôs type is dual to the client‚Äôs type:}
		\begin{betterlist}
			\item dual(q?T.U) = q!T.dual(U) \quad dual(q!T.U) = q?T.dual(U) \quad dual(end) = end \quad dual(mu a.T) = mu a.dual(T) \quad dual(a) = a \quad dual(q+\{i : S\textsubscript{i}\}\textsubscript{i‚Ç¨I}) = q\&\{i : dual(S\textsubscript{i})\}\textsubscript{i‚Ç¨I} \quad dual(q\&\{i : S\textsubscript{i}\}\textsubscript{i‚Ç¨I}) = q+\{i : dual(S\textsubscript{i})\}\textsubscript{i‚Ç¨I}
		\end{betterlist}
		\item \nul{sending a channel:}
		\vspace{-0.25cm}

		\adjustbox{scale=0.5}{
			% \begin{noindent}
    \begin{dnumberedcodebox}[minted language=text, minted options={autogobble, fontsize=\large}, box align=top]
      (nu x1 x2) // !(!bool.end).end
      (nu y1 y2) // ?bool.end
      x1!y2 | x2?z.z!true. | y1?z.printBoolean!z.0
    \end{dnumberedcodebox}
    %\end{noindent}
		}
		\item \nul{unrestricted server:}
		\vspace{-0.25cm}

		% \adjustbox{scale=0.5}{
		% 	% \begin{noindent}
		%   \begin{dnumberedcodebox}[minted language=text, minted options={autogobble, fontsize=\large}, box align=top]
		%     (nu client server)( // mu s.un?(lin!integer.lin!integer.end).s
		%     (nu d1 d2)( // mu a.un!a.a
		%     un d2(e)(
		%     (nu reader writer)( // lin?integer.lin?integer.end
		%     server!writer.reader?x.reader?y.printInteger!x+y) 
		%     | d1<e>) | d1<d2>)
		%     | client?c.c!5.c!7.client?c.c!5.c!7
		%     | client?c.c!3.c!7)
		%   \end{dnumberedcodebox}
		%   %\end{noindent}
		% }
		\adjustbox{scale=0.5}{
			% \begin{noindent}
    \begin{dnumberedcodebox}[minted language=text, minted options={autogobble, fontsize=\large}, box align=top]
(nu d1 d2)( // mu s.un !bool.s
  (nu client server)( // mu a.un+{max: un?(lin!integer.lin!integer.lin?integer.end).a}, 
                   //          quit: end}
    un d2?_.server > 
      {max: (nu writer reader)( // lin!integer.lin!integer.lin?integer.end
              server!writer.reader?x.reader?y if x > y then reader!x else reader!y
             ),
       quit: 0}
    | d1!true.client < max.client?c.c!-4.c!2.c?x.printInteger!x.d1!true.client > quit
    | d1!true.client < max.client?c.c!3.c!7.c?x.printInteger!x.d1!true.client > quit
  )
)
    \end{dnumberedcodebox}
    %\end{noindent}
		}
		\item \nul{linear server:}
		\vspace{-0.25cm}

		\adjustbox{scale=0.5}{
			% \begin{noindent}
    \begin{dnumberedcodebox}[minted language=text, minted options={autogobble, fontsize=\large}, box align=top]
(nu d1 d2)( // mu s.un!(mu a.lin+{max: lin!integer.lin!integer.lin?integer.a, quit: end}).s
  (nu client server)( // mu a.lin+{max: lin!integer.lin!integer.lin?integer.a, quit: end}
    un d2?s.s > {max: s?x.s?y if x > y then s!x.d1!s else s!y.d1!s, quit: 0}
    | d1!server.client < max.client!-4.client!2.client?x.printInteger!x.client > quit
  )
)
    \end{dnumberedcodebox}
    %\end{noindent}
		}
		% 		\item \nul{server with linear type:}
		% 		\vspace{-0.25cm}
		%
		% 		\adjustbox{scale=0.5}{
		% 			% \begin{noindent}
%     \begin{dnumberedcodebox}[minted language=text, minted options={autogobble, fontsize=\large}, box align=top]
% (nu client server) // mu a.lin +{max: lin!integer!integer.?integer.a,
%                 //           quit: end}
% client < quit.client!-4.client!2.client?x.printInteger!x.client < quit
% | server > {max server?x.server?y.if x > y then server!x else server!y,
%                    quit: 0}
%     \end{dnumberedcodebox}
%     %\end{noindent}
		% 		}
		\item \nul{linear syntax with unrestricted type:}
		\vspace{-0.25cm}

		\adjustbox{scale=0.5}{
			% \begin{noindent}
    \begin{dnumberedcodebox}[minted language=text, minted options={autogobble, fontsize=\large}, box align=top]
      (nu x1 x2)( // x1 = mu a.un ?bool.a = *?bool
        lin x1(y) | x2<true> | x2<true>
      )
    \end{dnumberedcodebox}
    %\end{noindent}
		}
		\item \nul{linear syntax with linear / unrestricted type:}
		\vspace{-0.25cm}

		\adjustbox{scale=0.5}{
			% \begin{noindent}
    \begin{dnumberedcodebox}[minted language=text, minted options={autogobble, fontsize=\large}, box align=top]
      (nu x1 x2)( // x1 = lin ?bool or x1 = un ?bool
        lin x1(y) | x2<true>
      )
    \end{dnumberedcodebox}
    %\end{noindent}
		}
	\end{betterlist}
\end{minipage}
\end{document}
