\documentclass[landscape, a4paper]{article}

\input{./content/packages}
\input{./content/desgin}
\input{./content/declarations}

\begin{document}
\fontsize{3pt}{3pt}\selectfont

\begin{minipage}[t]{0.2\linewidth}
	\fbox{General} \script{1}{Lecture Slides} \lecturenotes{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/slides/bonus/2024_04_17_lecture_1.md}
	\begin{betterlist}
		\item \underline{keywords:} Rob Pike, Static type system, Higher-order functions, Garbage collection, Object orientation through type interface (no classes but methods can be attached to types), Support for concurrency and communication (Lightweight threads, Communication through channels with formal foundations: Communicating Sequential Processes, Philosophy: \enquote{Do not communicate by sharing memory. Instead, share by communicating})
	\end{betterlist}
	\fbox{Execution}
	\begin{betterlist}
		\item \verb|go run hello.go| (compile and run), \verb|go build hello.go| (compile separately), \href{https://golang.org/}{Website}
		\item \alert{\enquote{pretty printer}:} \verb|gofmt hello.go| (outputs to console), \verb|gofmt -w hello.go| (writes to same file)
	\end{betterlist}
	\fbox{Syntax}
	\begin{betterlist}
		\item package corresponds to modules in other packages
		\item one statement per line, Semicolons are redundant
		\item \verb|var x int|, \verb|var varName varType|
		\item  \verb|go expression| starts a new thread to run \verb|expression|. \verb|expression| must be a function call or a method call; it cannot be parenthesized. The new thread executes concurrently to the following statements. Threads may run interleaved or on different CPUs (managed by the run-time system). As soon as the main thread terminates, all threads started by the main thread are terminated. Go calls threads \alert{goroutines}, other languages use \verb|fork| or \verb|spawn| instead of go
		\item the \verb|=| operator is used for assignment to already declared variables, while \verb|:=| is used for declaring and initializing a new variable
	\end{betterlist}
	\fbox{Terminology} \href{https://wiki.haskell.org/Parallelism_vs._Concurrency}{\inlinebox{Source}} \href{https://go.dev/tour/concurrency/11}{\inlinebox{Source 2}}
	\begin{betterlist}
		\item \underline{Concurrency versus Parallelism}
		\begin{betterlist}
			\item \alert{Parallelism:} Make programs run faster by making use of additional CPUs (parallel hardware)
			\item \alert{Concurrency:} Program organized into multiple threads of control. Threads may work independently or work on a common task.
		\end{betterlist}
		\item \alert{Thread:} independently sequentially executing code
		\item \underline{Thread state:}
		\begin{betterlist}
			\item Running (currently executing)
			\item Waiting (ready to execute, but no CPU is available)
			\item Blocked (waiting for thread-external condition)
		\end{betterlist}
		\item \alert{Multithreading:} Alternating execution of multiple threads on one CPU
		\item \alert{Scheduling:} Strategy to switch between running and waiting threads
		\begin{betterlist}
			\item \alert{Preemptive scheduling:} Every thread gets a certain slice of time to run, then it is preempted and a waiting thread is selected to run
			\item \alert{Cooperative scheduling:} A thread runs until a blocking command is encountered, then a waiting thread is selected to run
		\end{betterlist}
	\end{betterlist}
	\fbox{Multi-threading}
	\begin{betterlist}
		\item \underline{Blocking commands:}
		\begin{betterlist}
			\item Making the thread sleep (delay/sleep)
			\item Receiving from a channel (potentially blocking as the channel may be \enquote{empty})
			\item Sending on a channel (potentially blocking as a channel may be \enquote{full})
		\end{betterlist}
		\item \underline{State-based execution:}
		\begin{betterlist}
			\item Notation similar to the execution of UPPAAL/communicating automata. The program state consists of the states of individual threads. For example: \verb|(Main.Running, A.Waiting, B.Waiting)|. Creation of a thread (via the go keyword) adds a new thread, initially in wait-state
			\item a \alert{path of execution} is described by a sequence of individual program states. The transition between the current and the next states is indicated with \verb|-->|. E.g. \verb|Main.Running --> (Main.Running, A.Waiting)|
			\item \script{5}{Example}, path of execution at the bottom
		\end{betterlist}
	\end{betterlist}
	\fbox{Lambda's (anonymous functions)}

	\adjustbox{scale=0.5}{
		% https://github.com/cmhughes/latexindent.pl/issues/132
		% \begin{noindent}
    \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}]
      go func() {
        // content
      }()
      bFunc := func() {
        // content
      }
      go bFunc()
    \end{dnumberedcodebox}
    %\end{noindent}
	}
	\begin{betterlist}
		\item \script{9}{Example}
	\end{betterlist}

	\fbox{Channels}
	\begin{betterlist}
		\item Threads can communicate using channels, which is a datatype
		\item \alert{message:} a value sent or received over a channel
		\item channel can be \alert{unbuffered} or \alert{buffered}. A buffered channel can hold a finite number of messages in its buffer
		\item \underline{principles holding:}
		\begin{enumerate}
			\item a thread can send and receive messages on any channel it holds.
			\item a message can be received by exactly one thread.
			\item a recipient must necessarily wait for a message, unless a buffered message is available
			\item a sender can continue, as long as the channel still has a buffer available. If the buffer is full (or the channel is unbuffered), the sender is blocked until a message is received from the channel.
		\end{enumerate}
		\item \alert{typed channels:} \verb|var ch chan int|
		\begin{betterlist}
			\item \verb|var ch chan int| attaches a closed channel to ch on which no operations can be executed
		\end{betterlist}
		\item \alert{creation:} \verb|ch = make(chan int)|
		\item \alert{with/without buffer:} \verb|ch1 = make(chan int)| (unbuffered), \verb|ch2 = make(chan int, 50)| (buffered)
		\begin{betterlist}
			\item a buffer is a queue of messages
			\item \underline{rules for exchanging messages:}
			\begin{betterlist}
				\item channel without buffer (synchronous communication, synchronous channel):
				\begin{betterlist}
					\item sender blocks if no recipient is available
					\item recipient blocks if no sender is available
					\item direct (synchronous) communication between sender and recipient
					\item sender passes message to recipient
					% \item recipient blocks until there is a sender.
					% \item Similarly for the sender (as there is no buffer available)
				\end{betterlist}
				\item channel with buffer (asynchronous communication, asynchronous channel):
				\begin{betterlist}
					\item sender blocks if buffer is full
					\item recipient blocks if buffer is empty
					\item indirect (asynchronous) communication between sender and recipient
					\item sender puts message in buffer, recipient takes message from buf
					\item the buffer is organized as a queue (FIFO)
					% \item recipient blocks if there is no message available in the buffer
					% \item sender blocks only if the buffer is full
				\end{betterlist}
			\end{betterlist}
			% \item \underline{difference as follows:}
			%   \begin{betterlist}
			%     \item for an unbuffered channel, a sender always has to \alert{synchronize} with a recipient. Sender and recipient always block. The Go runtime system checks if there are blocking sender and recipient for the same channel. If so, they communicate with each other and become unblocked
			%     \item for a buffered channel, the sender behaves \alert{asynchronously} and tries to write the message to the buffer. The sender only blocks if the buffer is full, then it tries again. The recipient always synchronizes with the buffer. If the buffer is empty, the recipient blocks. Otherwise, a message is taken from the buffer
			%   \end{betterlist}
			\item both modes of communication are equivalent. That is, a channel with buffer can be emulated by channels without buffers
			\item \alert{Send value \texttt{y} on channel \texttt{ch}:} \verb|ch <- y|
			\item \alert{Receive from channel \texttt{ch} and save the value in \texttt{x}:} \verb|x = <- ch|
			\begin{betterlist}
				\item an expression, i.e., \verb|<-| is a unary operator on channels
				\item \script{13}{Example}
			\end{betterlist}
			\item \alert{Restricted communication:}
			\begin{betterlist}
				\item channel types can be annotated
				\item \alert{only sending:} \verb|func snd(ch chan <- int) {}|
				\item \alert{only receiving:} \verb|func rcv(ch <- chan int) {}|
			\end{betterlist}
		\end{betterlist}
		\item \script{18}{Example}
	\end{betterlist}
	\fbox{Mutex} \script{20}{Exercise Slides} \exercisenotes{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/slides/bonus/2024_04_19_tutorial_1.md}
	\begin{betterlist}
		\item \solution{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/solutions/lec-01-exercises/01a.MutexWithBuffer.go}{1a}, \solution{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/solutions/lec-01-exercises/01b.MutexWithoutBuffer.go}{1b}

		\adjustbox{scale=0.5}{
			% \begin{noindent}
    \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
        type Mutex (chan int)

        func newMutex() Mutex {
          var ch = make(chan int, 1)
          return ch
        }

        func lock(m Mutex) {
          m <- 1
        }

        func unlock(m Mutex) {
          <- m
        }
    \end{dnumberedcodebox}
    %\end{noindent}
		}
		\adjustbox{scale=0.5}{
			% \begin{noindent}
    \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
      type Mutex (chan int)
      
      func mutex(ch chan int) {
        for {
          <- ch
          ch <- 1
        }
      }
      
      func newMutex() Mutex {
        var ch = make(chan int) 
        go mutex(ch)
        return ch
      }
      
      func lock(m Mutex) {
        m <- 1
      }
      
      func unlock(m Mutex) {
        <- m
      }
    \end{dnumberedcodebox}
    %\end{noindent}
		}
	\end{betterlist}
	\fbox{Mutable Variable} \script{21}{Exercise Slides}
	\begin{betterlist}
		\item \solution{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/solutions/lec-01-exercises/02a.MVarWithBuffer.go}{2a}, \solution{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/solutions/lec-01-exercises/02b.MVarWithoutBufferNoAnswers.go}{2b}, \solution{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/solutions/lec-01-exercises/02c.MVarWithoutBuffer.go}{2c}

		\adjustbox{scale=0.5}{
			% \begin{noindent}
    \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
      type MVar (chan int)
      
      func newMVar(x int) MVar {
        var ch = make(chan int, 1)
        ch <- x
        return ch
      }
      
      func takeMVar(m MVar) int {
        var x int
        x = <- m
        return x
      }
      
      func putMVar(m MVar, x int) {
        m <- x
      }
    \end{dnumberedcodebox}
    %\end{noindent}
		}
		\adjustbox{scale=0.5}{
			% \begin{noindent}
    \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
      type MVar (chan int)

      func newMVar(x int) MVar {
        var ch = make(chan int)
        go func() {
          for {
            ch <- x
            x = <- ch
          }
        }()
        return ch
      }

      func takeMVar(m MVar) int {
        var x int
        x = <- m
        return x
      }

      func putMVar(m MVar, x int) {
        go func() { m <- x }()
      }
    \end{dnumberedcodebox}
    %\end{noindent}
		}
	\end{betterlist}
\end{minipage}
\begin{minipage}[t]{0.2\linewidth}
	\fbox{Channels of Channels} \script{23}{Lecture Slides} \lecturenotes{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/slides/bonus/2024_04_24_lecture_1.md}
	\begin{betterlist}
		\item \verb|var ch chan (chan int)|. A channel that accepts channels of integers

		\adjustbox{scale=0.5}{
			% \begin{noindent}
    \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
    type Request struct {
        id  int
        ack chan int
    }

    func worker(req chan Request) {
        var c Request
        for {
            c = <-req
            fmt.Printf("received from %d \n", c.id)
            time.Sleep(1 * 1e9)
            c.ack <- 1
        }
    }

    func client(id int, req chan Request) {
        var ack = make(chan int)
        for {
            c := Request{id, ack}
            req <- c
            <-ack
        }

    }

    func main() {
        var req = make(chan Request)
        go worker(req)
        go client(1, req)
        client(2, req)
    }
    \end{dnumberedcodebox}
    %\end{noindent}
		}
		\item \script{25}{Example: Worker and Client} and  \script{26}{Example: Sleeping barber}
	\end{betterlist}
	\fbox{Non-deterministic Choice (\texttt{select})}
	\begin{betterlist}
		\item one wants to continue, as soon as one of the events occurs. The \verb|select| primitive allows simultaneous waiting for multiple events

		\adjustbox{scale=0.5}{
			% \begin{noindent}
      \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
      select {
        case x = <-ch1:
            ...
        case y = <-ch2:
            ...
        case ch3 <- 1:
            ...
      }
      \end{dnumberedcodebox}
    %\end{noindent}   }
		}
		\item \underline{select works as follows:}
		\begin{betterlist}
			\item select blocks if all events (cases) block
			\item if one event (case) occurs, the corresponding case is chosen
			\item if multiple events (cases) occur, one corresponding case is chosen randomly
			\item the remaining cases are no longer available!
		\end{betterlist}
		\item events that were not chosen remain available. The order of cases does not matter. The choice is random and almost equally distributed.
		\item \script{32}{Example: \enquote{Random} Choice}, \script{34}{Example: Selection is \enquote{Fair}}, \script{35}{Example: Attempt at emulating select in Newsreader} and \script{39}{Example: Execution of multiple tasks}
		\item \underline{Selection with prioritization:} put the case that should be priotised several times
		\item \underline{\texttt{default}:}

		\adjustbox{scale=0.5}{
			% \begin{noindent}
      \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
        select {
          case <-ch1:
          case ch2<-1:
          default:
        }
      \end{dnumberedcodebox}
    %\end{noindent}   }
		}
		\begin{betterlist}
			\item If none of the cases occurs, select blocks. It is also possible to prevent blocking using \texttt{default}
			\item If none of the first two cases occurs, then the third (\texttt{default}) case is selected
		\end{betterlist}
		\item \underline{\texttt{timeout}:}

		\adjustbox{scale=0.5}{
			% \begin{noindent}
        \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
        timeout := time.After(4 * 1e9)
        select {
          case <-ch:
          case <-timeout:
            fmt.Println("timed out")
          return
        }
        \end{dnumberedcodebox}
      %\end{noindent}   }
		}
		\item \underline{\alert{Berrier} pattern:}
		\begin{betterlist}
			\item multiple tasks will be executed simultaneously. The program will continue as soon as all tasks are done. Effectively a \alert{counting semaphore} is modeled
		\end{betterlist}
		\adjustbox{scale=0.5}{
			% \begin{noindent}
          \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
          func barrier() {
            var ch = make(chan int)
            // run all three tasks concurrently
            go func() {
                task1()
                ch <- 1 // signal done
            }()
            go func() {
                task2()
                ch <- 1
            }()
            go func() {
                task3()
                ch <- 1
            }()

            // collect results concurrently
            timeout := time.After(4 * 1e9)
            for i := 0; i < 3; i++ {
                select {
                  case <-ch:
                  case <-timeout:
                      fmt.Println("timed out")
                      return
                }

            }
            fmt.Println("done")
          }

          \end{dnumberedcodebox}
        %\end{noindent}   }
		}
	\end{betterlist}
	\fbox{Where it can all go wrong} \exercisenotes{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/slides/bonus/2024_05_03_tutorial_1.md}
	\begin{betterlist}
		\item \alert{trace:} is a sequence of events and expresses the interleaved execution of individual threads
		\begin{betterlist}
			\item \uline{\alert{trace-based description of program execution} is related to the \alert{state-based execution}:} both notations/concepts have the goal to describe (concurrent) program execution. The relationship between the two is somewhat like regular expressions versus finite machines
		\end{betterlist}

		\item \alert{Deadlock:} Occurs when all threads are blocked. Go runtime system recognizes such a situation and aborts
		\begin{betterlist}
			\item \verb|pre(ch?)|: wanting to receive on channel \verb|ch|
			% \begin{betterlist}
			%   \item \verb|pre| describes the event before the corresponding operation takes place
			% \end{betterlist}
			\item \verb|post(ch?)|: having received on channel \verb|ch|
			% \begin{betterlist}
			%   \item \verb|post| describes the event after the corresponding operation has taken place
			% \end{betterlist}
			\item \verb|pre(ch!)|: wanting to send on channel \verb|ch|
			\item \verb|post(ch!)|: having sent on channel \verb|ch|
			\item in case of communication (send-receive), we assume that in the trace the post event of the send always occurs before the post event of the receive
			\item \script{45}{Examples for deadlock and no deadlock}, code found at a previous page
		\end{betterlist}
		\item \alert{Starvation:}
		\begin{betterlist}
			\item \script{48}{Example} where Main starves (does not progress), because S and R always communicate with each other. Such a situation is considered starvation
		\end{betterlist}
		\item \alert{Livelock:} Describes a situation in which always at least one thread is not blocked, but no thread progresses. A livelock does not occur in \script{48}{Example}
		\item \alert{Data race:} Situation in which two unprotected, conflicting memory operations (at least one write) occur simultaneously
		\begin{betterlist}
			\item one writes \verb|w(x)| to denote a write event on variable \verb|x|, and \verb|r(x)| for a read event. One does not distinguish pre and post events; all events are post events. Ones simplifies the operation \verb|x++| to \verb|w(x)| (is reading and then writing but that much detail not interesting)
			\item in a program execution (represented as trace), a data race occurs when two conflicting write/read events occur directly after one another:

			\adjustbox{scale=0.5}{
				% \begin{noindent}
            \begin{dnumberedcodebox}[minted language=text,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top, title=data race visible]
                 Main        T
            1.               y!
            2.               w(x)
            3.   w(x)
            \end{dnumberedcodebox}
          %\end{noindent}   }
			}
			\adjustbox{scale=0.5}{
				% \begin{noindent}
            \begin{dnumberedcodebox}[minted language=text,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top, title=data race not visible]
                 Main        T
            1.               y!
            2.               w(x)
            3.               y?
            4.   w(x)
            \end{dnumberedcodebox}
          %\end{noindent}   }
			}
			\item \script{52}{Reordering and data races}
			\item \solution{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/solutions/lec-02-exercisesb/ilias01_answers.pdf}{Ilias Quiz 1}
		\end{betterlist}
	\end{betterlist}
	\fbox{Lists} \script{56}{Exercise Slides} \exercisenotes{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/slides/bonus/2024_04_26_12_16_11.md}

	\adjustbox{scale=0.5}{
		% \begin{noindent}
      \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
        subs := list.New()
        subs.PushBack(s)
        for e := subs.Front(); e != nil; e = e.Next() {
          s := e.Value.(Sub)
          if s.topic == m.topic {
            s.news <- m
          }
        }
      \end{dnumberedcodebox}
    %\end{noindent}   }
	}
	\begin{betterlist}
		\item lists in Go are \alert{heterogeneous}. That is, when one takes an element from the list, one needs to cast its type explicitly
		\item \solution{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/solutions/lec-02-exercises/03.publishSubscribe.go}{3}
	\end{betterlist}
\end{minipage}
\begin{minipage}[t]{0.2\linewidth}
	\fbox{Quantified Semaphor}

	\adjustbox{scale=0.5}{
		% \begin{noindent}
      \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
type QSem struct {
  q              int
  curr           int
  m              Mutex
  blockedWaits   *list.List
  blockedSignals *list.List
}

func newQSem(q int) QSem {
  var m = newMutex()
  qsem := QSem{q, q, m, list.New(), list.New()}
  return qsem
}

// down
func wait(qsem *QSem) {
  lock(qsem.m)
  if qsem.curr > 0 {
    if qsem.blockedSignals.Len() > 0 {
      var s = qsem.blockedSignals.Front()
      qsem.blockedSignals.Remove(s)
      unlock(qsem.m)
      lock(s.Value.(Mutex))
    } else {
      qsem.curr--
      unlock(qsem.m)
    }
  } else {
    var w = newMutex()
    qsem.blockedWaits.PushBack(w)
    unlock(qsem.m)
    unlock(w) 
  }
}

// up
func signal(qsem *QSem) {
  lock(qsem.m)
  if qsem.curr < qsem.q {
    if qsem.blockedWaits.Len() > 0 {
      var w = qsem.blockedWaits.Front()
      qsem.blockedWaits.Remove(w)
      unlock(qsem.m)
      lock(w.Value.(Mutex))
    } else {
      qsem.curr++
      unlock(qsem.m)
    }
  } else {
    var s = newMutex()
    qsem.blockedSignals.PushBack(s)
    unlock(qsem.m)
    unlock(s)
  }
}
      \end{dnumberedcodebox}
    %\end{noindent}
	}
	\adjustbox{scale=0.5}{
		% \begin{noindent}
      \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
type QSem struct {
  q              int
  curr           int
  m              Mutex
  signalWaits    Mutex
  signalSignals  Mutex
  noBlockedWaits int
  noBlockedSignals int
}

func newQSem(q int) QSem {
  var m = newMutex()
  qsem := QSem{q, q, m, newMutex(), newMutex(), 
               0, 0}
  return qsem
}

// down
func wait(qsem *QSem) {
  lock(qsem.m)
  if qsem.curr > 0 {
    if qsem.noBlockedSignals > 0 {
      qsem.noBlockedSignals--
      unlock(qsem.m)
      lock(qsem.signalSignals)
    } else {
      qsem.curr--
      unlock(qsem.m)
    }
  } else {
    qsem.noBlockedWaits++
    unlock(qsem.m)
    unlock(qsem.signalWaits)
  }
}

// up
func signal(qsem *QSem) {
  lock(qsem.m)
  if qsem.curr < qsem.q {
    if qsem.noBlockedWaits > 0 {
      qsem.noBlockedWaits--
      unlock(qsem.m)
      lock(qsem.signalWaits)
    } else {
      qsem.curr++
      unlock(qsem.m)
    }
  } else {
    qsem.noBlockedSignals++
    unlock(qsem.m)
    unlock(qsem.signalSignals)
  }
}
      \end{dnumberedcodebox}
    %\end{noindent}   }
	}
	\begin{betterlist}
		\item \solution{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/solutions/lec-02-exercises/04.qsem1.go}{4.1}, \solution{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/solutions/lec-02-exercises/04.qsem2.go}{4.2}
		\item mechanism with queues unnecessary, because in go blocked senders and recipients on channels are ordered and unblocked in order. Implementation does not need to keep track of which thread exactly is waiting, because we already know that threats themselves already know they're waiting. All we need to track is that there are threads waiting. Instead of using lists of mutual exclusions to indicate unblocking, one simply uses a single mutex for unblocking waits ans signals and keep track how many are waiting. lock on mutual exclusion, meaning that the first signal that called unlock will be unlocked and be done
	\end{betterlist}
	\fbox{Examples for Deadlocks, Livelocks and Starvation via Traces}
	\begin{betterlist}
		\item \solution{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/solutions/lec-02-exercises/05.sleepingBarber2.go}{5}, \solution{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/solutions/lec-02-exercises/06.diningPhilosophers.md}{6}

		\adjustbox{scale=0.5}{
			% \begin{noindent}
          \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
                  import (
                    "time"
                    "math/rand"
                  )
                  n := rand.Intn(4)
                  time.Sleep(time.Duration(n) * time.Second)
                  time.Sleep(100 * time.Millisecond)
          \end{dnumberedcodebox}
        %\end{noindent}   }
		}
	\end{betterlist}
	\fbox{Priorisation}

	\adjustbox{scale=0.5}{
		% \begin{noindent}
        \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
          select {
            case <-deer:
              numOfDeerSeen++
            case <-elves:
              numOfElvesSeen++
              select {
                case <-deer:
                  numOfDeerSeen++
                default:
              }
          }
        \end{dnumberedcodebox}
      %\end{noindent}   }
	}
	\adjustbox{scale=0.5}{
		% \begin{noindent}
        \begin{dnumberedcodebox}[minted language=go,minted options={autogobble, fontsize=\tiny,numbersep=0.3cm,linenos}, box align=top]
          select {
            case <-deer:
              numOfDeerSeen++
            case <-elves:
              select {
              case <-deer:
                numOfDeerSeen++
                go func() { elves <- 1 }()
              default:
                numOfElvesSeen++
              }
            }
        \end{dnumberedcodebox}
      %\end{noindent}   }
	}
	\begin{betterlist}
		\item \solution{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/solutions/lec-02-exercisesb/07.SantaClaus.go}{7}
		\item Santa gives priority to the reindeer in the case that there is both a group of elves and a group of reindeer waiting.
	\end{betterlist}
  \fbox{Dynamic data race prediction} \script{74}{Lecture Slides} \lecturenotes{/home/areo/Documents/Studium/Semester_2_Master/Concurrency/slides/bonus/2024_05_08_16_12_53.md}
	\begin{betterlist}
		\item \alert{Dynamic analysis}: Execute the program and observe its behavior, Determine if there is any potential bad behavior based on this specific program run
		\item \alert{Static analysis}: Predict all possible program runs without actually executing the program, (usually) sound, \underline{but overapproximative:} if there is a bug, it will be flagged, but also non-bug may be flagged
		\item events are collected in a program \alert{trace}. A trace is a linear sequence of events and represents an interleaved execution of the program
		\begin{betterlist}
			\item there is a \alert{tabular notation} for traces with a separate \alert{column} for each \alert{thread} and separate \alert{row} for each \alert{event}. The trace \alert{position} of an event corresponds to the row number
		\end{betterlist}
		\item an \alert{event} registers interesting program behavior. Each event is connected to one of the operations we are interested in
		\begin{betterlist}
			\item for each event, the trace records the \alert{thread} where the event happened. Each event can be identified by its position in the trace
			\item two events are \alert{conflicting events} if they are read/write events for the same variable that come from different threads and at least one of them is a write event
			% \begin{betterlist}
			%   \item \underline{in other words:} two read/write operations on some shared variable are \alert{conflicting} if the operations happen in different threads and at least one of the operations is a write
			% \end{betterlist}
			\item a \alert{data race} arises if two conflicting events appear right next to each other in the trace. That implies that both events may happen in any order
		\end{betterlist}
		\item \script{80}{Example}
		\item instead of rerunning the program to obtain other traces, another method is to consider \alert{valid trace reorderings} that result from a trace. Reordering of a trace means that we change the order of its events such that the resulting sequence of events still represents a sensible execution sequence. \underline{Motivation}: Rerunning a program over and over again to encounter a trace that detects a data race is very time consuming. \underline{Conditions for a valid trace reordering}:
		\begin{betterlist}
			\item The elements in the reordered trace must be part of the original trace
			\begin{betterlist}
				\item A valid reordering only needs to include a subset of the events of the original trace
			\end{betterlist}

			\item \alert{Program order must be maintained}:
			\begin{betterlist}
				\item \underline{the \alert{Program order Condition} states}: Let $P$ be some trace and $P'$ be a permutation of $P$. $P'$ preserves program order if, for each thread $T$, $P \downarrow T = P' \downarrow T$
				\begin{betterlist}
					\item \underline{notation}: for a trace $P$ and thread $T$, we write $P \downarrow T$ for the list of events in thread $T$ contained in $P$
				\end{betterlist}
				\item \script{85}{Example}
			\end{betterlist}
			\item \alert{Lock semantics must be maintained}:
			\begin{betterlist}
				\item \underline{the \alert{Lock Semantics Condition} states:} Let $P$ be some trace and $P'$ be some reordering of $P$. If $𝑃' = P_1 acq(y) P_2 acq(y) P_3$, then there must be some event $rel(y)$ in $P_2$. If $P' = P_1 rel(y) P_2$, then there must be some $acq(y)$ such that $P_1 = P'_1 acq(y) P''_1$ and there is no $rel(y)$ in $𝑃''_1$
				\item \script{87}{Example}
			\end{betterlist}
			\item \alert{Last writer must be maintained}:
			\begin{betterlist}
				\item \underline{the \alert{Last Writer Condition} states}: Let $P$ be some trace with a read event $r(x)$ and $P'$ be some reordering of $P$. The event $r(x)$ must have the same \alert{last writer} in $P'$ as in $P$
				\begin{betterlist}
					\item If $P_1 r(𝑥) P_2$ is a trace, then the \alert{last writer} of $r(x)$ is some $w(x)$ such that $P_1 = P_1' w(x) P_1^{''}$ and $P_1^{''}$ does not contain another $w(x)$
				\end{betterlist}

				\item \script{89}{Example}
			\end{betterlist}
			\item \script{99}{Example}
			\item \script{100}{Summary in other words}
		\end{betterlist}
		\item \alert{dynamic data race prediction}: we record the trace of a specific program run. Two conflicting events may not appear in the trace right next to each other. However, we may be able to predict that there is some trace reordering under which the two conflicting events appear right next to each other (in the reordered trace)
		\begin{betterlist}
			% \item to identify conflicting events that are in a race, we could check if there is a valid reordering of the trace under which both events occur right next to each other
			% Exhaustive predictive methods attempt to identify as many reorderings as possible. 
			\item a \enquote{simple} data race prediction method seems to compute all possible (valid) reorderings and checks if they contain any data race. Such exhaustive methods do not scale to real-world settings because program runs and the resulting traces may be large and considering all possible reorderings generally leads to an exponential blow up. As we favor efficiency (by efficient we mean a run-time that is linear in the size of the trace) over exhaustiveness, we may compromise \alert{completeness} and \alert{soundness}:
			\begin{betterlist}
				\item \alert{Complete} means that all valid reorderings that exhibit some race can be predicted. If a method is incomplete, we call every race that is not reported race a \alert{false negative}
				\item \alert{Sound} means that all races reported by the method can be exhibited with some valid reordering of the trace. If a method is unsound, it may report a trace as racy even if there is no valid reordering that exhibits a race. Such a report is a \alert{false positive}
			\end{betterlist}
		\end{betterlist}
	\end{betterlist}
	\fbox{Efficient dynamic data race prediction methods}
	\begin{betterlist}
		\item Lamport's \alert{happens-before (HB, incomplete) relation}:
		\begin{betterlist}
			\item Efficient methods approximate by only considering certain reorderings. Instead of explicitly constructing a reordering, we calculate a happens before relation%, it approximates the possible reorderings. The HB relation can be computed efficiently but may lead to false positives and false negatives
			\item \alert{a partial order} on events to determine if one event happens before another event. If events are unordered, we assume that these events may happen concurrently (i.e., in any order). \uline{Ground truth:} the \alert{must happen before relation (mhb)}
			\item any \alert{happens-before (partial) order} (HB relation) approximates the must happen before relation (the possible reorderings)
			\begin{betterlist}
				\item if the order is \alert{too large}, it orders events that may not be ordered by mhb: it misses data races and may yield false negatives
				\item if the order is \alert{too small}, it does not order events that may be ordered by mhb: it hallucinates data races and may thus yield false positives
			\end{betterlist}
			\item \alert{Vector clocks}: A distributed time stamp, A representation for a happens-before relation
			\item if two conflicting operations are unordered under the happens-before relation, then we report that these operations are in a (data) race
			% \item in practice, the entire trace does not need to be present as events can be processed \alert{online} in a stream-based fashion. A more detailed \alert{offline} analysis may get better results if the full trace is available
		\end{betterlist}
	\end{betterlist}
\end{minipage}
\begin{minipage}[t]{0.2\linewidth}
	\begin{betterlist}
		\item Lamport's \alert{happens-before (HB, incomplete) relation} continue:
		\begin{betterlist}
			\item Let $T$ be a trace. We define the HB relation $<$ as the smallest strict partial order that satisfies the following conditions:
			\begin{betterlist}
				\item \alert{Program order:} If $t\#e_i$, $t\#f_{i + n} \in T$ for some $n > 0$, then $t\#e_i < t\#f_{i + n}$
				\begin{betterlist}
					\item \alert{Trace and event notation}: We write $t\#e_i$ to denote event $e$ at trace position $i$ in thread $t$. \script{98}{Example}
				\end{betterlist}
				\item \alert{Critical section order:} If $t_1\#rel(x)_k, t_2\#acq(x)_{k + n} \in T$ with $t_1 \ne t_2$ and $n > 0$, then $t_1\#rel(x)_k < t_2\#acq(x)_{k + n}$
				\item \script{102}{Additional rephrasing of above conditions and example}
			\end{betterlist}
			\item \alert{Happens-before data race check:} If there are conflicting events $e$ and $f$ but neither $e < f$ nor $f < e$ , then $(e, f)$ is a HB data race pair
			\begin{betterlist}
				\item the argument is that if neither $e < f$ nor $f < e$ we are able to reorder the trace such that $e$ and $f$ appear right next to each other (in some reordered trace)
				\item \underline{note}: if $(e, f)$ is a HB data race pair then so is $(f, e)$. In such a situation, we consider $(e, f)$ and $(f, e)$ as two distinct representative for the same data race. When reporting (and counting) HB data races we only consider a specific representative
			\end{betterlist}
			\item \alert{Event set $ES_e$}: set of events that happen up-to and including event $e$. That is, $ES_e = \{ f ∣ f < e \} \cup \{e\}$
			\begin{betterlist}
				\item \underline{Observations:} To enforce the critical section order we add the event set $ES_{rel(y)}$ of some release event to the event set $ES_{acq}(y)$ of some subsequent acquire event, To enforce the program order, we accumulate events within one thread (in essence, building the transitive closure)
				\item to decide if $e < f$ we can check for $ES_{e} \subset ES_{f}$. Consider two conflicting events $e$ and $f$ where $e$ appears before $f$ in the trace. To decide if $e$ and $f$ are in a race, we check for $e \in ES_f$ or $f \in ES_e$. If yes, then there is no race (because $e < f$ or $f < e$). Otherwise, there is a race.
				\item \script{104}{Example}
				\item \alert{Set-based race predictor:}
				\begin{betterlist}
					\item we compute event sets by processing the events in the trace from beginning to end. We maintain the following state variables when processing event $e_i$: \script{105}{Overview}
					\item each event invokes its processing function: \script{106}{Overview}. We write $e@operation$ for the processing function for event $e$ of the form $operation$. We add thread information as an additional argument
				\end{betterlist}
			\end{betterlist}
      \item \script{107}{Example}
		\end{betterlist}
		\item \alert{Lockset (unsound)}:
	\end{betterlist}
\end{minipage}
\begin{minipage}[t]{0.2\linewidth}
\end{minipage}

\newpage

\begin{minipage}[t]{0.2\linewidth}
	\fbox{Tricks}
	\begin{betterlist}
		\item immer bis zu einer Stelle wo es nicht mehr weitergeht ausführen und dann threads ansehen wo blockierender Channel drin steht
	\end{betterlist}
\end{minipage}
\begin{minipage}[t]{0.2\linewidth}
\end{minipage}
\begin{minipage}[t]{0.2\linewidth}
\end{minipage}
\begin{minipage}[t]{0.2\linewidth}
\end{minipage}
\begin{minipage}[t]{0.2\linewidth}
\end{minipage}
\end{document}
