\documentclass{standalone}

\input{./content/packages}
\input{./content/desgin}
\input{./content/declarations}

\begin{document}
\begin{mindmap}
	\begin{mindmapcontent}
		\node (middle) at (current page.center) {Cyber Physical Systems
			\resizebox{\textwidth}{!}{
				\begin{minipage}[t]{30cm}
					\begin{itemize}
						\item \alert{Definition:} Networked computational resources interacting with physical systems
						\begin{itemize}
							\item \script{41}{Examples}
							\item \script{42}{Comparison with Embedded Systems (ff.)}
							\item \script{46}{Problems}
						\end{itemize}
					\end{itemize}
				\end{minipage}
			}
		}
		child {
				node {Model Checking
						\resizebox{\textwidth}{!}{
							\begin{minipage}[t]{20cm}
								\begin{itemize}
									\item a formal verification technique which allows for desired behavioral properties of a given system to be verified on the basis of a suitable model of the system through systematic inspection of all states of the model
									\begin{itemize}
										\item \alert{Model:} Model is an abstract, formal, mathematical representation or description of structure or behaviour of a (software) system that abstracts from the datails of a system that are not relevant for the system % Mathemticaly precise abstraction from the datails of a system that are not relevant for the system
									\end{itemize}
									\item \script{125}{Model checking schema (ff.)}
									\begin{itemize}
										\item we have a cyber physical system for which we want to find some kind of model and in the end that model will be translated to a transition system and on the other side we have some requirements something that we want to our cyber physical system to satisfy and we translate that to a formal specification and then the task of a model Checker is to check if the transition system satisfies the specification
										\item our goal is to verify a cyberphysical system which means that we want to check that a certain property holds about the behavior of the physical system so we're interested in behavioral properties and for this we need a mathematical model of this cyber physical system and we need a formalization of the requirements and our formal method our formal model will be what we call a transition system
										\item an important aspect of a cyber physic system is that it is composed of many components some of which are physical some are computer and there is this important aspect of concurrency of synchronization of distribution and of communication and so there are various ways to express the communication between the different models and depending on that we will construct a transition system but the goal is always that you translate you give a mathematical model for each component of the cop physical system and then given the specific communication mechanism you will construct a mathematical model for the overall system okay
									\end{itemize}
								\end{itemize}
							\end{minipage}
						}
					}
				child {
						node {Linear-time properties (LT properties)
								\resizebox{\textwidth}{!}{
									\begin{minipage}[t]{16cm}
										\begin{itemize}
											\item \script{577}{Definition}, LT property so is set of traces (language of all traces allowed in the system),infinite words are infinite sequences of sets of atomic propositions that are traces, because we have this assumption that everything is infinite E is then a subset of the power set of AP to the Omega
											\begin{itemize}
												\item \videonine{4515}{Short: What is linear time property}
											\end{itemize}
											\item \script{577}{Example: Mutex (ff.)}, often do some sort of quantification over the natural numbers i (index) and can think of this as we say something about \alert{all points of time} because the trace the sequence models the flow of time we start with the labeling of the initial state and then as the transition system makes steps we get new sets of atomic propositions that describe how the system develops over time. An equivalent way would be to say there does not exist a point of time where both are in the critical section. An atomic proposition can be element or not but it cannot be equal $A_i$, we look at the atomic propositions and LT properties completely separately from the transition system right we have just fixed the set of atomic propositions and I mean our implementation may satisfy something like it's never case that wait crit1 crit2 hold at the same time but when we're specifying the property we don't think about these kinds of things, $\emptyset\{wait _1, crit_1\} \not\in MUTEX$ also possible, even though it makes no sense
											\item \script{587}{Satisfaction relation (f.)}: The transition system satisfies the property if and only if every initial state of the transition system satisfies the property%, this is what a model checker checks in the end, a test case only tests one, here it is all possible infinetely many traces
											\begin{itemize}
												\item \script{589}{Same for individual states}: All the traces that start in this state if this set is a subset of e then the state satisfies the LT property
											\end{itemize}
											\item \alert{linear time} just means that we define the property as a set of sequences and so sequences are linearly ordered as opposed to a tree
										\end{itemize}
									\end{minipage}
								}
							}
						child {
								node {Trace relations
										\resizebox{\textwidth}{!}{
											\begin{minipage}[t]{12cm}
												\begin{itemize}
													\item \script{689}{Comparison}
												\end{itemize}
											\end{minipage}
										}
									}
								child {
										node {Trace equivalence
												\resizebox{\textwidth}{!}{
													\begin{minipage}[t]{12cm}
														\begin{itemize}
															\item \script{688}{Definition}
															\item \script{693}{Example:  Beverage machines (f.)}, want property e that says that when this is T1 and this is T2 I want the property that says T1 is correct because T1 satisfies the property and T2 is not correct because it does not satisfy the property and the thing is such a property does not exist, I need to describe my system in terms of linear sequences because my linear time properties are traces are sets of sequences, one way to get out of it would to say okay so I extend my set of atomic propositions and this would allow me to distinguish between this these states here but it's not really a solution because this seems like implementation details right I mean the user does not care about the internal state of my machine the user cares about can I insert a coin can I take my beverage, because they are Trace equivalent according to the theorem that we have just proven we know that they satisfy the same properties and so there is no property that can be used to distinguish this system from this system by saying that this system does not satisfy the property and this system satisfies it
															\item \script{698}{Example: Yellow and Blue}, you cannot have two without having a third yellow ($\{a,b\}\{a,b\}\{a\}\not\in Traces(T_2)$)
														\end{itemize}
													\end{minipage}
												}
											}
									}
								child {
										node {Trace inclusion
												\resizebox{\textwidth}{!}{
													\begin{minipage}[t]{12cm}
														\begin{itemize}
															\item \script{650}{Definition}: $Traces(T_1)\subseteq Traces(T_2)\wedge T_2\models E \Rightarrow T_1\models E$, inclusion between sets is a \alert{transitive} relation
															\item Let $T_1$ and $T_2$ be transition systems over $AP$. Then, the following statements are equivalent:
															\begin{itemize}
																\item $Traces(T_1) \subseteq Traces(T_2)$
																\item for all LT-properties $E$ over $AP$: whenever $T_2 \models E$ then $T_1 \models E$
																\item \script{654}{Proof}, 2: the smallest property $E$ that satisfies $T_2$ is the set of all traces of $T_2$: $Traces(T_2)$, that T1 satisfies e means that the set of all traces of T1 forms a subset of e but e is Traces(T2) so this means that the set of all traces of T1 is a subset of the traces of T2 and this is what we needed to show ($Traces(T_1) \subseteq E = Traces(T_2)$)
															\end{itemize}
														\end{itemize}
													\end{minipage}
												}
											}
										child {
												node {Implementation/refinement relation (Appears naturally as)
														\resizebox{\textwidth}{!}{
															\begin{minipage}[t]{16cm}
																\begin{itemize}
																	\item \script{657}{Definition}, what does refine mean it becomes finer it becomes less abstract so you go to another model and because it is less abstract it has less nondeterminism it has more implementation details and that means that it has less traces. This is something that you can check by just a comparison of the two transition system and since you go from T1 to T2 in a systematic fashion the hope is that the check $T_2 \sqsubseteq T_1$ will be easier and perhaps this check $T_2\models E$ will be difficult but you don't need to do it because it's already implied by $T_1\models E$ and $T_2 \sqsubseteq T_1$
																\end{itemize}
															\end{minipage}
														}
													}
											}
										child {
												node {Resolving nondeterminism (Appears naturally when)
														\resizebox{\textwidth}{!}{
															\begin{minipage}[t]{16cm}
																\begin{itemize}
																	\item \script{666}{Definition}, the consequences of resolving non determinism is that you will have less paths and if you have less paths then you have less traces
																	\item \script{660}{Example (ff.)}, then when you have proven your property about this system here you no longer need to prove it about this system here, it does not even matter what the labeling is of the different states in the transition system because the already for the sets of paths we have this inclusion relation and if we have it for the paths then we also have it for the labelings no matter what the labeling is, for any property e over this given set of atomic propositions and for the set of other positions you can choose any
																\end{itemize}
															\end{minipage}
														}
													}
											}
										child {
												node {Context of abstractions (Appears naturally in)
														\resizebox{\textwidth}{!}{
															\begin{minipage}[t]{18cm}
																\begin{itemize}
																	\item \script{672}{Example (ff.)}, corresponds to a property just like Mutual exclusion except that for Mission exclusion I have crit one and crit two and here I say that I never have at the same time that I am at the location L2 and Y is odd right or one could always say that always L2 is not in a i or odd y is not in a i and this must hold for all positions I, program graph translated to transition system, abstract ts because it's too big, two states are equivalent if we cannot distinguish them with respect to three properties, \alert{equal modul 2} means that the difference between the two is even, we have that X is equal to zero so we don't have non negatives, we don't consider this other case where I'm at L1 and X is greater zero and X is different from Y modul 2 and the reason that we don't consider this is because such a state will not be reachable, this state here no longer says that X is exactly seven and Y is exactly five I lose this information I \alert{abstract away from the concrete values} all I remember is these two things, in the concrete I know that this here will be executed exactly six times and at the seventh time I will be at a state where X is equal to zero and here you can see that this transition here can be executed an arbitrary number of times and what does this mean it means that although the transition system T that is associated to this program graph here does not have any \alert{infinite execution} this one here does right I can stay here forever I can also say that the length of the executions is unbounded in this transition system, for now we only look at a property that is \alert{different from termination} and so this abstraction is fine, location l2 values don't change to it holds before. now when I look at this transition system here it allows me to observe that whenever I'm in location L2 then the difference between X and Y is even and X is equal to 0 and since 0 is an even number Y is also an even number and so I have proven my um property that whenever I have terminated the Y Loop X is even or X is not odd and so you see that here I have nondeterminism in the abstraction whereas in the concrete transition system it is always determined whether I take this edge so whether I execute the Y Loop or whether I jump out of the Y Loop and it's determined by the evaluation of the Guard but when I only know that X is greater than zero then and I decrement X by one then I don't know perhaps if x was strictly greater than one then it will be greater 0 afterwards and so I execute this transition in the transition system but if the value was one then execute this one here but by just looking at this transition system I have \alert{lost this information} I have abstracted it away and so this abstraction introduces nondeterminism so nondeterminism looks like I have more choices but this is the price that I pay for the fact that here I have only four states and here I have many more states okay and so this abstract transition system here if I call it t Prime then it allows me to verify this property because there's only one state where I'm at L2 and I know that then y cannot be odd because it's X is equal to 0 and um X is equal to Y modul 2. we have our \alert{theorem} about the \alert{trace inclusion} we have that the transition system with the largest set of traces satisfies our correctness properties and this allows us to conclude that the transition system that we're interested in also satisfies the property
																\end{itemize}
															\end{minipage}
														}
													}
											}
									}
							}
						child {
								node {Classification of LT-properties
										\resizebox{\textwidth}{!}{
											\begin{minipage}[t]{16cm}
												\begin{itemize}
													\item \script{703}{Overview and examples} and \videoeight{3935}{Explanation}
													\item \script{937}{Examples} and \videonine{4065}{Explanation}, \videonine{4135}{Philosophers think}, \videonine{4225}{Philosophers eat same time}, \videonine{4257}{Philosophers eat before}, \videonine{4360}{Philosopher eats afterwards}, no starvation property, \videonine{4456}{Philosophers eating phase}
												\end{itemize}
											\end{minipage}
										}
									}
								child {
										node {Decomposition theorem
												\resizebox{\textwidth}{!}{
													\begin{minipage}[t]{12cm}
														\begin{itemize}
															\item \script{994}{Definition (ff.)}, \scriptfive{1}{Node 1} and \scriptfive{2}{Node 2}, \videonine{5555}{Connection to conjunction}
															\begin{itemize}
																\item classification does not mean that we have here the set of all LT properties all linear Time Properties and then we have then we can divide all linear Time Properties such that it is either a safety or liveness that is not the case so it's \alert{not} as if LT is the \alert{union} of safety and liveness however what is the case is that whenever I have a property e that I can write this e as a \alert{conjunction} of E1 and E2 such that E1 is a safety property and E2 is a liveness property and this is very nice that I can do this so it's a form of decomposition I decompose the property into a conjunction of a safety and the liveness property and this is very nice because I have one \alert{algorithm for safety properties} and I have \alert{another algorithm for liveness properties}, to prove that a transition system satisfies E I prove that it satisfies E1 and I prove that it satisfies E2, to prove safety properties I take the finite prefixes I look at the \alert{finite words} and for the other ones I look at the \alert{infinite words}, for the \alert{finite} ones I use automata over finite Words and for the other ones the \alert{second kind} of life properties one will use Büchi automata
																\item \script{1003}{Proof (ff.)}, \scriptfive{4}{Node 1} and \scriptfive{5}{Node 2} and \scriptfive{6}{Node 3} and \scriptfive{7}{Node 4}, \videotwelve{1506}{Proof step 1}, \videotwelve{1477}{Proof step 2}, \videotwelve{1427}{Proof Step 3}
																\item \script{956}{Only property both Safe and Live} and \videonine{4982}{Explanations}, \videonine{5017}{Empty Set Liveness}
																\begin{itemize}
																	\item \videonine{5037}{Set of all traces}, \videonine{5057}{Safety set of all traces}, \videonine{5127}{Liveness set of all traces}
																	\item  \videonine{5209}{Reason for only}, \videonine{5417}{Why does it hold}
																\end{itemize}
															\end{itemize}
														\end{itemize}
													\end{minipage}
												}
											}
									}
								child {
										node {Safety properties
												\resizebox{\textwidth}{!}{
													\begin{minipage}[t]{20cm}
														\begin{itemize}
															\item \enquote{\alert{nothing bad will happen}} or eqnuivalently \enquote{\alert{nothing bad happens and if it happens, it happens after a finite amount of time}}
															\item \script{790}{Definition (ff.)}, set of all \alert{infinite} words / traces that do not have a bad prefix
															\begin{itemize}
																\item \videoeight{2065}{Explanation: Counter Example}
																\item \videoeight{2283}{Explanation: Empty Set}
																\item \scriptthree{4}{More direct} and \videoeight{2109}{Explanation}, whenever I have a trace that does not satisfy the property one doesn't have to look at the whole infinite trace to know that the property does not hold, it is sufficient to look at all finite prefixes, if it does not satisfy the property, then there will be a position $n$ such that the prefix going from $A_0$ to $A_n$ is a bad prefix%, after finetely many states or finetely many elements in the sequence I know that I no longer need to look at what the remainder of Sigma is because the remainder of Sigma does not matter whatever you choose to extend it you will not be able to get a trace that satisfies E you will not be able to repair it
																\item another way to read this is \alert{if a trace violates (does not satisfy) the property e then it has a bad prefix} but what is a bad prefix well it is one that cannot be \alert{extended} to trace E
																\item \scriptthree{9}{Antoher Definition} and \videoeight{4449}{Explained}%, set of all traces such that no prefix of sigma lies in E
																\item \scriptthree{12}{Condition for safety property (bottom)} and \videoeight{5301}{Explanation}
																\item \videoeight{3857}{Finite good}, the nice thing about these characteristics is that my satisfaction relation of the transition system is now one where I don't need to look at the infinite traces but it is sufficient to look at the finite traces and this is because the $E$ defines me a set of finite words and vice versa a set of finite words I can use it as a set of bad prefixes to define an e, when a property is safety property when it can be defined by a set of bad prefixes, whether I have first come up with the set of finite words or whether I have first come up with the property and then i define the set of finite words it doesn't matter in any case this set of finite words is what I can use to define the correctness of the transition system
																\item \script{960}{Definition with closure (pr.)} and \videotwelve{467}{Explanation}
																\item \videonine{2627}{Summary of safety property and bad prefix}
															\end{itemize}
															\item \script{708}{Examples and classification (ff.)}% , it's related to the fact that bureaucracy is so great right when you go to the university and you ask can you do this they will say no it's not possible why because it's always safe to do nothing so when you when you have a system where you always remain in the same state this system satisfies every lifeless property every safety property right you are safe right save just means that you don't arrive at the bad thing, save just means that you don't arrive at the bad thing
															\begin{itemize}
																\item \script{779}{Alternative depiction and examples}, invariants like \alert{mutual exclusion} ($never\enspace crit_1\wedge crit_2$) and \alert{deadlock freedoom} ($never \bigwedge_{0\le i< n} wait_i$) can be identified by looking at one single state, don't need to look at history: \enquote{\alert{no bad state will be reached}} \videoeight{1550}{Explanation: Safety properties that need history}: \enquote{\alert{there is no bad prefix}}%, once come to state that breaks condition, then one has a finite prefix of the infinite sequence of states
																\item \script{799}{Examle: Traffic light (ff.)}, just come up with bad prefix
																\begin{itemize}
																	\item \videoeight{2799}{Why don't talk about sequence of states}, when specify correctness property don't know Cyber Physical systems, not constructed yet, don't have model yet, \videoeight{3195}{Don't say before this position}, reason that is not set of minimal bad prefixes, not first occurence
																\end{itemize}
															\end{itemize}
															\item \script{809}{Satisfaction}, can characterize the validity of a safety property on a given transition system T by the fact that none of the finite prefixes of a trace in the transition system is a bad prefix
															\begin{itemize}
																\item \videoeight{3424}{Proof: Minimal ones, why subset is equivalent}, why is this equivalent to go up if the set of finite traces does not contain a minimal bad prefix then I know that it does not contain a bad prefix because if it did contain a bad prefix then I could make this prefix minimal and then I would get a witness in the minimal bad prefixes and the other direction down is clear because minimal Bad prefix is a subset of Bad prefixes
																\item \script{811}{Proof (ff.)} and \videoeight{3500}{Explanation}, to be totally correct I should always put an index, a set of bad prefixes always depends on $E$, one defines a set of bad prefixes for the $E$
															\end{itemize}
															\item \underline{interesting facts:}
															\begin{itemize}
																\item \script{830}{Every invariant is a safety property} and \scriptthree{8}{Other version} and \videoeight{4029}{Explanation}, $E\;always\;\phi$: every reachable state satisfies some invariant condition $\phi$
																\item \script{837}{$\emptyset$ is a safety property} and \scriptthree{10}{Other Version} and \videoeight{4535}{Explanation}, we are talking about the prefixes of the negation of $E$, every trace is not part of the empty set, singleton that contains the empty word
																\begin{itemize}
																	\item \scriptthree{11}{Special case of Safety Property: Invariant} and \videoeight{4917}{Explanation}, there's no trace that every state satisfies false
																	\begin{itemize}
																		\item \videoeight{5022}{Difference false and Empty Set}, the empty set is as an atomic proposition is not the same as false as an as a propositional formula, just as everything satisfies true, no such thing satisfies false, there's no trace that satisfies the safety property, all finite words are bad prefixes and the minimal bad prefix is the empty word $\epsilon$
																	\end{itemize}
																\end{itemize}
																\item \script{837}{$(2^{AP})^\omega$ is a safety property} and \scriptthree{12}{Other Version} and \videoeight{5186}{Explanation}, premise that a trace does not satisfy the property is never fullfilled and implicatin where the premise is never fulfilled is valid, can choose empty set as the set of bad prefixes
															\end{itemize}
														\end{itemize}
													\end{minipage}
												}
											}
										child [level distance=8cm] {
												node {Regular safety properties
														\resizebox{\textwidth}{!}{
															\begin{minipage}[t]{12cm}
																\begin{itemize}
																	\item \script{1031}{Definition}, Regular means accpeted by automaton
																	\begin{itemize}
																		\item \videotwelve{4106}{Regular languages} and \scriptfive{20}{Node}
																	\end{itemize}
																	\item \script{1048}{BadPref is regular \textit{iff} MinBadPref is regular}
																	\item \script{1020}{If $\mathcal{T}$ is a finite transition system then $Traces_{fin}(\mathcal{T})$ is regular}, Tansform TS into an NFA and \videotwelve{2204}{Explanation}, \scriptfive{9}{Node}, \videotwelve{2475}{Just need to decide}, \videotwelve{2576}{Initial state not accepting}, \videotwelve{2705}{Label outgoing edge also possible}
																	\item \script{1026}{Checking safety and $\omega$-regular properties (f.)}, \scriptfive{8}{Node 1} and \scriptfive{10}{Node 2} and \scriptfive{11}{Node 3} , \videotwelve{3014}{Omega regular}, \videotwelve{3035}{Regular}, \videotwelve{3054}{Acceptance condition}, \videotwelve{2158}{Bad prefix represented by finite and bad traces by Büchi automaton}
																	\item \underline{interesting facts:}
																	\begin{itemize}
																		\item \script{1054}{Every invariant is regular (prr.)} and \videotwelve{3806}{Explanation}, \scriptfive{18}{Node}, \videotwelve{3614}{Property Negation}
																		\item \script{1059}{Every safety property is regular (ff.)} and \videotwelve{4058}{Explanation}, \scriptfive{19}{Node}, \videotwelve{4226}{Possible to have bad prefixes regular but minimal bad prefixes is not}
																	\end{itemize}
																	\item \script{1062}{Verifying regular safety properties}, \videotwelve{4394}{Complement of automaton}, not everything in complement is good prefix, notion of good prefix doesn't exist
																	\item \script{1065}{Overview Model checking (f. pr.)}, \scriptfive{21}{Node}, \videotwelve{4666}{Could also do with transition system}, but doesn't matter, \videotwelve{4675}{Safety can always be reduced to invariant}, \videotwelve{4700}{Two possibilities}
																	\item \script{1073}{$3$ Equivalent Statements (prr.)}, \videotwelve{4999}{Explanation: 3 Conditions}, production automaton, \videotwelve{5004}{$2$ options to check algorithmically}, \videotwelve{5046}{Case where safety property regular}, correctness checking reduced to checking of an invariant
																	\item \script{1075}{Example: Sequential circuit (ff.)} and \videotwelve{5109}{Explanation}, \videotwelve{5203}{$2$ possibilities}, \videotwelve{5319}{Counter Example}
																	\item \script{1082}{Algorithm}, \videotwelve{5351}{Explanation}, \videotwelve{5360}{Construct product automaton or product TS}
																\end{itemize}
															\end{minipage}
														}
													}
												child {
														node {Product-TS
																\resizebox{\textwidth}{!}{
																	\begin{minipage}[t]{12cm}
																		\begin{itemize}
																			\item \script{1070}{Example (prr.)}, \scriptfive{22}{Node}, \videotwelve{4700}{Two possibilities}, \videotwelve{4783}{Construction}, \videotwelve{4874}{Prefer constructing automaton from transition system}, \videotwelve{4977}{notion of acceptance}, never reach a accepting state, never accpepting invariant condition holds in every execution
																		\end{itemize}
																	\end{minipage}
																}
															}
													}
												child {
														node {Nondeterministic finite automata (NFA)
																\resizebox{\textwidth}{!}{
																	\begin{minipage}[t]{12cm}
																		\begin{itemize}
																			\item \script{1034}{Definition} and \videotwelve{3221}{Explanation}, \scriptfive{13}{Node}
																			\begin{itemize}
																				\item \script{1037}{Notations in pictures example (f.)}, \scriptfive{15}{Node}, \videotwelve{3445}{Short hand}, stands for whole set of edges where label of edge can be any set that satisfies formula
																				\item \script{1039}{Symbolic notations for transition labels and examples}, \scriptfive{16}{Node}, \videotwelve{3445}{Short hand}, stands for whole set of edges where label of edge can be any set that satisfies formula, \videotwelve{3507}{Empty set}
																				\item \videotwelve{2273}{Initial state of automaton}
																			\end{itemize}
																			\item \videotwelve{3196}{Accept words and recognize sets}, \scriptfive{12}{Node}
																			\item \underline{Examples:}
																			\begin{itemize}
																				\item \script{1042}{Example: NFA for bad prefixes}, \videotwelve{3553}{Explanation}, \videotwelve{3614}{Property Negation}
																				\item \script{1047}{Example: Regular safety property (prr.)}, \videotwelve{3671}{Explanation}
																				\item \script{1055}{Example: DFA for MUTEX}
																			\end{itemize}
																		\end{itemize}
																	\end{minipage}
																}
															}
													}
											}
										child { % [level distance = 5cm] {
												node {Prefix closure
														\resizebox{\textwidth}{!}{
															\begin{minipage}[t]{16cm}
																\begin{itemize}
																	\item \script{891}{Definition}
																	\begin{itemize}
																		\item \script{906}{$\sigma\in cl(E)$ \textit{iff} $pref(\sigma)\subseteq pref(E)$ (f.)}, and also negation on both sides
																		\item \scriptfour{1}{Closure in Math}, \videonine{823}{Operation/Function}, \videonine{869}{Open Interval Intuition, add limit points, closed set}
																		\begin{itemize}
																			\item \videonine{3244}{Other interesting things}, set closed means it is equal to it's closure, \alert{whenever one has a property e and one takes it's closure, then one gets a safety property}, \scriptfour{6}{Apply closure to closure}, if apply closure to the closure of a set, then one gets the same set in the closure
																			\item \videotwelve{219}{Distance}, \videotwelve{232}{Example: Eventually b}
																			\item \videotwelve{1489}{Closure properties}, closure is idempotent
																		\end{itemize}
																		\item \scriptfour{1}{Other definition for prefix closure}, \videonine{1046}{Explanation}, \videonine{1094}{Example}, \videonine{1273}{What has to do with limit points}, \videonine{1403}{Function $pref$}, \videonine{1496}{Role of Inclusion}, \videonine{1580}{Why Property is subset of Closure}, \videonine{3011}{Closure condition explained}
																		\item \script{898}{Examples} and \scriptfour{2}{Sidenotes}
																		\begin{itemize}
																			\item \underline{example 1:} \videonine{1937}{Complement Method}, \videonine{2758}{Summary}
																			\item \underline{example 2:} \videonine{2102}{Explanation}, \videonine{2324}{Explanation: Inclusions}, \videonine{2796}{Summary}
																		\end{itemize}
																		\item \videonine{3076}{Not being in $pref(E)$}, which means it can't be extented and is a bad prefix
																	\end{itemize}
																	\item \alert{$E$ is a safety property \textit{iff} $cl(E) = E$}, subset inclusion always holds in one direction, if there's a trace trace that is in in the closure but not in E then it's not a safety property
																	\begin{itemize}
																		\item \videonine{2432}{Explanation} and \scriptfour{3}{Sidenotes}, \videonine{2492}{Complement closure method}
																		\item \script{909}{Proof (ff. prr.)} and \scriptfour{4}{Sidenotes}, \videonine{2870}{Explanation: Backward}, \videonine{3167}{Explanation: Forward}
																		\begin{itemize}
																			\item \videonine{3272}{$cl(E) \supseteq E$ holds}
																			\item \videonine{3312}{$cl(E) \subseteq E$ holds}
																			\begin{itemize}
																				\item \videonine{3415}{$pref(cl(E)) = pref(E)$}, prefixes of the closure of the set equal to prefixes of the set, because elements in the closure are defined by it's prefixes
																			\end{itemize}
																		\end{itemize}
																		\item \videonine{3449}{Use this property}
																		\begin{itemize}
																			\item \videonine{3489}{Closure of $E$ is Safety Property}, because the closure of the closure is the closure again
																		\end{itemize}
																	\end{itemize}
																\end{itemize}
															\end{minipage}
														}
													}
											}
										child [level distance = 6cm] {
												node {Bad prefix
														\resizebox{\textwidth}{!}{
															\begin{minipage}[t]{12cm}
																\begin{itemize}
																	\item finite word that can't be extented to a trace that satisfies the property $E$
																	\begin{itemize}
																		% \item what is a bad prefix it is a finite sequence and if it is if this finite sequence is a prefix of an infinite trace then this infinite trace will not satisfy the given linear time property e
																		\item \script{793}{$BadPref$}, set of \alert{finite} words / prefixes
																		\item \script{794}{Minimal bad prefixes}, not always minimal, whenever you have this bad thing happening and you extend it will remain a bad prefix, any finite extension of a minimal bad prefix is again a bad prefix and every extension of a bad prefix is a bad, bad prefixes are \alert{finite} that's why we use a $*$, if shorter then there is a way to repair it
																		\item \script{784}{Examples}
																		\begin{itemize}
																			\item it is the infinite Trace that violates a property of infinite traces so one cannot say that a finite prefix violates the property it's just that one knows that every Trace that has this prefix will violate the property no matter how this continues this Trace here will not satisfy by the correctness so the prefix is bad in the sense that you cannot continue it to a trace that satisfies the property so it is a finite witness
																			\item \videoeight{1723}{Explanation}
																		\end{itemize}
																		\item \videoeight{2341}{With respect to property with example}, it doesn't make sense to say that some finite sequence of labels is a bad prefix but it depends on the property for other properties it could be extended
																	\end{itemize}
																\end{itemize}
															\end{minipage}
														}
													}
											}
										child {
												node {Invariant
														\resizebox{\textwidth}{!}{
															\begin{minipage}[t]{12cm}
																\begin{itemize}
																	\item \script{750}{Invariant Checking (f.)}
																	\begin{itemize}
																		\item not satisfied want \videoeight{655}{Counter example}, i.e. path that reaches state that violates invariant condition, path only until state that violates property, don't need to extend path, trace that labels path is infinite but one already knows that trace will violate the invariant, so it doesn't matter what follows after this state
																	\end{itemize}
																	\item \script{727}{Definition}, $always\;\phi$, $never\;\neg\phi$, invariantly the not bad thing holds true, every state on path of transition system which always starts in initial state satisfies the invariant condition, which means the label satisfies it, some invariant conditions holds true about every state in every execution of the transition system that starts in the initial state
																	\begin{itemize}
																		\item \enquote{\alert{no bad state will be reached}}
																		\item \videoeight{467}{Intuitive explanation}
																	\end{itemize}
																	\item \script{711}{Examples}
																	\begin{itemize}
																		\item \script{730}{Example: Mutex (ff.)}
																	\end{itemize}
																	\item \script{738}{Satisfaction of invariants (ff.)}, only look at one state at a time on paths, so check that for each reachable state it satisfies the invariant condition
																\end{itemize}
															\end{minipage}
														}
													}
												child {
														node {DFS-based invariant checking
																\resizebox{\textwidth}{!}{
																	\begin{minipage}[t]{12cm}
																		\begin{itemize}
																			\item \script{756}{Algorithm}, failed search means that system is so far correct, reverse stack for counter example
																			\begin{itemize}
																				\item \script{752}{Input and Output}
																				\item \script{766}{Resursive DFS}, %arbitrary states, first time on initial states, 
																				\begin{itemize}
																					\item \videoeight{958}{Explanation}, if state has already been processed which means that it is not in the set of unprocessed states then the algorithm will say no the serach has failed because I already have processed the state and if I have come here it means that the processing of this state did not result in a positive answer because if there was a positive answer I would stop, loop then state already processed so no push on stack for new identical state
																				\end{itemize}
																			\end{itemize}
																			\item \script{767}{Example (ff.)}
																		\end{itemize}
																	\end{minipage}
																}
															}
													}
											}
									}
								child {
										node {Liveness properties
												\resizebox{\textwidth}{!}{
													\begin{minipage}[t]{16cm}
														\begin{itemize}
															\item \enquote{\alert{something good will happen}}, \enquote{\alert{the good thing will happen sometimes after finite amount of time but not always}}
															\item \script{941}{Definition} and \scriptfour{5}{Sidenotes} and \videonine{4508}{Explanation}, \videonine{4553}{Inclusion}
															\begin{itemize}
																\item \script{926}{Categories with examples}, \videonine{3564}{Explanation}, \videonine{3892}{No starvation property}
																\item \videotwelve{566}{Negation Liveness property}
															\end{itemize}
															\item \videonine{3711}{Intuition Liveness Property}, to know that an event will not occur eventually, one needs to know the whole infinite trace, if it's satisfied for some liveness properties (not infinitely many times) there's a finite witness
															\item \script{945}{Examples (ff.)} and \videonine{4644}{Explanations}, \videonine{4772}{Wrong here can be star}, \videonine{4885}{Reactiveness}, \videonine{4953}{Reason for strictly greater}
														\end{itemize}
													\end{minipage}
												}
											}
										child {
												node {Contradiction to independance
														\resizebox{\textwidth}{!}{
															\begin{minipage}[t]{12cm}
																\begin{itemize}
																	\item \script{639}{Example: LT property \enquote{infinitely often green} (ff.)}, this is somehow in contradiction to the fact that the two transition systems are independent right so they work independently there is no synchronization between them they don't know it about each other so how come when I take the model for the two together the property suddenly stops well obviously this model here is not a good model because it does not allow us to reflect that well in the real world this cyber physical system here does satisfy this property here so we need to accommodate the model for the safety properties it is perfect but um it's not good for the other one
																\end{itemize}
															\end{minipage}
														}
													}
											}
										child {
												node {Liveness for Mutual Exclusion
														\resizebox{\textwidth}{!}{
															\begin{minipage}[t]{16cm}
																\begin{itemize}
																	\item \script{584}{Definition for Mutex}: %e.g. not waiting forever to get into ciritical section, shouldn't say every process that requests enters because this is talking about actions we need to talk about the atomic propositions wait and crit and so we can define this livess or starvation freedom property as the set of all infinite words over the power set of the atomic propositions such that we say that if process one is waiting infinitely often then process one should also be in the critical section infinitely often because if you're waitiing often and you don't only get to enter finitely many times, then at some point you have to wait forever and the same of course holds for the second process that one shouldn't wait forever either okay and right in the same way, parenthesis around the premise, otherwise it's a bit ambigous, but you're more ambitious right so something good is supposed to happen so you must move to some good state and eventually yoand not stay in the same save state and eventually you will arrive at the good thing
																	\begin{itemize}
																		\item \alert{starvation freedom} means something like each time there is a request there will be an acknowledgement and so the request is an action but the effect of the action is that the successor state has the label wait either wait one or wait two and then there is an acknowledgement where the acknowledgement here means the enter action and the effect of the enter action is that the successor state satisfies the atomic proposition crit one or crit 2
																		% 	\item to understand this implication it makes sense to look at its negation the negation of an implication is that the left side of the implication holds and the right side does not and it means that we have this infinite trace because it's infinite and goes outside of the transparency and infinitely often there is this request and so the process let's say process one is is in the wait state or is in a state that satisfies the atomic proposition wait and now the right hand side of the implication is wrong if the implication is falsified and what does this mean it means that only finite many positions have crit one in the letter so that means that after a finite amount let's say here there is no more so in the rest here there is no more our position such that the label contains the atomic proposition crit one% and this means that there are requests right because we have infinitely more infinite requests and in fact there are infinitely many requests because there infinitely many positions where wait one is an element of the labor which do not have the response right the the request to enter the critical section is not met because from here on we no longer have crit in one of the letters and intuitively it is because we reason about infinite traces so we do not care what happens finitely often so if finally often a request is met by an acknowledgement that's fine but we want that it happens infinitely often
																		% 	\item examples for trace in live: $(\{wait_1\}, \{crit_1\}, \{wait_2\}, \{crit_2\})^{\omega}\in LIVE$, $\emptyset^{\omega} \in LIVE$, $\{crit_1\}\in LIVE$, if noones wait infintely often we don't care what else happens,% $(\{wait_1\}, \{crit_1\}, \{wait_2\})^{\omega}\in LIVE$
																	\end{itemize}
																	\item \script{601}{Problem with Liveness (ff.), } in this Trace we have infinitely often wait 2 right this these three occurrences are repeated infinitely often but we don't have any occurrence of crit 2 so in particular we don't have infinitely many occurrences of crit 2 and this is problematic here right we have the second process has requested but it never gets to actually enter the critical section, many people will actually still use semaphores for Mutual exclusion because in practice is it's probably it's quite unlikely that this happens and towards the end of the lecture we will see the concept of fairness so that's sort of an additional assumption that we put to rule out this. Usually we would have a self flop in the initial state that means that perhaps a process never ever needs to uh make a request but it can if it wishes
																	\item \script{604}{Peterson algorithm (ff.)}: $b_1$ and $b_2$ are booleans, $X$ identifies one of the two processes
																	\begin{itemize}
																		\item  P1 when it requests sets B1 to true or to one so B1 sort of means process one would like to be in the critical section and it also sets the variable X to two and P2 does something symmetric afterwards
																		\item now process one if it wants to enter it can only enter if this guard is fulfilled right it can only enter if either X is equal to one but we just set it to two so something has to happen for that to hold or B2 is false not b2 holds so if the other process doesn't want to enter then of course I can just enter that's the easy case um but if this if B1 is set to true then we have to wait until X is equal to one
																		\item similar to a common situation two people who want to exit. in a few minutes we all want to exit through this door but we don't want to run into each other so there's a mutual exclusion only one person can be in the door at the same time and let's say two people are heading to the door and one person arrives like a split second before the other person because we're all very polite people the first person will say no please you go first and then the second person to arrive will also be very polite and say no please you will here first you go first and then the first person will go through right and this is sort of what happens here when the process one sets X to two it says so process two you can go first and if process two arrives second it will undo this change it will set X to one again and then this is satisfied so the first process can actually go through the door and as it leaves the door it makes space for the second process to also enter the door or enter the critical section here
																		\item \script{611}{Example, $b_1 = 0, b_2 = 0$}, initially they have not requested because if we do that then we have this nice thing that whenever we are in ncrit one then B1 is equal to zero and whenever we are in wait one or crit one B1 is equal to one and the same here for the second process, in this transition system I didn't write the values of B1 and B2 because else unreadable and it's okay because whenever I'm in wait one I know that B1 must be equal to one and if I'm in ncrit 2 then that means B2 is equal to zero right
																		\begin{itemize}
																			\item also satisfies live one way we can do that is we can look at all the states where wait one holds and I mean we know that when we are in one of these states infinitely often we should make sure that we're also infinitely often in a state with crit one and we can do that if we make sure that after we're such in such a state after a finite number of steps we're going to be in a state with crit one again because then if one happens infinitely often the other one also has to happen infinitely often and that's the case% because right for this state here we know that immediately in the next state process one is in the critical section so it's fine for this state we have two options either crit one holds immediately in the next step or after two steps also still fine and then we can sort of propagate that back right so this state is also okay because even though wait one holds in the next step we are in a state where we know that soon after crit one will hold so in particular after at most three steps crit one will hold and then for this state after at most four steps crit one will hold so if we're in one of these states then in one of the yellow States infinitely often we must be in one of the red States infinitely often as well
																			\item and so you see that here you you can no longer execute the loop where the transition from wait into critical can be ignored forever so it is ignored here so we don't have a transition that goes from wait 2 to critical 2 important is that from here I canot take the transition where the first process goes from wait to critical and this is because we have this flag here x = 1 and that means that when both of them are in wait the value of x signals whose turn it is we avoid this infinite Loop that ignores the second process forever
																		\end{itemize}
																	\end{itemize}
																\end{itemize}
															\end{minipage}
														}
													}
											}
									}
							}
					}
				child {
						node {Modelling Concurrent Systems
								\resizebox{\textwidth}{!}{
									\begin{minipage}[t]{12cm}
										\begin{itemize}
											\item \script{168}{Semantic models}
											\begin{itemize}
												\item \script{175}{states, transitions, atomic propositions}
											\end{itemize}
											\item \script{204}{Nondeterminism} and \script{207}{Interpretation}
											\begin{itemize}
												\item \script{452}{More on Nondeeterminism}
												\item \script{471}{Summary}
											\end{itemize}
										\end{itemize}
									\end{minipage}
								}
							}
						child {
								node {Program Graph
										\resizebox{\textwidth}{!}{
											\begin{minipage}[t]{14cm}
												\begin{itemize}
													\item \script{402}{Definition}, \alert{nodes} called \alert{locations} / lines and not states, $Cond(Var)\times Act$ is if guard is satisfied then execute the action, and executing the action, the values of variables change according to what the effect functiono has specified, somtimes action is void, effect defines how does the action change the values of the variables and therefore Effect function that assigns to each action a function that takes a value of the variables and gives them the new value of the variables
													\item \script{376}{Semantics and states}, it is not sufficient to just know what the \alert{variable} of $x$ is, because one also has to know in what \alert{location} it is to know what's the next statement one has to execute, location alone not sufficient because one could have if then else statemts and x could not have the right value
													\item \script{412}{TS-semantics of a program graph (ff.)}, initial states are initial locations and values anything that satisify the initial condition, alpha is the alpha that labels edge in the program graph, edge in program graph drawn with hook and only go there if values of variables in state satify the guard, values of variables change according to what new valuation the effect function assigns to that action%, $\righrarrow$ is called transition function of transition system
													\begin{itemize}
														\item \script{416}{Labeling of the states}
														\item \script{421}{Typed variables}
														\item $Eval(Var)$: Set of evaluations for Var
														\item $Cond(Var))$: Set on the of Boolean conditions  on the variables in Var
														\item \script{425}{Conditions on typed variables and $\models$ relation (f.)}
														\item \script{431}{Effect-function for action}, \scripttwo{1}{More details about Effect-function}, for many statements it was always quite obvious from the name of this action what the effect was meant to be but you will also see in the exercises some actions where this is not clear from the name and so we have to define the effects separately
													\end{itemize}
													\item \script{379}{Example: Sequential program (f.)}, on the left side transition system, could label actions, then can label edges in transition system with action names%, in cases where one doesn't fix $x$ and $y$ one has to draw such a transiation system for every single pair of values for $x$ and $y$
													\item \script{389}{Example: Beverage machine and \alert{number of states}}, guarded command language (GCL), environment modelled non-deterministicaly, $2$ program locations start and select and $3$ values for soda and beer
												\end{itemize}
												% EXAM: transform program graph into transition system
											\end{minipage}
										}
									}
								child {
										node {Interleaving for PG
												\resizebox{\textwidth}{!}{
													\begin{minipage}[t]{12cm}
														\begin{itemize}
															\item \script{375}{Example}, if statement on outgoing edge at line $1$, will go from line one to the next line by executing the statement in line $1$, abstract away from the syntax of a programming language, one does not have to think about text%, resembles a little bit the notation of transiation systems
															, \alert{thread} 1 executing \alert{program} 1 and thread 2 executing program 2, in both cases locations are the same, but the state is different, because the value of the variable x is different. \alert{First} form the \alert{interleaving program} graph and \alert{second} from this program graph one derives / \alert{builds} the \alert{transition system}, one looks at the value of the variable $x$ according to each transition%. Is not the same as taking the transition system for both programs and taking the interleaving semantics for those
															\item \script{443}{Independant and dependant actions, interleaving and competition}
															\begin{itemize}
																\item \script{448}{Example with graph and disabled actions (ff.)}
															\end{itemize}
															\item looks very similar to the inter leaving of transition systems but it is a program graph so we call these nodes here locations rather than States and they still have these guards which is something that we don't have in transition systems
															\begin{itemize}
																\item take the transition system by adding the valuations of variables
																\item what could also happen is that of course we have the combination of two locations with different variable valuations appearing in the transition system right so for instance if I didn't fix that Y is equal to 1 in the beginning I would also have an initial state for ncrit 1 ncrit 2 and y is equal to 2 right this would be another initial State and then we would have a number of other states that are reachable from that
															\end{itemize}
															\item \script{382}{Example: Critical resource (ff.)}, for access to resource to synchronse but not for request, variable called semaphor, if semaphor 1 can access critical section, both adhere to syme protocol, make sure that in transition system state where the location is crit1 crit2 can not be reached
														\end{itemize}
													\end{minipage}
												}
											}
									}
							}
						child {
								node {Transition System
										\resizebox{\textwidth}{!}{
											\begin{minipage}[t]{12cm}
												\begin{itemize}
													\item \script{184}{Definition} and \script{187}{$Act$-Set} ($AP$, assign to each state observations that one can make in the present state)
													\begin{itemize}
														\item \script{147}{safety, liveness, real-time requiremens}
														\item $!\alpha$ send signal $\alpha$
														\item $?\alpha$ receive signal $\alpha$
														\item \script{199}{Behaviour as algorithm (f.)}
														\item \script{133}{Example: Control system for traffic lights (ff.)}
														\item \script{154}{Example: Railroad crossing (ff.)}, it is possible that the train enters before we send the lower signal or before the phyiscal component has reached it's state here (edge lower, down) and this would mean one would end up in the state in 1 up and this is something one doesn't want
														\item \script{191}{Example: Beverage machine}
													\end{itemize}
												\end{itemize}
											\end{minipage}
										}
									}
								child {
										node {State-based view
												\resizebox{\textwidth}{!}{
													\begin{minipage}[t]{14cm}
														\begin{itemize}
															\item abstraction fom actions, ignore action labels on transitions, only useful for modelling formalisms, ignore details, more generel view of states, therefore use \alert{atomic propositions}
															\item \underline{reasons:}
															\begin{itemize}
																\item many states don't need to distinguish all of them, can happen that 2 states with the same atomic propositions labeled and treated the same
																\item want to do this modeling of the transition system or more generally the design of the actual system independently and separately from the rec requirements. We want to be able to write down the requirements and maybe even formalize them before we even start designing the system. % Don't know what the states of this whe transition system are going to look like so I'm going to just fix some Atomic propositions that I think are important to the requirements that I care about and then I can specify the system using only those atomic propositions and later the designer of the system for example can read my specification and think about how to implement it but all these implementation details like actions and the 
																structure of States um is something I don't want to care about when I'm just specifying the behavior
																% \item the set of atomic propositions that we choose always depends on what properties we are interested in
															\end{itemize}
															\item \script{527}{Overview (ff.)}, if we have any terminal State then there's no outgoing transition what we're going to do is we're going to add a new state this is not a state that is previously part of the transition system and we're going to add one new atomic proposition and this state is going to have a self loop and any terminal state just gets a transition to the state so now we no longer have terminal states and it's in a sense equivalent right we can just we have to adapt our specifications a bit so for instance instead of saying something always holds we maybe have to say it always holds unless the system has terminated and for that we can use this atomic proposition or if we just want to rule out terminal states we can also just add the specification that the system never terminates right it depends a bit on which system we are going to look at. It's also not expensive
															\item \script{532}{Example: Communicating traffic lights}, labeling is as one would expect, this transition system has just one execution when we start in initial state we have only one transition we can take and then only one transition we can take after that it's a completely deterministic and then we also must have only one trace
															\item \script{535}{Example: Independent traffic lights (pr.)}, many possibilities we can for example do this loop n number of times and then do this loop forever right that gives you for every natural number a different trace so we already have definitely infinitely many
															\item \script{537}{Example: Mutual exclusion with semaphore (ff.)}, infinitely many choices
															\item \script{554}{Example: Four States (ff.)}, infinitely many paths, always when we have these like two different Loops that are nested into each other we often have infinitely many right we can for example take this Loop on the left side a couple of times and then loop around or we can do the the bigger Loop a couple of times, only one Trace we always switch between a blue and a yellow State and it doesn't matter which path we take, \underline{later:} now we have the same graph but because we suddenly distinguish between these two states the number of traces explodes from one to infinitely many
															\item \script{561}{Example: From Programgraph (ff.)}, when we have a transition system derived from a program graph often times we take Atomic propositions that look like conditions over the variables and then we need to check how we label those States so we just check the variable assignment satisfies which of the atomic propositions it satisfies, \underline{later:} right hand side we may have infinitely many paths but because those states are labeled with the same set we have only one trace the empty set and then infinitely often the set even y
															\item when ones talks about traces always look what are the atomic propositions and and how is the transition system labeled,
														\end{itemize}
													\end{minipage}
												}
											}
										child {
												node {Paths
														\resizebox{\textwidth}{!}{
															\begin{minipage}[t]{12cm}
																\begin{itemize}
																	\item \alert{Path}: An initial maximal path fragment
																	\begin{itemize}
																		%   \item paths should always be as long as they possibly can. self Loop we would only call this a path if we take it infinitely often and so path either has to be infinite or it has to end in a state like where there is no next step to take 
																		\item \script{516}{Path Fragment}: Sequence of states arising from the projection of an execution fragment to the states and can be infinite or finite, or \underline{informal:} execution fragment where one has removed all the action labels
																		\begin{itemize}
																			\item \alert{Execution}: An initial maximal execution fragment
																			\begin{itemize}
																				\item \script{516}{Execution Fragment}: Sequence of consecutive transitions
																				\item \alert{initial:} If $s_0 \in S_0$ , if it starts in a initial state
																				\item \alert{maximal:} If infinite or ending in a terminal state
																			\end{itemize}
																		\end{itemize}
																		\item \script{510}{Paths of a Transition system (f.)}
																		\item $Paths(s_i)$: Paths of a particular state
																		\item $Paths_{fin}(s_i)$: Set of finite path fragments starting in $s_i$, e.g. take self loop any finite number of times, so infinitely many finite path fragments
																		\item $Paths_{fin}(\mathcal{T})$: Finite path fragments of the whole transition system
																	\end{itemize}
																\end{itemize}
															\end{minipage}
														}
													}
											}
										child {
												node {Traces
														\resizebox{\textwidth}{!}{
															\begin{minipage}[t]{12cm}
																\begin{itemize}
																	\item \script{523}{Trace (pr.)}: Take a path of a transition system and replace every state by the label of the state, the set of atomic propositions
																	\begin{itemize}
																		\item $\operatorname{Traces}(\mathcal{T}) \stackrel{\text { def }}{=}\{\operatorname{trace}(\pi): \pi \in \operatorname{Paths}(\mathcal{T})\} \subseteq\left(2^{A P}\right)^\omega$, the traces of a transition system are the traces of each path% and the paths are the initial maximal path fragments
																		\item $\operatorname{Traces}_{\text {fin }}(\mathcal{T}) \stackrel{\text { def }}{=}\left\{\operatorname{trace}(\widehat{\pi}): \widehat{\pi} \in \operatorname{Paths}_{\text {fin }}(\mathcal{T})\right\} \subseteq\left(2^{A P}\right)^*$
																		% \item often look at TS's that \alert{don't have terminal states}, because if we don't have terminal states then all the executions are infinite we can never get stuck in the terminal State or the paths are infinite and all the traces are infinite and that's just otherwise we often have to make this case distinctionif the trace is finite then this and if the trace is infinite we have to do something else. If we make this assumption then the traces are exactly a subset of this set on the right 
																		\item \alert{ignore} transition systems that have \alert{terminal traces} and the intuition is that we don't really need terminal traces because we can always add a self loop and in fact that self Loop models the fact that when you stay in the same state well it is in fact you do a self transition and when we want to reflect that you don't need to get out of a state then you want to add a self transition to the state right so when you have somehow a state which has no outgoing transition well this is as if the time is stuck right and when you have a state which has an outgoing transition well this looks as if in fact you are obliged to move into this state here whereas in truth we don't specify how long we stay there and so in fact it would make sense to add a self Loop to every state and then if we do that then we don't have any terminal states because and it would not change anything with respect to the safety properties. we don't put them always because it makes the system a little bit more complicated but we put them at states that would be terminal otherwise
																	\end{itemize}
																	\item \script{521}{Example}, two paths depending on what initial state ones chooses
																	\item several executions can have the same trace
																\end{itemize}
															\end{minipage}
														}
													}
											}
									}
								child {
										node {TS for special use cases
												\resizebox{\textwidth}{!}{
													\begin{minipage}[t]{12cm}
														\begin{itemize}
															\item \script{328}{Sequential circuit (ff., pr.)}, always when one goes to the next state, the values of the input bits can be everything, must take account of all non-determinstic assignment of values, values of the registers are determined by this functions delta, atomic propositions play a role when we talk about properties that talk about the behaviour of the system, in terms what can be observed about the system, we don't observe value of the registers, input bits and output bits observed. Value of output written as label to the state
															\begin{itemize}
																\item \script{348}{Example}, first write all possible states (maybe good idea?), two initial states because the environment assigns Non-deterministicaly either a $0$ or $1$ to the input bit, each state will have two transitions because the $X$ can either be $0$ or $1$%, at the end flip between two states depending on input
																\item \script{352}{Number of states}, a \alert{state} is the sequence of all bits of values of the input and the registers, number gates don't play role
															\end{itemize}
														\end{itemize}
													\end{minipage}
												}
											}
									}
								% child {
								%   node {Dependant Actions
								%     \resizebox{\textwidth}{!}{
								%       \begin{minipage}[t]{12cm}
								%         \begin{itemize}
								%           \item \script{304}{Example}
								%         \end{itemize}
								%       \end{minipage}
								%     }
								%   }
								% }
								child {
										node {Composite Transition System
												\resizebox{\textwidth}{!}{
													\begin{minipage}[t]{12cm}
														\begin{itemize}
															\item \script{156}{Example: Railroad crossing (ff.)}
														\end{itemize}
													\end{minipage}
												}
											}
										child {
												node (interleavingoperator) {Interleaving operator $\parallel\;\!\!\!\mid$
														\resizebox{\textwidth}{!}{
															\begin{minipage}[t]{12cm}
																\begin{itemize}
																	\item \script{262}{Definition (ff.)}\quad(disjoint union: \cite{mAnswerWhatDefinition2010})
																	\begin{itemize}
																		\item \script{224}{\enquote{Diamond}}, order does not matter%, action is still enabled, because 2nd process hasn't changed it's state
																		\item \script{218}{Example: Useless lights for non-crossing streets}
																	\end{itemize}
																\end{itemize}
															\end{minipage}
														}
													}
											}
										child {
												node {Synchronization operator $\parallel_{Syn}$ \& parallel operator $\parallel$
														\resizebox{\textwidth}{!}{
															\begin{minipage}[t]{12cm}
																\begin{itemize}
																	\item \script{275}{Definition: Synchronization operator $\parallel_{Syn}$ (pr.)}, if $\alpha \in Act_i \setminus Syn$ then it's just like the interleaving operator
																	\begin{itemize}
																		\item \script{251}{Synchronization Alphabet}, request not in synchronsiation alphat, no difference interleaving or synchronised transition, for synchronized parallel composition important to name $Act_1$, $Act_2$ apart, so that they don't appear in the intersection, for interleaving not important $r_1$ and $r_2$, because one doesn't talk about synchronization alphabets, based on this \script{254}{example} %(two green going away from crit1 wait2 lock and wait1 crit2 lock have to be r2, r1, left to right)
																		, interleaving composition ignores the action labels, there is no synchronisation, that's why no label request \script{250}{here}
																		% https://youtu.be/a8rkQRxgmfU?feature=shared&t=2270
																	\end{itemize}
																	\item \script{283}{Synchronization operator $\parallel_{Syn}$ for three or more processes (f.)}, for the arbiter example the request did not appear in the synchronisation alphabet, even though it appeared in the shared alphabet of the two components, often request that that there may be an overlap between the action symbols of two, but never between three, don't allow that three move in parallel. \script{373}{This} is for the case where one does not specify the sychrnonsiation alphabet beforehand
																	\begin{itemize}
																		\item $Syn$ always has to be a subset of the actions of the two transition systems so we did a little trick here and said we define this in this context to just mean we synchronize here only over the actions that are in syn and are in T1 as well as in T2
																	\end{itemize}
																	\item \script{285}{Parallel operator $\parallel$ (for three or more processes)}
																\end{itemize}
															\end{minipage}
														}
													}
												child {
														node (arbiter) {Mutual exclusion with an arbiter
																\resizebox{\textwidth}{!}{
																	\begin{minipage}[t]{12cm}
																		\begin{itemize}
																			\item \script{250}{Protocol with Arbiter}
																			\begin{itemize}
																				\item \script{250}{Example: Mutual exclusion with an arbiter (ff.)}, take the interleaving of the two transition systems, so they don't synchronise with each other
																				\item if Y is initially equal to 1 then only one of one process can be in the it's critical location if Y is initially equal to two then at most two processes can be in their critical location
																			\end{itemize}
																		\end{itemize}
																	\end{minipage}
																}
															}
													}
												child {
														node (concurrency) {Concurrency between synchronized components
																\resizebox{\textwidth}{!}{
																	\begin{minipage}[t]{12cm}
																		\begin{itemize}
																			\item \script{230}{Example: Booking system in supermarket}, in state 101 can code and print in parallel, either code and then print or print and then code, but arrive at the same state, also have diamond, have an action that concerns only $2$ of the $3$ components and not the third one and then the third one can move in parallel with the other two. We distinguish between the \alert{independant actions} that are the ones that don't appear in the shared synchronisation alphabet and the \alert{dependant} ones, they appear in the shared ones
																			% reason: not transitive relation
																		\end{itemize}
																	\end{minipage}
																}
															}
													}
											}
									}
							}
					}
			}
		child {
				node (test){Basics}
				child {
						node {Propositional Logic
								\resizebox{\textwidth}{!}{
									\begin{minipage}[t]{12cm}
										\begin{itemize}
											\item \script{715}{Overview (ff.)}
											\begin{itemize}
												\item \script{722}{State satisfies condition}
											\end{itemize}
										\end{itemize}
									\end{minipage}
								}
							}
					}
				child {
						node {Predicate Logic
								\resizebox{\textwidth}{!}{
									\begin{minipage}[t]{16cm}
										\begin{itemize}
											\item $\overset{\infty}{\exists}i \in \mathbb{N}_0: \text{cond}_i = \forall j\in \mathbb{N}_0:\exists i\in\mathbb{N}_0: i > j \;\wedge\; \text{cond}_i \;\hat=$ \enquote{there exist infinitely many}
											\item $\overset{\infty}{\forall}i \in \mathbb{N}_0: \text{cond}_i = \exists j\in \mathbb{N}_0:\forall i\in\mathbb{N}_0: i > j \rightarrow \text{cond}_i \;\hat=$ \enquote{for almost all, i.e., for all except for finitely many}
										\end{itemize}
									\end{minipage}
								}
							}
					}
				child {
						node {Not-categorizable topics
								\resizebox{\textwidth}{!}{
									\begin{minipage}[t]{12cm}
										\begin{itemize}
											\item \script{47}{Impact of Errors}
											\item \script{60}{System design cycle}, model satisfies mathematical requirements (specification), experience that concrete systems satisfies informal requirements that are not mathematical
										\end{itemize}
									\end{minipage}
								}
							}
						child {
								node {Validation Techniques
										\resizebox{\textwidth}{!}{
											\begin{minipage}[t]{12cm}
												\begin{itemize}
													\item \script{71}{Overview}, testing can only cover a finite subset, whereas a mathematical theorem about natural does hold over all natural numbers, running the physcal system = testing which is extremely costly, for simulation make assumption about physical environment and one doesn't know if they are satisfied
													\begin{itemize}
														\item \script{75}{Schema for formal verification}%, model based on components of cyber physical system, speciciation describes behaviour of overall system, by behaviour of it's components
													\end{itemize}
												\end{itemize}
											\end{minipage}
										}
									}
								child {
										node {Deductive verification (deductive, semi-automatic)
												\resizebox{\textwidth}{!}{
													\begin{minipage}[t]{12cm}
														\begin{itemize}
															\item \script{76}{Overview}, human comes up with the proof, takes the model and the properties and construct a proof that the model satisfies the properties and let a theorem prover check each step of the proof, for deductive verification you use mathematical formulas for the model and for the behavior and then this implication expresses that every behavior of the model is a behavior that is admitted by my collective properties, often these theorem provers check the validity of an implication, the implications says every behavior of the system but if I have a behavior of of the model then this is a behavior that satisfies the specification
														\end{itemize}
													\end{minipage}
												}
											}
									}
								child {
										node {Automatic verification  (algorithmic, fully-automatic)
												\resizebox{\textwidth}{!}{
													\begin{minipage}[t]{12cm}
														\begin{itemize}
															\item machines comes up with mathematical proof, finds proof and checks it, there are specific kinds of techniques called model checking
															\item \script{77}{Overview Model Checking undecidable}, even for models of simple machines that implement sequential programs we can't automitcaly verify the most simple specification, e.g. that the program will always hold for a given input
															\item \script{78}{Overview Model Checking decidable (f.)}, make a certain restriction we will say that the model of the system it will throw away so many things until we can come to a model that has only finitely many states, can represent the model as a graph, when you think of the behavior as a sequence of state changes then for finate state models you will use finite graphs to represent the system, % and the state changes so state change is then an arrow between two nodes where each node represents a state and when you have finally many states then this can work because then you take a graph with finally many notes 
															also restrict to a certain class of requirements that we call temporal formulas and this is restricted way to talk about properties of the finite state models so the restriction lies in the fact that you don't say at this time point this happens and then some time points later something else happens and then sometimes before something else must have happened so you don't talk about precise time points but you only talk about relative position of time points to each other, $\square$: always at any point of time, $\triangle$: at some later point of time
														\end{itemize}
													\end{minipage}
												}
											}
									}
							}
					}
				child {
						node {Not categorizable definitions
								\resizebox{\textwidth}{!}{
									\begin{minipage}[t]{12cm}
										\begin{itemize}
											\item \alert{Correct computer system:} Absence of faulty, undesired system behaviors
											\begin{itemize}
												\item \alert{error:} Behaviour of a system that we don't want
											\end{itemize}
											\item \alert{Erroneous computer system}: Existence of faulty, undesired system behaviors
											\item \alert{Formal methods}: Applied mathematics for modelling and analysing CPS
											\item \alert{Verification}: Did I build my system right, does my system satisfy the correctness properties. Refers to specific properties that are written down somewhere
											\item \alert{Validation}: Did I build the right system, that I wanted to build? I more a subjective impression, does e.g. the car behave the way I expect?
											\begin{itemize}
												\item in the slides Validation $=$ Verication about properties
											\end{itemize}
										\end{itemize}
									\end{minipage}
								}
							}
					}
				% \begin{itemize}
				%   \item \script{75}{Schema for formal verification (ff.)}
				%   \item \script{80}{Comparison to other validation techniques}
				% \end{itemize}
				child {
						node {Structured operational semantics (SOS)
								\resizebox{\textwidth}{!}{
									\begin{minipage}[t]{12cm}
										\begin{itemize}
											\item \script{268}{Definition and Example}
											\item \script{413}{Other Example}
										\end{itemize}
									\end{minipage}
								}
							}
					}
				child {
						node {Formal Languages
								\resizebox{\textwidth}{!}{
									\begin{minipage}[t]{12cm}
										\begin{itemize}
											\item \script{6}{Alphabet and letters / symbols}
											\item \script{7}{Word}
											\item \script{11}{Concatenation}
											\item \script{12}{Language}
										\end{itemize}
									\end{minipage}
								}
							}
					}
				child {
						node {Non-deterministic finite automata
								\resizebox{\textwidth}{!}{
									\begin{minipage}[t]{12cm}
										\begin{itemize}
											\item \script{29}{Definition}
											\begin{itemize}
												\item \script{15}{Terms}
												\item \script{31}{Example (ff.)}
											\end{itemize}
											\item \script{16}{Acceptance}
											\begin{itemize}
												\item \script{23}{Example}
												\item \script{27}{Accepted Language and example}
											\end{itemize}
										\end{itemize}
									\end{minipage}
								}
							}
						child {
								node {Emptyness Check
										\resizebox{\textwidth}{!}{
											\begin{minipage}[t]{12cm}
												\begin{itemize}
													\item \script{86}{Definition}
													\item \script{87}{Algorithm (f.)}
													\begin{itemize}
														\item \script{100}{Example}
													\end{itemize}
												\end{itemize}
											\end{minipage}
										}
									}
							}
						child {
								node {Intersection Construction
										\resizebox{\textwidth}{!}{
											\begin{minipage}[t]{12cm}
												\begin{itemize}
													\item \script{102}{Definition}
													\item \script{104}{Example}
												\end{itemize}
											\end{minipage}
										}
									}
							}
					}
				child {
						node {Büchi Automata
								\resizebox{\textwidth}{!}{
									\begin{minipage}[t]{12cm}
										\begin{itemize}
											\item \script{111}{Definition}
											\item \script{112}{Acceptance condition (f.)}
											\begin{itemize}
												\item \script{119}{Example}
												\item \script{122}{Language of a Büchi Automaton and Example}
											\end{itemize}
										\end{itemize}
									\end{minipage}
								}
							}
						child {
								node {$\omega$-Word and $\omega$-Language
										\resizebox{\textwidth}{!}{
											\begin{minipage}[t]{12cm}
												\begin{itemize}
													\item \script{107}{$\omega$-Word Definition}
													\item \script{109}{$\omega$-Language Definition}
												\end{itemize}
											\end{minipage}
										}
									}
							}
					}
			}
	\end{mindmapcontent}
	\begin{edges}
		\edge{test}{middle}
		\edge{interleavingoperator}{concurrency}
		\edge{interleavingoperator}{arbiter}
	\end{edges}
	\annotation{middle.south}{
		\resizebox{\textwidth}{!}{
			\begin{minipage}[t]{12cm}
				\printbibliography[heading=none]
			\end{minipage}
		}
	}
\end{mindmap}
\end{document}
% whatever: 448
